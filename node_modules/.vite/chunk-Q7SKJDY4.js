var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};

// node_modules/dom7/dom7.esm.js
var dom7_esm_exports = {};
__export(dom7_esm_exports, {
  $: () => $,
  add: () => add,
  addClass: () => addClass,
  animate: () => animate,
  animationEnd: () => animationEnd,
  append: () => append,
  appendTo: () => appendTo,
  attr: () => attr,
  blur: () => blur,
  change: () => change,
  children: () => children,
  click: () => click,
  closest: () => closest,
  css: () => css,
  data: () => data,
  dataset: () => dataset,
  default: () => dom7_esm_default,
  detach: () => detach,
  each: () => each,
  empty: () => empty,
  eq: () => eq,
  filter: () => filter,
  find: () => find,
  focus: () => focus,
  focusin: () => focusin,
  focusout: () => focusout,
  hasClass: () => hasClass,
  height: () => height,
  hide: () => hide,
  html: () => html,
  index: () => index,
  insertAfter: () => insertAfter,
  insertBefore: () => insertBefore,
  is: () => is,
  keydown: () => keydown,
  keypress: () => keypress,
  keyup: () => keyup,
  mousedown: () => mousedown,
  mouseenter: () => mouseenter,
  mouseleave: () => mouseleave,
  mousemove: () => mousemove,
  mouseout: () => mouseout,
  mouseover: () => mouseover,
  mouseup: () => mouseup,
  next: () => next,
  nextAll: () => nextAll,
  off: () => off,
  offset: () => offset,
  on: () => on,
  once: () => once,
  outerHeight: () => outerHeight,
  outerWidth: () => outerWidth,
  parent: () => parent,
  parents: () => parents,
  prepend: () => prepend,
  prependTo: () => prependTo,
  prev: () => prev,
  prevAll: () => prevAll,
  prop: () => prop,
  remove: () => remove,
  removeAttr: () => removeAttr,
  removeClass: () => removeClass,
  removeData: () => removeData,
  resize: () => resize,
  scroll: () => scroll,
  scrollLeft: () => scrollLeft,
  scrollTo: () => scrollTo,
  scrollTop: () => scrollTop,
  show: () => show,
  siblings: () => siblings,
  stop: () => stop,
  styles: () => styles,
  submit: () => submit,
  text: () => text,
  toggleClass: () => toggleClass,
  touchend: () => touchend,
  touchmove: () => touchmove,
  touchstart: () => touchstart,
  transform: () => transform,
  transition: () => transition,
  transitionEnd: () => transitionEnd,
  trigger: () => trigger,
  val: () => val,
  value: () => value,
  width: () => width
});

// node_modules/ssr-window/ssr-window.esm.js
function isObject(obj) {
  return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
}
function extend(target, src) {
  if (target === void 0) {
    target = {};
  }
  if (src === void 0) {
    src = {};
  }
  Object.keys(src).forEach(function(key) {
    if (typeof target[key] === "undefined")
      target[key] = src[key];
    else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
      extend(target[key], src[key]);
    }
  });
}
var ssrDocument = {
  body: {},
  addEventListener: function() {
  },
  removeEventListener: function() {
  },
  activeElement: {
    blur: function() {
    },
    nodeName: ""
  },
  querySelector: function() {
    return null;
  },
  querySelectorAll: function() {
    return [];
  },
  getElementById: function() {
    return null;
  },
  createEvent: function() {
    return {
      initEvent: function() {
      }
    };
  },
  createElement: function() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute: function() {
      },
      getElementsByTagName: function() {
        return [];
      }
    };
  },
  createElementNS: function() {
    return {};
  },
  importNode: function() {
    return null;
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  }
};
function getDocument() {
  var doc = typeof document !== "undefined" ? document : {};
  extend(doc, ssrDocument);
  return doc;
}
var ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ""
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  },
  history: {
    replaceState: function() {
    },
    pushState: function() {
    },
    go: function() {
    },
    back: function() {
    }
  },
  CustomEvent: function CustomEvent() {
    return this;
  },
  addEventListener: function() {
  },
  removeEventListener: function() {
  },
  getComputedStyle: function() {
    return {
      getPropertyValue: function() {
        return "";
      }
    };
  },
  Image: function() {
  },
  Date: function() {
  },
  screen: {},
  setTimeout: function() {
  },
  clearTimeout: function() {
  },
  matchMedia: function() {
    return {};
  },
  requestAnimationFrame: function(callback) {
    if (typeof setTimeout === "undefined") {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame: function(id2) {
    if (typeof setTimeout === "undefined") {
      return;
    }
    clearTimeout(id2);
  }
};
function getWindow() {
  var win = typeof window !== "undefined" ? window : {};
  extend(win, ssrWindow);
  return win;
}

// node_modules/dom7/dom7.esm.js
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf5(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct5(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper3(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function makeReactive(obj) {
  var proto = obj.__proto__;
  Object.defineProperty(obj, "__proto__", {
    get: function get2() {
      return proto;
    },
    set: function set(value2) {
      proto.__proto__ = value2;
    }
  });
}
var Dom7 = function(_Array) {
  _inheritsLoose(Dom72, _Array);
  function Dom72(items) {
    var _this;
    _this = _Array.call.apply(_Array, [this].concat(items)) || this;
    makeReactive(_assertThisInitialized(_this));
    return _this;
  }
  return Dom72;
}(_wrapNativeSuper(Array));
function arrayFlat(arr) {
  if (arr === void 0) {
    arr = [];
  }
  var res = [];
  arr.forEach(function(el) {
    if (Array.isArray(el)) {
      res.push.apply(res, arrayFlat(el));
    } else {
      res.push(el);
    }
  });
  return res;
}
function arrayFilter(arr, callback) {
  return Array.prototype.filter.call(arr, callback);
}
function arrayUnique(arr) {
  var uniqueArray = [];
  for (var i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1)
      uniqueArray.push(arr[i]);
  }
  return uniqueArray;
}
function toCamelCase(string) {
  return string.toLowerCase().replace(/-(.)/g, function(match, group) {
    return group.toUpperCase();
  });
}
function qsa(selector, context) {
  if (typeof selector !== "string") {
    return [selector];
  }
  var a = [];
  var res = context.querySelectorAll(selector);
  for (var i = 0; i < res.length; i += 1) {
    a.push(res[i]);
  }
  return a;
}
function $(selector, context) {
  var window2 = getWindow();
  var document2 = getDocument();
  var arr = [];
  if (!context && selector instanceof Dom7) {
    return selector;
  }
  if (!selector) {
    return new Dom7(arr);
  }
  if (typeof selector === "string") {
    var html2 = selector.trim();
    if (html2.indexOf("<") >= 0 && html2.indexOf(">") >= 0) {
      var toCreate = "div";
      if (html2.indexOf("<li") === 0)
        toCreate = "ul";
      if (html2.indexOf("<tr") === 0)
        toCreate = "tbody";
      if (html2.indexOf("<td") === 0 || html2.indexOf("<th") === 0)
        toCreate = "tr";
      if (html2.indexOf("<tbody") === 0)
        toCreate = "table";
      if (html2.indexOf("<option") === 0)
        toCreate = "select";
      var tempParent = document2.createElement(toCreate);
      tempParent.innerHTML = html2;
      for (var i = 0; i < tempParent.childNodes.length; i += 1) {
        arr.push(tempParent.childNodes[i]);
      }
    } else {
      arr = qsa(selector.trim(), context || document2);
    }
  } else if (selector.nodeType || selector === window2 || selector === document2) {
    arr.push(selector);
  } else if (Array.isArray(selector)) {
    if (selector instanceof Dom7)
      return selector;
    arr = selector;
  }
  return new Dom7(arrayUnique(arr));
}
$.fn = Dom7.prototype;
function addClass() {
  for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
    classes[_key] = arguments[_key];
  }
  var classNames = arrayFlat(classes.map(function(c) {
    return c.split(" ");
  }));
  this.forEach(function(el) {
    var _el$classList;
    (_el$classList = el.classList).add.apply(_el$classList, classNames);
  });
  return this;
}
function removeClass() {
  for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    classes[_key2] = arguments[_key2];
  }
  var classNames = arrayFlat(classes.map(function(c) {
    return c.split(" ");
  }));
  this.forEach(function(el) {
    var _el$classList2;
    (_el$classList2 = el.classList).remove.apply(_el$classList2, classNames);
  });
  return this;
}
function toggleClass() {
  for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    classes[_key3] = arguments[_key3];
  }
  var classNames = arrayFlat(classes.map(function(c) {
    return c.split(" ");
  }));
  this.forEach(function(el) {
    classNames.forEach(function(className) {
      el.classList.toggle(className);
    });
  });
}
function hasClass() {
  for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    classes[_key4] = arguments[_key4];
  }
  var classNames = arrayFlat(classes.map(function(c) {
    return c.split(" ");
  }));
  return arrayFilter(this, function(el) {
    return classNames.filter(function(className) {
      return el.classList.contains(className);
    }).length > 0;
  }).length > 0;
}
function attr(attrs, value2) {
  if (arguments.length === 1 && typeof attrs === "string") {
    if (this[0])
      return this[0].getAttribute(attrs);
    return void 0;
  }
  for (var i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      this[i].setAttribute(attrs, value2);
    } else {
      for (var attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }
  return this;
}
function removeAttr(attr2) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr2);
  }
  return this;
}
function prop(props, value2) {
  if (arguments.length === 1 && typeof props === "string") {
    if (this[0])
      return this[0][props];
  } else {
    for (var i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        this[i][props] = value2;
      } else {
        for (var propName in props) {
          this[i][propName] = props[propName];
        }
      }
    }
    return this;
  }
  return this;
}
function data(key, value2) {
  var el;
  if (typeof value2 === "undefined") {
    el = this[0];
    if (!el)
      return void 0;
    if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
      return el.dom7ElementDataStorage[key];
    }
    var dataKey = el.getAttribute("data-" + key);
    if (dataKey) {
      return dataKey;
    }
    return void 0;
  }
  for (var i = 0; i < this.length; i += 1) {
    el = this[i];
    if (!el.dom7ElementDataStorage)
      el.dom7ElementDataStorage = {};
    el.dom7ElementDataStorage[key] = value2;
  }
  return this;
}
function removeData(key) {
  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];
    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
      el.dom7ElementDataStorage[key] = null;
      delete el.dom7ElementDataStorage[key];
    }
  }
}
function dataset() {
  var el = this[0];
  if (!el)
    return void 0;
  var dataset2 = {};
  if (el.dataset) {
    for (var dataKey in el.dataset) {
      dataset2[dataKey] = el.dataset[dataKey];
    }
  } else {
    for (var i = 0; i < el.attributes.length; i += 1) {
      var _attr = el.attributes[i];
      if (_attr.name.indexOf("data-") >= 0) {
        dataset2[toCamelCase(_attr.name.split("data-")[1])] = _attr.value;
      }
    }
  }
  for (var key in dataset2) {
    if (dataset2[key] === "false")
      dataset2[key] = false;
    else if (dataset2[key] === "true")
      dataset2[key] = true;
    else if (parseFloat(dataset2[key]) === dataset2[key] * 1)
      dataset2[key] *= 1;
  }
  return dataset2;
}
function val(value2) {
  if (typeof value2 === "undefined") {
    var el = this[0];
    if (!el)
      return void 0;
    if (el.multiple && el.nodeName.toLowerCase() === "select") {
      var values = [];
      for (var i = 0; i < el.selectedOptions.length; i += 1) {
        values.push(el.selectedOptions[i].value);
      }
      return values;
    }
    return el.value;
  }
  for (var _i = 0; _i < this.length; _i += 1) {
    var _el = this[_i];
    if (Array.isArray(value2) && _el.multiple && _el.nodeName.toLowerCase() === "select") {
      for (var j = 0; j < _el.options.length; j += 1) {
        _el.options[j].selected = value2.indexOf(_el.options[j].value) >= 0;
      }
    } else {
      _el.value = value2;
    }
  }
  return this;
}
function value(value2) {
  return this.val(value2);
}
function transform(transform2) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].style.transform = transform2;
  }
  return this;
}
function transition(duration) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].style.transitionDuration = typeof duration !== "string" ? duration + "ms" : duration;
  }
  return this;
}
function on() {
  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    args[_key5] = arguments[_key5];
  }
  var eventType = args[0], targetSelector = args[1], listener = args[2], capture = args[3];
  if (typeof args[1] === "function") {
    eventType = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = void 0;
  }
  if (!capture)
    capture = false;
  function handleLiveEvent(e) {
    var target = e.target;
    if (!target)
      return;
    var eventData = e.target.dom7EventData || [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    if ($(target).is(targetSelector))
      listener.apply(target, eventData);
    else {
      var _parents = $(target).parents();
      for (var k = 0; k < _parents.length; k += 1) {
        if ($(_parents[k]).is(targetSelector))
          listener.apply(_parents[k], eventData);
      }
    }
  }
  function handleEvent(e) {
    var eventData = e && e.target ? e.target.dom7EventData || [] : [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    listener.apply(this, eventData);
  }
  var events = eventType.split(" ");
  var j;
  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];
    if (!targetSelector) {
      for (j = 0; j < events.length; j += 1) {
        var event2 = events[j];
        if (!el.dom7Listeners)
          el.dom7Listeners = {};
        if (!el.dom7Listeners[event2])
          el.dom7Listeners[event2] = [];
        el.dom7Listeners[event2].push({
          listener,
          proxyListener: handleEvent
        });
        el.addEventListener(event2, handleEvent, capture);
      }
    } else {
      for (j = 0; j < events.length; j += 1) {
        var _event = events[j];
        if (!el.dom7LiveListeners)
          el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[_event])
          el.dom7LiveListeners[_event] = [];
        el.dom7LiveListeners[_event].push({
          listener,
          proxyListener: handleLiveEvent
        });
        el.addEventListener(_event, handleLiveEvent, capture);
      }
    }
  }
  return this;
}
function off() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }
  var eventType = args[0], targetSelector = args[1], listener = args[2], capture = args[3];
  if (typeof args[1] === "function") {
    eventType = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = void 0;
  }
  if (!capture)
    capture = false;
  var events = eventType.split(" ");
  for (var i = 0; i < events.length; i += 1) {
    var event2 = events[i];
    for (var j = 0; j < this.length; j += 1) {
      var el = this[j];
      var handlers = void 0;
      if (!targetSelector && el.dom7Listeners) {
        handlers = el.dom7Listeners[event2];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers = el.dom7LiveListeners[event2];
      }
      if (handlers && handlers.length) {
        for (var k = handlers.length - 1; k >= 0; k -= 1) {
          var handler = handlers[k];
          if (listener && handler.listener === listener) {
            el.removeEventListener(event2, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
            el.removeEventListener(event2, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (!listener) {
            el.removeEventListener(event2, handler.proxyListener, capture);
            handlers.splice(k, 1);
          }
        }
      }
    }
  }
  return this;
}
function once() {
  var dom = this;
  for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
    args[_key7] = arguments[_key7];
  }
  var eventName = args[0], targetSelector = args[1], listener = args[2], capture = args[3];
  if (typeof args[1] === "function") {
    eventName = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = void 0;
  }
  function onceHandler() {
    for (var _len8 = arguments.length, eventArgs = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      eventArgs[_key8] = arguments[_key8];
    }
    listener.apply(this, eventArgs);
    dom.off(eventName, targetSelector, onceHandler, capture);
    if (onceHandler.dom7proxy) {
      delete onceHandler.dom7proxy;
    }
  }
  onceHandler.dom7proxy = listener;
  return dom.on(eventName, targetSelector, onceHandler, capture);
}
function trigger() {
  var window2 = getWindow();
  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
    args[_key9] = arguments[_key9];
  }
  var events = args[0].split(" ");
  var eventData = args[1];
  for (var i = 0; i < events.length; i += 1) {
    var event2 = events[i];
    for (var j = 0; j < this.length; j += 1) {
      var el = this[j];
      if (window2.CustomEvent) {
        var evt = new window2.CustomEvent(event2, {
          detail: eventData,
          bubbles: true,
          cancelable: true
        });
        el.dom7EventData = args.filter(function(data2, dataIndex) {
          return dataIndex > 0;
        });
        el.dispatchEvent(evt);
        el.dom7EventData = [];
        delete el.dom7EventData;
      }
    }
  }
  return this;
}
function transitionEnd(callback) {
  var dom = this;
  function fireCallBack(e) {
    if (e.target !== this)
      return;
    callback.call(this, e);
    dom.off("transitionend", fireCallBack);
  }
  if (callback) {
    dom.on("transitionend", fireCallBack);
  }
  return this;
}
function animationEnd(callback) {
  var dom = this;
  function fireCallBack(e) {
    if (e.target !== this)
      return;
    callback.call(this, e);
    dom.off("animationend", fireCallBack);
  }
  if (callback) {
    dom.on("animationend", fireCallBack);
  }
  return this;
}
function width() {
  var window2 = getWindow();
  if (this[0] === window2) {
    return window2.innerWidth;
  }
  if (this.length > 0) {
    return parseFloat(this.css("width"));
  }
  return null;
}
function outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      var _styles = this.styles();
      return this[0].offsetWidth + parseFloat(_styles.getPropertyValue("margin-right")) + parseFloat(_styles.getPropertyValue("margin-left"));
    }
    return this[0].offsetWidth;
  }
  return null;
}
function height() {
  var window2 = getWindow();
  if (this[0] === window2) {
    return window2.innerHeight;
  }
  if (this.length > 0) {
    return parseFloat(this.css("height"));
  }
  return null;
}
function outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      var _styles2 = this.styles();
      return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue("margin-top")) + parseFloat(_styles2.getPropertyValue("margin-bottom"));
    }
    return this[0].offsetHeight;
  }
  return null;
}
function offset() {
  if (this.length > 0) {
    var window2 = getWindow();
    var document2 = getDocument();
    var el = this[0];
    var box = el.getBoundingClientRect();
    var body = document2.body;
    var clientTop = el.clientTop || body.clientTop || 0;
    var clientLeft = el.clientLeft || body.clientLeft || 0;
    var scrollTop2 = el === window2 ? window2.scrollY : el.scrollTop;
    var scrollLeft2 = el === window2 ? window2.scrollX : el.scrollLeft;
    return {
      top: box.top + scrollTop2 - clientTop,
      left: box.left + scrollLeft2 - clientLeft
    };
  }
  return null;
}
function hide() {
  for (var i = 0; i < this.length; i += 1) {
    this[i].style.display = "none";
  }
  return this;
}
function show() {
  var window2 = getWindow();
  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];
    if (el.style.display === "none") {
      el.style.display = "";
    }
    if (window2.getComputedStyle(el, null).getPropertyValue("display") === "none") {
      el.style.display = "block";
    }
  }
  return this;
}
function styles() {
  var window2 = getWindow();
  if (this[0])
    return window2.getComputedStyle(this[0], null);
  return {};
}
function css(props, value2) {
  var window2 = getWindow();
  var i;
  if (arguments.length === 1) {
    if (typeof props === "string") {
      if (this[0])
        return window2.getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      for (i = 0; i < this.length; i += 1) {
        for (var _prop in props) {
          this[i].style[_prop] = props[_prop];
        }
      }
      return this;
    }
  }
  if (arguments.length === 2 && typeof props === "string") {
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props] = value2;
    }
    return this;
  }
  return this;
}
function each(callback) {
  if (!callback)
    return this;
  this.forEach(function(el, index2) {
    callback.apply(el, [el, index2]);
  });
  return this;
}
function filter(callback) {
  var result = arrayFilter(this, callback);
  return $(result);
}
function html(html2) {
  if (typeof html2 === "undefined") {
    return this[0] ? this[0].innerHTML : null;
  }
  for (var i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html2;
  }
  return this;
}
function text(text2) {
  if (typeof text2 === "undefined") {
    return this[0] ? this[0].textContent.trim() : null;
  }
  for (var i = 0; i < this.length; i += 1) {
    this[i].textContent = text2;
  }
  return this;
}
function is(selector) {
  var window2 = getWindow();
  var document2 = getDocument();
  var el = this[0];
  var compareWith;
  var i;
  if (!el || typeof selector === "undefined")
    return false;
  if (typeof selector === "string") {
    if (el.matches)
      return el.matches(selector);
    if (el.webkitMatchesSelector)
      return el.webkitMatchesSelector(selector);
    if (el.msMatchesSelector)
      return el.msMatchesSelector(selector);
    compareWith = $(selector);
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el)
        return true;
    }
    return false;
  }
  if (selector === document2) {
    return el === document2;
  }
  if (selector === window2) {
    return el === window2;
  }
  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el)
        return true;
    }
    return false;
  }
  return false;
}
function index() {
  var child = this[0];
  var i;
  if (child) {
    i = 0;
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1)
        i += 1;
    }
    return i;
  }
  return void 0;
}
function eq(index2) {
  if (typeof index2 === "undefined")
    return this;
  var length = this.length;
  if (index2 > length - 1) {
    return $([]);
  }
  if (index2 < 0) {
    var returnIndex = length + index2;
    if (returnIndex < 0)
      return $([]);
    return $([this[returnIndex]]);
  }
  return $([this[index2]]);
}
function append() {
  var newChild;
  var document2 = getDocument();
  for (var k = 0; k < arguments.length; k += 1) {
    newChild = k < 0 || arguments.length <= k ? void 0 : arguments[k];
    for (var i = 0; i < this.length; i += 1) {
      if (typeof newChild === "string") {
        var tempDiv = document2.createElement("div");
        tempDiv.innerHTML = newChild;
        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (var j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }
  return this;
}
function appendTo(parent2) {
  $(parent2).append(this);
  return this;
}
function prepend(newChild) {
  var document2 = getDocument();
  var i;
  var j;
  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === "string") {
      var tempDiv = document2.createElement("div");
      tempDiv.innerHTML = newChild;
      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }
  return this;
}
function prependTo(parent2) {
  $(parent2).prepend(this);
  return this;
}
function insertBefore(selector) {
  var before = $(selector);
  for (var i = 0; i < this.length; i += 1) {
    if (before.length === 1) {
      before[0].parentNode.insertBefore(this[i], before[0]);
    } else if (before.length > 1) {
      for (var j = 0; j < before.length; j += 1) {
        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
      }
    }
  }
}
function insertAfter(selector) {
  var after = $(selector);
  for (var i = 0; i < this.length; i += 1) {
    if (after.length === 1) {
      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
    } else if (after.length > 1) {
      for (var j = 0; j < after.length; j += 1) {
        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
      }
    }
  }
}
function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
        return $([this[0].nextElementSibling]);
      }
      return $([]);
    }
    if (this[0].nextElementSibling)
      return $([this[0].nextElementSibling]);
    return $([]);
  }
  return $([]);
}
function nextAll(selector) {
  var nextEls = [];
  var el = this[0];
  if (!el)
    return $([]);
  while (el.nextElementSibling) {
    var _next = el.nextElementSibling;
    if (selector) {
      if ($(_next).is(selector))
        nextEls.push(_next);
    } else
      nextEls.push(_next);
    el = _next;
  }
  return $(nextEls);
}
function prev(selector) {
  if (this.length > 0) {
    var el = this[0];
    if (selector) {
      if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
        return $([el.previousElementSibling]);
      }
      return $([]);
    }
    if (el.previousElementSibling)
      return $([el.previousElementSibling]);
    return $([]);
  }
  return $([]);
}
function prevAll(selector) {
  var prevEls = [];
  var el = this[0];
  if (!el)
    return $([]);
  while (el.previousElementSibling) {
    var _prev = el.previousElementSibling;
    if (selector) {
      if ($(_prev).is(selector))
        prevEls.push(_prev);
    } else
      prevEls.push(_prev);
    el = _prev;
  }
  return $(prevEls);
}
function siblings(selector) {
  return this.nextAll(selector).add(this.prevAll(selector));
}
function parent(selector) {
  var parents2 = [];
  for (var i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if ($(this[i].parentNode).is(selector))
          parents2.push(this[i].parentNode);
      } else {
        parents2.push(this[i].parentNode);
      }
    }
  }
  return $(parents2);
}
function parents(selector) {
  var parents2 = [];
  for (var i = 0; i < this.length; i += 1) {
    var _parent = this[i].parentNode;
    while (_parent) {
      if (selector) {
        if ($(_parent).is(selector))
          parents2.push(_parent);
      } else {
        parents2.push(_parent);
      }
      _parent = _parent.parentNode;
    }
  }
  return $(parents2);
}
function closest(selector) {
  var closest2 = this;
  if (typeof selector === "undefined") {
    return $([]);
  }
  if (!closest2.is(selector)) {
    closest2 = closest2.parents(selector).eq(0);
  }
  return closest2;
}
function find(selector) {
  var foundElements = [];
  for (var i = 0; i < this.length; i += 1) {
    var found = this[i].querySelectorAll(selector);
    for (var j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }
  return $(foundElements);
}
function children(selector) {
  var children2 = [];
  for (var i = 0; i < this.length; i += 1) {
    var childNodes = this[i].children;
    for (var j = 0; j < childNodes.length; j += 1) {
      if (!selector || $(childNodes[j]).is(selector)) {
        children2.push(childNodes[j]);
      }
    }
  }
  return $(children2);
}
function remove() {
  for (var i = 0; i < this.length; i += 1) {
    if (this[i].parentNode)
      this[i].parentNode.removeChild(this[i]);
  }
  return this;
}
function detach() {
  return this.remove();
}
function add() {
  var dom = this;
  var i;
  var j;
  for (var _len10 = arguments.length, els = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
    els[_key10] = arguments[_key10];
  }
  for (i = 0; i < els.length; i += 1) {
    var toAdd = $(els[i]);
    for (j = 0; j < toAdd.length; j += 1) {
      dom.push(toAdd[j]);
    }
  }
  return dom;
}
function empty() {
  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];
    if (el.nodeType === 1) {
      for (var j = 0; j < el.childNodes.length; j += 1) {
        if (el.childNodes[j].parentNode) {
          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
        }
      }
      el.textContent = "";
    }
  }
  return this;
}
function scrollTo() {
  var window2 = getWindow();
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var left = args[0], top = args[1], duration = args[2], easing = args[3], callback = args[4];
  if (args.length === 4 && typeof easing === "function") {
    callback = easing;
    left = args[0];
    top = args[1];
    duration = args[2];
    callback = args[3];
    easing = args[4];
  }
  if (typeof easing === "undefined")
    easing = "swing";
  return this.each(function animate2() {
    var el = this;
    var currentTop;
    var currentLeft;
    var maxTop;
    var maxLeft;
    var newTop;
    var newLeft;
    var scrollTop2;
    var scrollLeft2;
    var animateTop = top > 0 || top === 0;
    var animateLeft = left > 0 || left === 0;
    if (typeof easing === "undefined") {
      easing = "swing";
    }
    if (animateTop) {
      currentTop = el.scrollTop;
      if (!duration) {
        el.scrollTop = top;
      }
    }
    if (animateLeft) {
      currentLeft = el.scrollLeft;
      if (!duration) {
        el.scrollLeft = left;
      }
    }
    if (!duration)
      return;
    if (animateTop) {
      maxTop = el.scrollHeight - el.offsetHeight;
      newTop = Math.max(Math.min(top, maxTop), 0);
    }
    if (animateLeft) {
      maxLeft = el.scrollWidth - el.offsetWidth;
      newLeft = Math.max(Math.min(left, maxLeft), 0);
    }
    var startTime = null;
    if (animateTop && newTop === currentTop)
      animateTop = false;
    if (animateLeft && newLeft === currentLeft)
      animateLeft = false;
    function render(time) {
      if (time === void 0) {
        time = new Date().getTime();
      }
      if (startTime === null) {
        startTime = time;
      }
      var progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      var easeProgress = easing === "linear" ? progress : 0.5 - Math.cos(progress * Math.PI) / 2;
      var done;
      if (animateTop)
        scrollTop2 = currentTop + easeProgress * (newTop - currentTop);
      if (animateLeft)
        scrollLeft2 = currentLeft + easeProgress * (newLeft - currentLeft);
      if (animateTop && newTop > currentTop && scrollTop2 >= newTop) {
        el.scrollTop = newTop;
        done = true;
      }
      if (animateTop && newTop < currentTop && scrollTop2 <= newTop) {
        el.scrollTop = newTop;
        done = true;
      }
      if (animateLeft && newLeft > currentLeft && scrollLeft2 >= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }
      if (animateLeft && newLeft < currentLeft && scrollLeft2 <= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }
      if (done) {
        if (callback)
          callback();
        return;
      }
      if (animateTop)
        el.scrollTop = scrollTop2;
      if (animateLeft)
        el.scrollLeft = scrollLeft2;
      window2.requestAnimationFrame(render);
    }
    window2.requestAnimationFrame(render);
  });
}
function scrollTop() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  var top = args[0], duration = args[1], easing = args[2], callback = args[3];
  if (args.length === 3 && typeof easing === "function") {
    top = args[0];
    duration = args[1];
    callback = args[2];
    easing = args[3];
  }
  var dom = this;
  if (typeof top === "undefined") {
    if (dom.length > 0)
      return dom[0].scrollTop;
    return null;
  }
  return dom.scrollTo(void 0, top, duration, easing, callback);
}
function scrollLeft() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }
  var left = args[0], duration = args[1], easing = args[2], callback = args[3];
  if (args.length === 3 && typeof easing === "function") {
    left = args[0];
    duration = args[1];
    callback = args[2];
    easing = args[3];
  }
  var dom = this;
  if (typeof left === "undefined") {
    if (dom.length > 0)
      return dom[0].scrollLeft;
    return null;
  }
  return dom.scrollTo(left, void 0, duration, easing, callback);
}
function animate(initialProps, initialParams) {
  var window2 = getWindow();
  var els = this;
  var a = {
    props: Object.assign({}, initialProps),
    params: Object.assign({
      duration: 300,
      easing: "swing"
    }, initialParams),
    elements: els,
    animating: false,
    que: [],
    easingProgress: function easingProgress(easing, progress) {
      if (easing === "swing") {
        return 0.5 - Math.cos(progress * Math.PI) / 2;
      }
      if (typeof easing === "function") {
        return easing(progress);
      }
      return progress;
    },
    stop: function stop2() {
      if (a.frameId) {
        window2.cancelAnimationFrame(a.frameId);
      }
      a.animating = false;
      a.elements.each(function(el) {
        var element = el;
        delete element.dom7AnimateInstance;
      });
      a.que = [];
    },
    done: function done(complete) {
      a.animating = false;
      a.elements.each(function(el) {
        var element = el;
        delete element.dom7AnimateInstance;
      });
      if (complete)
        complete(els);
      if (a.que.length > 0) {
        var que = a.que.shift();
        a.animate(que[0], que[1]);
      }
    },
    animate: function animate2(props, params) {
      if (a.animating) {
        a.que.push([props, params]);
        return a;
      }
      var elements = [];
      a.elements.each(function(el, index2) {
        var initialFullValue;
        var initialValue;
        var unit;
        var finalValue;
        var finalFullValue;
        if (!el.dom7AnimateInstance)
          a.elements[index2].dom7AnimateInstance = a;
        elements[index2] = {
          container: el
        };
        Object.keys(props).forEach(function(prop2) {
          initialFullValue = window2.getComputedStyle(el, null).getPropertyValue(prop2).replace(",", ".");
          initialValue = parseFloat(initialFullValue);
          unit = initialFullValue.replace(initialValue, "");
          finalValue = parseFloat(props[prop2]);
          finalFullValue = props[prop2] + unit;
          elements[index2][prop2] = {
            initialFullValue,
            initialValue,
            unit,
            finalValue,
            finalFullValue,
            currentValue: initialValue
          };
        });
      });
      var startTime = null;
      var time;
      var elementsDone = 0;
      var propsDone = 0;
      var done;
      var began = false;
      a.animating = true;
      function render() {
        time = new Date().getTime();
        var progress;
        var easeProgress;
        if (!began) {
          began = true;
          if (params.begin)
            params.begin(els);
        }
        if (startTime === null) {
          startTime = time;
        }
        if (params.progress) {
          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), startTime + params.duration - time < 0 ? 0 : startTime + params.duration - time, startTime);
        }
        elements.forEach(function(element) {
          var el = element;
          if (done || el.done)
            return;
          Object.keys(props).forEach(function(prop2) {
            if (done || el.done)
              return;
            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
            easeProgress = a.easingProgress(params.easing, progress);
            var _el$prop = el[prop2], initialValue = _el$prop.initialValue, finalValue = _el$prop.finalValue, unit = _el$prop.unit;
            el[prop2].currentValue = initialValue + easeProgress * (finalValue - initialValue);
            var currentValue = el[prop2].currentValue;
            if (finalValue > initialValue && currentValue >= finalValue || finalValue < initialValue && currentValue <= finalValue) {
              el.container.style[prop2] = finalValue + unit;
              propsDone += 1;
              if (propsDone === Object.keys(props).length) {
                el.done = true;
                elementsDone += 1;
              }
              if (elementsDone === elements.length) {
                done = true;
              }
            }
            if (done) {
              a.done(params.complete);
              return;
            }
            el.container.style[prop2] = currentValue + unit;
          });
        });
        if (done)
          return;
        a.frameId = window2.requestAnimationFrame(render);
      }
      a.frameId = window2.requestAnimationFrame(render);
      return a;
    }
  };
  if (a.elements.length === 0) {
    return els;
  }
  var animateInstance;
  for (var i = 0; i < a.elements.length; i += 1) {
    if (a.elements[i].dom7AnimateInstance) {
      animateInstance = a.elements[i].dom7AnimateInstance;
    } else
      a.elements[i].dom7AnimateInstance = a;
  }
  if (!animateInstance) {
    animateInstance = a;
  }
  if (initialProps === "stop") {
    animateInstance.stop();
  } else {
    animateInstance.animate(a.props, a.params);
  }
  return els;
}
function stop() {
  var els = this;
  for (var i = 0; i < els.length; i += 1) {
    if (els[i].dom7AnimateInstance) {
      els[i].dom7AnimateInstance.stop();
    }
  }
}
var noTrigger = "resize scroll".split(" ");
function shortcut(name) {
  function eventHandler() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[0] === "undefined") {
      for (var i = 0; i < this.length; i += 1) {
        if (noTrigger.indexOf(name) < 0) {
          if (name in this[i])
            this[i][name]();
          else {
            $(this[i]).trigger(name);
          }
        }
      }
      return this;
    }
    return this.on.apply(this, [name].concat(args));
  }
  return eventHandler;
}
var click = shortcut("click");
var blur = shortcut("blur");
var focus = shortcut("focus");
var focusin = shortcut("focusin");
var focusout = shortcut("focusout");
var keyup = shortcut("keyup");
var keydown = shortcut("keydown");
var keypress = shortcut("keypress");
var submit = shortcut("submit");
var change = shortcut("change");
var mousedown = shortcut("mousedown");
var mousemove = shortcut("mousemove");
var mouseup = shortcut("mouseup");
var mouseenter = shortcut("mouseenter");
var mouseleave = shortcut("mouseleave");
var mouseout = shortcut("mouseout");
var mouseover = shortcut("mouseover");
var touchstart = shortcut("touchstart");
var touchend = shortcut("touchend");
var touchmove = shortcut("touchmove");
var resize = shortcut("resize");
var scroll = shortcut("scroll");
var dom7_esm_default = $;

// node_modules/swiper/esm/utils/dom.js
var Methods = {
  addClass,
  removeClass,
  hasClass,
  toggleClass,
  attr,
  removeAttr,
  transform,
  transition,
  on,
  off,
  trigger,
  transitionEnd,
  outerWidth,
  outerHeight,
  styles,
  offset,
  css,
  each,
  html,
  text,
  is,
  index,
  eq,
  append,
  prepend,
  next,
  nextAll,
  prev,
  prevAll,
  parent,
  parents,
  closest,
  find,
  children,
  filter,
  remove
};
Object.keys(Methods).forEach(function(methodName) {
  Object.defineProperty($.fn, methodName, {
    value: Methods[methodName],
    writable: true
  });
});
var dom_default = $;

// node_modules/swiper/esm/utils/utils.js
function deleteProps(obj) {
  var object = obj;
  Object.keys(object).forEach(function(key) {
    try {
      object[key] = null;
    } catch (e) {
    }
    try {
      delete object[key];
    } catch (e) {
    }
  });
}
function nextTick(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return setTimeout(callback, delay);
}
function now() {
  return Date.now();
}
function getComputedStyle2(el) {
  var window2 = getWindow();
  var style;
  if (window2.getComputedStyle) {
    style = window2.getComputedStyle(el, null);
  }
  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }
  if (!style) {
    style = el.style;
  }
  return style;
}
function getTranslate(el, axis) {
  if (axis === void 0) {
    axis = "x";
  }
  var window2 = getWindow();
  var matrix;
  var curTransform;
  var transformMatrix;
  var curStyle = getComputedStyle2(el, null);
  if (window2.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(",").length > 6) {
      curTransform = curTransform.split(", ").map(function(a) {
        return a.replace(",", ".");
      }).join(", ");
    }
    transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
    matrix = transformMatrix.toString().split(",");
  }
  if (axis === "x") {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m41;
    else if (matrix.length === 16)
      curTransform = parseFloat(matrix[12]);
    else
      curTransform = parseFloat(matrix[4]);
  }
  if (axis === "y") {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m42;
    else if (matrix.length === 16)
      curTransform = parseFloat(matrix[13]);
    else
      curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function isObject2(o) {
  return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
}
function extend2() {
  var to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
  var noExtend = ["__proto__", "constructor", "prototype"];
  for (var i = 1; i < arguments.length; i += 1) {
    var nextSource = i < 0 || arguments.length <= i ? void 0 : arguments[i];
    if (nextSource !== void 0 && nextSource !== null) {
      var keysArray = Object.keys(Object(nextSource)).filter(function(key) {
        return noExtend.indexOf(key) < 0;
      });
      for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        var nextKey = keysArray[nextIndex];
        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          if (isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend2(to[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject2(to[nextKey]) && isObject2(nextSource[nextKey])) {
            to[nextKey] = {};
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              extend2(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function bindModuleMethods(instance, obj) {
  Object.keys(obj).forEach(function(key) {
    if (isObject2(obj[key])) {
      Object.keys(obj[key]).forEach(function(subKey) {
        if (typeof obj[key][subKey] === "function") {
          obj[key][subKey] = obj[key][subKey].bind(instance);
        }
      });
    }
    instance[key] = obj[key];
  });
}

// node_modules/swiper/esm/utils/get-support.js
var support;
function calcSupport() {
  var window2 = getWindow();
  var document2 = getDocument();
  return {
    touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch),
    pointerEvents: !!window2.PointerEvent && "maxTouchPoints" in window2.navigator && window2.navigator.maxTouchPoints >= 0,
    observer: function checkObserver() {
      return "MutationObserver" in window2 || "WebkitMutationObserver" in window2;
    }(),
    passiveListener: function checkPassiveListener() {
      var supportsPassive = false;
      try {
        var opts = Object.defineProperty({}, "passive", {
          get: function get2() {
            supportsPassive = true;
          }
        });
        window2.addEventListener("testPassiveListener", null, opts);
      } catch (e) {
      }
      return supportsPassive;
    }(),
    gestures: function checkGestures() {
      return "ongesturestart" in window2;
    }()
  };
}
function getSupport() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}

// node_modules/swiper/esm/utils/get-device.js
var device;
function calcDevice(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, userAgent = _ref.userAgent;
  var support3 = getSupport();
  var window2 = getWindow();
  var platform = window2.navigator.platform;
  var ua = userAgent || window2.navigator.userAgent;
  var device2 = {
    ios: false,
    android: false
  };
  var screenWidth = window2.screen.width;
  var screenHeight = window2.screen.height;
  var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
  var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  var windows = platform === "Win32";
  var macos = platform === "MacIntel";
  var iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
  if (!ipad && macos && support3.touch && iPadScreens.indexOf(screenWidth + "x" + screenHeight) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad)
      ipad = [0, 1, "13_0_0"];
    macos = false;
  }
  if (android && !windows) {
    device2.os = "android";
    device2.android = true;
  }
  if (ipad || iphone || ipod) {
    device2.os = "ios";
    device2.ios = true;
  }
  return device2;
}
function getDevice(overrides) {
  if (overrides === void 0) {
    overrides = {};
  }
  if (!device) {
    device = calcDevice(overrides);
  }
  return device;
}

// node_modules/swiper/esm/utils/get-browser.js
var browser;
function calcBrowser() {
  var window2 = getWindow();
  function isSafari() {
    var ua = window2.navigator.userAgent.toLowerCase();
    return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
  }
  return {
    isEdge: !!window2.navigator.userAgent.match(/Edge/g),
    isSafari: isSafari(),
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)
  };
}
function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }
  return browser;
}

// node_modules/swiper/esm/modules/resize/resize.js
var supportsResizeObserver = function supportsResizeObserver2() {
  var window2 = getWindow();
  return typeof window2.ResizeObserver !== "undefined";
};
var resize_default = {
  name: "resize",
  create: function create() {
    var swiper = this;
    extend2(swiper, {
      resize: {
        observer: null,
        createObserver: function createObserver() {
          if (!swiper || swiper.destroyed || !swiper.initialized)
            return;
          swiper.resize.observer = new ResizeObserver(function(entries) {
            var width2 = swiper.width, height2 = swiper.height;
            var newWidth = width2;
            var newHeight = height2;
            entries.forEach(function(_ref) {
              var contentBoxSize = _ref.contentBoxSize, contentRect = _ref.contentRect, target = _ref.target;
              if (target && target !== swiper.el)
                return;
              newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
              newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
            });
            if (newWidth !== width2 || newHeight !== height2) {
              swiper.resize.resizeHandler();
            }
          });
          swiper.resize.observer.observe(swiper.el);
        },
        removeObserver: function removeObserver() {
          if (swiper.resize.observer && swiper.resize.observer.unobserve && swiper.el) {
            swiper.resize.observer.unobserve(swiper.el);
            swiper.resize.observer = null;
          }
        },
        resizeHandler: function resizeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized)
            return;
          swiper.emit("beforeResize");
          swiper.emit("resize");
        },
        orientationChangeHandler: function orientationChangeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized)
            return;
          swiper.emit("orientationchange");
        }
      }
    });
  },
  on: {
    init: function init(swiper) {
      var window2 = getWindow();
      if (swiper.params.resizeObserver && supportsResizeObserver()) {
        swiper.resize.createObserver();
        return;
      }
      window2.addEventListener("resize", swiper.resize.resizeHandler);
      window2.addEventListener("orientationchange", swiper.resize.orientationChangeHandler);
    },
    destroy: function destroy(swiper) {
      var window2 = getWindow();
      swiper.resize.removeObserver();
      window2.removeEventListener("resize", swiper.resize.resizeHandler);
      window2.removeEventListener("orientationchange", swiper.resize.orientationChangeHandler);
    }
  }
};

// node_modules/swiper/esm/modules/observer/observer.js
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var Observer = {
  attach: function attach(target, options) {
    if (options === void 0) {
      options = {};
    }
    var window2 = getWindow();
    var swiper = this;
    var ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
    var observer = new ObserverFunc(function(mutations) {
      if (mutations.length === 1) {
        swiper.emit("observerUpdate", mutations[0]);
        return;
      }
      var observerUpdate = function observerUpdate2() {
        swiper.emit("observerUpdate", mutations[0]);
      };
      if (window2.requestAnimationFrame) {
        window2.requestAnimationFrame(observerUpdate);
      } else {
        window2.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === "undefined" ? true : options.attributes,
      childList: typeof options.childList === "undefined" ? true : options.childList,
      characterData: typeof options.characterData === "undefined" ? true : options.characterData
    });
    swiper.observer.observers.push(observer);
  },
  init: function init2() {
    var swiper = this;
    if (!swiper.support.observer || !swiper.params.observer)
      return;
    if (swiper.params.observeParents) {
      var containerParents = swiper.$el.parents();
      for (var i = 0; i < containerParents.length; i += 1) {
        swiper.observer.attach(containerParents[i]);
      }
    }
    swiper.observer.attach(swiper.$el[0], {
      childList: swiper.params.observeSlideChildren
    });
    swiper.observer.attach(swiper.$wrapperEl[0], {
      attributes: false
    });
  },
  destroy: function destroy2() {
    var swiper = this;
    swiper.observer.observers.forEach(function(observer) {
      observer.disconnect();
    });
    swiper.observer.observers = [];
  }
};
var observer_default = {
  name: "observer",
  params: {
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  },
  create: function create2() {
    var swiper = this;
    bindModuleMethods(swiper, {
      observer: _extends({}, Observer, {
        observers: []
      })
    });
  },
  on: {
    init: function init3(swiper) {
      swiper.observer.init();
    },
    destroy: function destroy3(swiper) {
      swiper.observer.destroy();
    }
  }
};

// node_modules/swiper/esm/components/core/modular.js
var modular_default = {
  useParams: function useParams(instanceParams) {
    var instance = this;
    if (!instance.modules)
      return;
    Object.keys(instance.modules).forEach(function(moduleName) {
      var module = instance.modules[moduleName];
      if (module.params) {
        extend2(instanceParams, module.params);
      }
    });
  },
  useModules: function useModules(modulesParams) {
    if (modulesParams === void 0) {
      modulesParams = {};
    }
    var instance = this;
    if (!instance.modules)
      return;
    Object.keys(instance.modules).forEach(function(moduleName) {
      var module = instance.modules[moduleName];
      var moduleParams = modulesParams[moduleName] || {};
      if (module.on && instance.on) {
        Object.keys(module.on).forEach(function(moduleEventName) {
          instance.on(moduleEventName, module.on[moduleEventName]);
        });
      }
      if (module.create) {
        module.create.bind(instance)(moduleParams);
      }
    });
  }
};

// node_modules/swiper/esm/components/core/events-emitter.js
var events_emitter_default = {
  on: function on2(events, handler, priority) {
    var self = this;
    if (typeof handler !== "function")
      return self;
    var method = priority ? "unshift" : "push";
    events.split(" ").forEach(function(event2) {
      if (!self.eventsListeners[event2])
        self.eventsListeners[event2] = [];
      self.eventsListeners[event2][method](handler);
    });
    return self;
  },
  once: function once2(events, handler, priority) {
    var self = this;
    if (typeof handler !== "function")
      return self;
    function onceHandler() {
      self.off(events, onceHandler);
      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      handler.apply(self, args);
    }
    onceHandler.__emitterProxy = handler;
    return self.on(events, onceHandler, priority);
  },
  onAny: function onAny(handler, priority) {
    var self = this;
    if (typeof handler !== "function")
      return self;
    var method = priority ? "unshift" : "push";
    if (self.eventsAnyListeners.indexOf(handler) < 0) {
      self.eventsAnyListeners[method](handler);
    }
    return self;
  },
  offAny: function offAny(handler) {
    var self = this;
    if (!self.eventsAnyListeners)
      return self;
    var index2 = self.eventsAnyListeners.indexOf(handler);
    if (index2 >= 0) {
      self.eventsAnyListeners.splice(index2, 1);
    }
    return self;
  },
  off: function off2(events, handler) {
    var self = this;
    if (!self.eventsListeners)
      return self;
    events.split(" ").forEach(function(event2) {
      if (typeof handler === "undefined") {
        self.eventsListeners[event2] = [];
      } else if (self.eventsListeners[event2]) {
        self.eventsListeners[event2].forEach(function(eventHandler, index2) {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self.eventsListeners[event2].splice(index2, 1);
          }
        });
      }
    });
    return self;
  },
  emit: function emit() {
    var self = this;
    if (!self.eventsListeners)
      return self;
    var events;
    var data2;
    var context;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (typeof args[0] === "string" || Array.isArray(args[0])) {
      events = args[0];
      data2 = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data2 = args[0].data;
      context = args[0].context || self;
    }
    data2.unshift(context);
    var eventsArray = Array.isArray(events) ? events : events.split(" ");
    eventsArray.forEach(function(event2) {
      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
        self.eventsAnyListeners.forEach(function(eventHandler) {
          eventHandler.apply(context, [event2].concat(data2));
        });
      }
      if (self.eventsListeners && self.eventsListeners[event2]) {
        self.eventsListeners[event2].forEach(function(eventHandler) {
          eventHandler.apply(context, data2);
        });
      }
    });
    return self;
  }
};

// node_modules/swiper/esm/components/core/update/updateSize.js
function updateSize() {
  var swiper = this;
  var width2;
  var height2;
  var $el = swiper.$el;
  if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) {
    width2 = swiper.params.width;
  } else {
    width2 = $el[0].clientWidth;
  }
  if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) {
    height2 = swiper.params.height;
  } else {
    height2 = $el[0].clientHeight;
  }
  if (width2 === 0 && swiper.isHorizontal() || height2 === 0 && swiper.isVertical()) {
    return;
  }
  width2 = width2 - parseInt($el.css("padding-left") || 0, 10) - parseInt($el.css("padding-right") || 0, 10);
  height2 = height2 - parseInt($el.css("padding-top") || 0, 10) - parseInt($el.css("padding-bottom") || 0, 10);
  if (Number.isNaN(width2))
    width2 = 0;
  if (Number.isNaN(height2))
    height2 = 0;
  extend2(swiper, {
    width: width2,
    height: height2,
    size: swiper.isHorizontal() ? width2 : height2
  });
}

// node_modules/swiper/esm/components/core/update/updateSlides.js
function updateSlides() {
  var swiper = this;
  var getDirectionLabel = function getDirectionLabel2(property) {
    if (swiper.isHorizontal()) {
      return property;
    }
    return {
      width: "height",
      "margin-top": "margin-left",
      "margin-bottom ": "margin-right",
      "margin-left": "margin-top",
      "margin-right": "margin-bottom",
      "padding-left": "padding-top",
      "padding-right": "padding-bottom",
      marginRight: "marginBottom"
    }[property];
  };
  var getDirectionPropertyValue = function getDirectionPropertyValue2(node, label) {
    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
  };
  var params = swiper.params;
  var $wrapperEl = swiper.$wrapperEl, swiperSize = swiper.size, rtl = swiper.rtlTranslate, wrongRTL = swiper.wrongRTL;
  var isVirtual = swiper.virtual && params.virtual.enabled;
  var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  var slides = $wrapperEl.children("." + swiper.params.slideClass);
  var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  var snapGrid = [];
  var slidesGrid = [];
  var slidesSizesGrid = [];
  function slidesForMargin(slideEl, slideIndex) {
    if (!params.cssMode)
      return true;
    if (slideIndex === slides.length - 1) {
      return false;
    }
    return true;
  }
  var offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === "function") {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }
  var offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === "function") {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }
  var previousSnapGridLength = swiper.snapGrid.length;
  var previousSlidesGridLength = swiper.slidesGrid.length;
  var spaceBetween = params.spaceBetween;
  var slidePosition = -offsetBefore;
  var prevSlideSize = 0;
  var index2 = 0;
  if (typeof swiperSize === "undefined") {
    return;
  }
  if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
  }
  swiper.virtualSize = -spaceBetween;
  if (rtl)
    slides.css({
      marginLeft: "",
      marginTop: ""
    });
  else
    slides.css({
      marginRight: "",
      marginBottom: ""
    });
  var slidesNumberEvenToRows;
  if (params.slidesPerColumn > 1) {
    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
    }
    if (params.slidesPerView !== "auto" && params.slidesPerColumnFill === "row") {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
    }
  }
  var slideSize;
  var slidesPerColumn = params.slidesPerColumn;
  var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
  var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);
  for (var i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    var slide = slides.eq(i);
    if (params.slidesPerColumn > 1) {
      var newSlideOrderIndex = void 0;
      var column = void 0;
      var row = void 0;
      if (params.slidesPerColumnFill === "row" && params.slidesPerGroup > 1) {
        var groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
        var slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
        var columnsInGroup = groupIndex === 0 ? params.slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
        row = Math.floor(slideIndexInGroup / columnsInGroup);
        column = slideIndexInGroup - row * columnsInGroup + groupIndex * params.slidesPerGroup;
        newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
        slide.css({
          "-webkit-box-ordinal-group": newSlideOrderIndex,
          "-moz-box-ordinal-group": newSlideOrderIndex,
          "-ms-flex-order": newSlideOrderIndex,
          "-webkit-order": newSlideOrderIndex,
          order: newSlideOrderIndex
        });
      } else if (params.slidesPerColumnFill === "column") {
        column = Math.floor(i / slidesPerColumn);
        row = i - column * slidesPerColumn;
        if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
          row += 1;
          if (row >= slidesPerColumn) {
            row = 0;
            column += 1;
          }
        }
      } else {
        row = Math.floor(i / slidesPerRow);
        column = i - row * slidesPerRow;
      }
      slide.css(getDirectionLabel("margin-top"), row !== 0 && params.spaceBetween && params.spaceBetween + "px");
    }
    if (slide.css("display") === "none")
      continue;
    if (params.slidesPerView === "auto") {
      var slideStyles = getComputedStyle(slide[0]);
      var currentTransform = slide[0].style.transform;
      var currentWebKitTransform = slide[0].style.webkitTransform;
      if (currentTransform) {
        slide[0].style.transform = "none";
      }
      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = "none";
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
      } else {
        var width2 = getDirectionPropertyValue(slideStyles, "width");
        var paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
        var paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
        var marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
        var marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
        var boxSizing = slideStyles.getPropertyValue("box-sizing");
        if (boxSizing && boxSizing === "border-box") {
          slideSize = width2 + marginLeft + marginRight;
        } else {
          var _slide$ = slide[0], clientWidth = _slide$.clientWidth, offsetWidth = _slide$.offsetWidth;
          slideSize = width2 + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }
      if (currentTransform) {
        slide[0].style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths)
        slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths)
        slideSize = Math.floor(slideSize);
      if (slides[i]) {
        slides[i].style[getDirectionLabel("width")] = slideSize + "px";
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);
    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0)
        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0)
        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1e3)
        slidePosition = 0;
      if (params.roundLengths)
        slidePosition = Math.floor(slidePosition);
      if (index2 % params.slidesPerGroup === 0)
        snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths)
        slidePosition = Math.floor(slidePosition);
      if ((index2 - Math.min(swiper.params.slidesPerGroupSkip, index2)) % swiper.params.slidesPerGroup === 0)
        snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }
    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index2 += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  var newSlidesGrid;
  if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
    $wrapperEl.css({
      width: swiper.virtualSize + params.spaceBetween + "px"
    });
  }
  if (params.setWrapperSize) {
    var _$wrapperEl$css;
    $wrapperEl.css((_$wrapperEl$css = {}, _$wrapperEl$css[getDirectionLabel("width")] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css));
  }
  if (params.slidesPerColumn > 1) {
    var _$wrapperEl$css2;
    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
    $wrapperEl.css((_$wrapperEl$css2 = {}, _$wrapperEl$css2[getDirectionLabel("width")] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css2));
    if (params.centeredSlides) {
      newSlidesGrid = [];
      for (var _i = 0; _i < snapGrid.length; _i += 1) {
        var slidesGridItem = snapGrid[_i];
        if (params.roundLengths)
          slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[_i] < swiper.virtualSize + snapGrid[0])
          newSlidesGrid.push(slidesGridItem);
      }
      snapGrid = newSlidesGrid;
    }
  }
  if (!params.centeredSlides) {
    newSlidesGrid = [];
    for (var _i2 = 0; _i2 < snapGrid.length; _i2 += 1) {
      var _slidesGridItem = snapGrid[_i2];
      if (params.roundLengths)
        _slidesGridItem = Math.floor(_slidesGridItem);
      if (snapGrid[_i2] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(_slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (snapGrid.length === 0)
    snapGrid = [0];
  if (params.spaceBetween !== 0) {
    var _slides$filter$css;
    var key = swiper.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
    slides.filter(slidesForMargin).css((_slides$filter$css = {}, _slides$filter$css[key] = spaceBetween + "px", _slides$filter$css));
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    var allSlidesSize = 0;
    slidesSizesGrid.forEach(function(slideSizeValue) {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    var maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map(function(snap) {
      if (snap < 0)
        return -offsetBefore;
      if (snap > maxSnap)
        return maxSnap + offsetAfter;
      return snap;
    });
  }
  if (params.centerInsufficientSlides) {
    var _allSlidesSize = 0;
    slidesSizesGrid.forEach(function(slideSizeValue) {
      _allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    _allSlidesSize -= params.spaceBetween;
    if (_allSlidesSize < swiperSize) {
      var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;
      snapGrid.forEach(function(snap, snapIndex) {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach(function(snap, snapIndex) {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  extend2(swiper, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });
  if (slidesLength !== previousSlidesLength) {
    swiper.emit("slidesLengthChange");
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow)
      swiper.checkOverflow();
    swiper.emit("snapGridLengthChange");
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit("slidesGridLengthChange");
  }
  if (params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateSlidesOffset();
  }
}

// node_modules/swiper/esm/components/core/update/updateAutoHeight.js
function updateAutoHeight(speed) {
  var swiper = this;
  var activeSlides = [];
  var newHeight = 0;
  var i;
  if (typeof speed === "number") {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      swiper.visibleSlides.each(function(slide) {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        var index2 = swiper.activeIndex + i;
        if (index2 > swiper.slides.length)
          break;
        activeSlides.push(swiper.slides.eq(index2)[0]);
      }
    }
  } else {
    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
  }
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== "undefined") {
      var height2 = activeSlides[i].offsetHeight;
      newHeight = height2 > newHeight ? height2 : newHeight;
    }
  }
  if (newHeight)
    swiper.$wrapperEl.css("height", newHeight + "px");
}

// node_modules/swiper/esm/components/core/update/updateSlidesOffset.js
function updateSlidesOffset() {
  var swiper = this;
  var slides = swiper.slides;
  for (var i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
}

// node_modules/swiper/esm/components/core/update/updateSlidesProgress.js
function updateSlidesProgress(translate) {
  if (translate === void 0) {
    translate = this && this.translate || 0;
  }
  var swiper = this;
  var params = swiper.params;
  var slides = swiper.slides, rtl = swiper.rtlTranslate;
  if (slides.length === 0)
    return;
  if (typeof slides[0].swiperSlideOffset === "undefined")
    swiper.updateSlidesOffset();
  var offsetCenter = -translate;
  if (rtl)
    offsetCenter = translate;
  slides.removeClass(params.slideVisibleClass);
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];
  for (var i = 0; i < slides.length; i += 1) {
    var slide = slides[i];
    var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);
    if (params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) {
      var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
      var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      var isVisible2 = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
      if (isVisible2) {
        swiper.visibleSlides.push(slide);
        swiper.visibleSlidesIndexes.push(i);
        slides.eq(i).addClass(params.slideVisibleClass);
      }
    }
    slide.progress = rtl ? -slideProgress : slideProgress;
  }
  swiper.visibleSlides = dom_default(swiper.visibleSlides);
}

// node_modules/swiper/esm/components/core/update/updateProgress.js
function updateProgress(translate) {
  var swiper = this;
  if (typeof translate === "undefined") {
    var multiplier = swiper.rtlTranslate ? -1 : 1;
    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }
  var params = swiper.params;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  var progress = swiper.progress, isBeginning = swiper.isBeginning, isEnd = swiper.isEnd;
  var wasBeginning = isBeginning;
  var wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / translatesDiff;
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }
  extend2(swiper, {
    progress,
    isBeginning,
    isEnd
  });
  if (params.watchSlidesProgress || params.watchSlidesVisibility || params.centeredSlides && params.autoHeight)
    swiper.updateSlidesProgress(translate);
  if (isBeginning && !wasBeginning) {
    swiper.emit("reachBeginning toEdge");
  }
  if (isEnd && !wasEnd) {
    swiper.emit("reachEnd toEdge");
  }
  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit("fromEdge");
  }
  swiper.emit("progress", progress);
}

// node_modules/swiper/esm/components/core/update/updateSlidesClasses.js
function updateSlidesClasses() {
  var swiper = this;
  var slides = swiper.slides, params = swiper.params, $wrapperEl = swiper.$wrapperEl, activeIndex = swiper.activeIndex, realIndex = swiper.realIndex;
  var isVirtual = swiper.virtual && params.virtual.enabled;
  slides.removeClass(params.slideActiveClass + " " + params.slideNextClass + " " + params.slidePrevClass + " " + params.slideDuplicateActiveClass + " " + params.slideDuplicateNextClass + " " + params.slideDuplicatePrevClass);
  var activeSlide;
  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find("." + params.slideClass + '[data-swiper-slide-index="' + activeIndex + '"]');
  } else {
    activeSlide = slides.eq(activeIndex);
  }
  activeSlide.addClass(params.slideActiveClass);
  if (params.loop) {
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ')[data-swiper-slide-index="' + realIndex + '"]').addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + '[data-swiper-slide-index="' + realIndex + '"]').addClass(params.slideDuplicateActiveClass);
    }
  }
  var nextSlide = activeSlide.nextAll("." + params.slideClass).eq(0).addClass(params.slideNextClass);
  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  }
  var prevSlide = activeSlide.prevAll("." + params.slideClass).eq(0).addClass(params.slidePrevClass);
  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }
  if (params.loop) {
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ')[data-swiper-slide-index="' + nextSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + '[data-swiper-slide-index="' + nextSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicateNextClass);
    }
    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ')[data-swiper-slide-index="' + prevSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + '[data-swiper-slide-index="' + prevSlide.attr("data-swiper-slide-index") + '"]').addClass(params.slideDuplicatePrevClass);
    }
  }
  swiper.emitSlidesClasses();
}

// node_modules/swiper/esm/components/core/update/updateActiveIndex.js
function updateActiveIndex(newActiveIndex) {
  var swiper = this;
  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  var slidesGrid = swiper.slidesGrid, snapGrid = swiper.snapGrid, params = swiper.params, previousIndex = swiper.activeIndex, previousRealIndex = swiper.realIndex, previousSnapIndex = swiper.snapIndex;
  var activeIndex = newActiveIndex;
  var snapIndex;
  if (typeof activeIndex === "undefined") {
    for (var i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== "undefined") {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    }
    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === "undefined")
        activeIndex = 0;
    }
  }
  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length)
    snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit("snapIndexChange");
    }
    return;
  }
  var realIndex = parseInt(swiper.slides.eq(activeIndex).attr("data-swiper-slide-index") || activeIndex, 10);
  extend2(swiper, {
    snapIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  swiper.emit("activeIndexChange");
  swiper.emit("snapIndexChange");
  if (previousRealIndex !== realIndex) {
    swiper.emit("realIndexChange");
  }
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    swiper.emit("slideChange");
  }
}

// node_modules/swiper/esm/components/core/update/updateClickedSlide.js
function updateClickedSlide(e) {
  var swiper = this;
  var params = swiper.params;
  var slide = dom_default(e.target).closest("." + params.slideClass)[0];
  var slideFound = false;
  var slideIndex;
  if (slide) {
    for (var i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }
  if (slide && slideFound) {
    swiper.clickedSlide = slide;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(dom_default(slide).attr("data-swiper-slide-index"), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = void 0;
    swiper.clickedIndex = void 0;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}

// node_modules/swiper/esm/components/core/update/index.js
var update_default = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};

// node_modules/swiper/esm/components/core/translate/getTranslate.js
function getSwiperTranslate(axis) {
  if (axis === void 0) {
    axis = this.isHorizontal() ? "x" : "y";
  }
  var swiper = this;
  var params = swiper.params, rtl = swiper.rtlTranslate, translate = swiper.translate, $wrapperEl = swiper.$wrapperEl;
  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }
  if (params.cssMode) {
    return translate;
  }
  var currentTranslate = getTranslate($wrapperEl[0], axis);
  if (rtl)
    currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}

// node_modules/swiper/esm/components/core/translate/setTranslate.js
function setTranslate(translate, byController) {
  var swiper = this;
  var rtl = swiper.rtlTranslate, params = swiper.params, $wrapperEl = swiper.$wrapperEl, wrapperEl = swiper.wrapperEl, progress = swiper.progress;
  var x = 0;
  var y = 0;
  var z = 0;
  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }
  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }
  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    $wrapperEl.transform("translate3d(" + x + "px, " + y + "px, " + z + "px)");
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y;
  var newProgress;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }
  swiper.emit("setTranslate", swiper.translate, byController);
}

// node_modules/swiper/esm/components/core/translate/minTranslate.js
function minTranslate() {
  return -this.snapGrid[0];
}

// node_modules/swiper/esm/components/core/translate/maxTranslate.js
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}

// node_modules/swiper/esm/components/core/translate/translateTo.js
function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
  if (translate === void 0) {
    translate = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (translateBounds === void 0) {
    translateBounds = true;
  }
  var swiper = this;
  var params = swiper.params, wrapperEl = swiper.wrapperEl;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  var minTranslate2 = swiper.minTranslate();
  var maxTranslate2 = swiper.maxTranslate();
  var newTranslate;
  if (translateBounds && translate > minTranslate2)
    newTranslate = minTranslate2;
  else if (translateBounds && translate < maxTranslate2)
    newTranslate = maxTranslate2;
  else
    newTranslate = translate;
  swiper.updateProgress(newTranslate);
  if (params.cssMode) {
    var isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
    } else {
      if (wrapperEl.scrollTo) {
        var _wrapperEl$scrollTo;
        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? "left" : "top"] = -newTranslate, _wrapperEl$scrollTo.behavior = "smooth", _wrapperEl$scrollTo));
      } else {
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
      }
    }
    return true;
  }
  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit("beforeTransitionStart", speed, internal);
      swiper.emit("transitionEnd");
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit("beforeTransitionStart", speed, internal);
      swiper.emit("transitionStart");
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd3(e) {
          if (!swiper || swiper.destroyed)
            return;
          if (e.target !== this)
            return;
          swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          if (runCallbacks) {
            swiper.emit("transitionEnd");
          }
        };
      }
      swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onTranslateToWrapperTransitionEnd);
    }
  }
  return true;
}

// node_modules/swiper/esm/components/core/translate/index.js
var translate_default = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};

// node_modules/swiper/esm/components/core/transition/setTransition.js
function setTransition(duration, byController) {
  var swiper = this;
  if (!swiper.params.cssMode) {
    swiper.$wrapperEl.transition(duration);
  }
  swiper.emit("setTransition", duration, byController);
}

// node_modules/swiper/esm/components/core/transition/transitionStart.js
function transitionStart(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  var swiper = this;
  var activeIndex = swiper.activeIndex, params = swiper.params, previousIndex = swiper.previousIndex;
  if (params.cssMode)
    return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }
  var dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex)
      dir = "next";
    else if (activeIndex < previousIndex)
      dir = "prev";
    else
      dir = "reset";
  }
  swiper.emit("transitionStart");
  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === "reset") {
      swiper.emit("slideResetTransitionStart");
      return;
    }
    swiper.emit("slideChangeTransitionStart");
    if (dir === "next") {
      swiper.emit("slideNextTransitionStart");
    } else {
      swiper.emit("slidePrevTransitionStart");
    }
  }
}

// node_modules/swiper/esm/components/core/transition/transitionEnd.js
function transitionEnd2(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  var swiper = this;
  var activeIndex = swiper.activeIndex, previousIndex = swiper.previousIndex, params = swiper.params;
  swiper.animating = false;
  if (params.cssMode)
    return;
  swiper.setTransition(0);
  var dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex)
      dir = "next";
    else if (activeIndex < previousIndex)
      dir = "prev";
    else
      dir = "reset";
  }
  swiper.emit("transitionEnd");
  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === "reset") {
      swiper.emit("slideResetTransitionEnd");
      return;
    }
    swiper.emit("slideChangeTransitionEnd");
    if (dir === "next") {
      swiper.emit("slideNextTransitionEnd");
    } else {
      swiper.emit("slidePrevTransitionEnd");
    }
  }
}

// node_modules/swiper/esm/components/core/transition/index.js
var transition_default = {
  setTransition,
  transitionStart,
  transitionEnd: transitionEnd2
};

// node_modules/swiper/esm/components/core/slide/slideTo.js
function slideTo(index2, speed, runCallbacks, internal) {
  if (index2 === void 0) {
    index2 = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index2 !== "number" && typeof index2 !== "string") {
    throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. [" + typeof index2 + "] given.");
  }
  if (typeof index2 === "string") {
    var indexAsNumber = parseInt(index2, 10);
    var isValidNumber = isFinite(indexAsNumber);
    if (!isValidNumber) {
      throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. [" + index2 + "] given.");
    }
    index2 = indexAsNumber;
  }
  var swiper = this;
  var slideIndex = index2;
  if (slideIndex < 0)
    slideIndex = 0;
  var params = swiper.params, snapGrid = swiper.snapGrid, slidesGrid = swiper.slidesGrid, previousIndex = swiper.previousIndex, activeIndex = swiper.activeIndex, rtl = swiper.rtlTranslate, wrapperEl = swiper.wrapperEl;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length)
    snapIndex = snapGrid.length - 1;
  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit("beforeSlideChangeStart");
  }
  var translate = -snapGrid[snapIndex];
  swiper.updateProgress(translate);
  if (params.normalizeSlideIndex) {
    for (var i = 0; i < slidesGrid.length; i += 1) {
      var normalizedTranslate = -Math.floor(translate * 100);
      var normalizedGird = Math.floor(slidesGrid[i] * 100);
      var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
      if (typeof slidesGrid[i + 1] !== "undefined") {
        if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGird) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGird) {
        slideIndex = i;
      }
    }
  }
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex)
        return false;
    }
  }
  var direction;
  if (slideIndex > activeIndex)
    direction = "next";
  else if (slideIndex < activeIndex)
    direction = "prev";
  else
    direction = "reset";
  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
    swiper.updateActiveIndex(slideIndex);
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== "slide") {
      swiper.setTranslate(translate);
    }
    if (direction !== "reset") {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    var isH = swiper.isHorizontal();
    var t = -translate;
    if (rtl) {
      t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
    }
    if (speed === 0) {
      wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
    } else {
      if (wrapperEl.scrollTo) {
        var _wrapperEl$scrollTo;
        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? "left" : "top"] = t, _wrapperEl$scrollTo.behavior = "smooth", _wrapperEl$scrollTo));
      } else {
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
      }
    }
    return true;
  }
  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit("beforeTransitionStart", speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    swiper.transitionEnd(runCallbacks, direction);
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit("beforeTransitionStart", speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd3(e) {
          if (!swiper || swiper.destroyed)
            return;
          if (e.target !== this)
            return;
          swiper.$wrapperEl[0].removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }
      swiper.$wrapperEl[0].addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener("webkitTransitionEnd", swiper.onSlideToWrapperTransitionEnd);
    }
  }
  return true;
}

// node_modules/swiper/esm/components/core/slide/slideToLoop.js
function slideToLoop(index2, speed, runCallbacks, internal) {
  if (index2 === void 0) {
    index2 = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  var swiper = this;
  var newIndex = index2;
  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }
  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}

// node_modules/swiper/esm/components/core/slide/slideNext.js
function slideNext(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  var swiper = this;
  var params = swiper.params, animating = swiper.animating;
  var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;
  if (params.loop) {
    if (animating && params.loopPreventsSlide)
      return false;
    swiper.loopFix();
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}

// node_modules/swiper/esm/components/core/slide/slidePrev.js
function slidePrev(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  var swiper = this;
  var params = swiper.params, animating = swiper.animating, snapGrid = swiper.snapGrid, slidesGrid = swiper.slidesGrid, rtlTranslate = swiper.rtlTranslate;
  if (params.loop) {
    if (animating && params.loopPreventsSlide)
      return false;
    swiper.loopFix();
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  var translate = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize2(val2) {
    if (val2 < 0)
      return -Math.floor(Math.abs(val2));
    return Math.floor(val2);
  }
  var normalizedTranslate = normalize2(translate);
  var normalizedSnapGrid = snapGrid.map(function(val2) {
    return normalize2(val2);
  });
  var currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
  var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === "undefined" && params.cssMode) {
    snapGrid.forEach(function(snap) {
      if (!prevSnap && normalizedTranslate >= snap)
        prevSnap = snap;
    });
  }
  var prevIndex;
  if (typeof prevSnap !== "undefined") {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0)
      prevIndex = swiper.activeIndex - 1;
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}

// node_modules/swiper/esm/components/core/slide/slideReset.js
function slideReset(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  var swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}

// node_modules/swiper/esm/components/core/slide/slideToClosest.js
function slideToClosest(speed, runCallbacks, internal, threshold) {
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (threshold === void 0) {
    threshold = 0.5;
  }
  var swiper = this;
  var index2 = swiper.activeIndex;
  var skip = Math.min(swiper.params.slidesPerGroupSkip, index2);
  var snapIndex = skip + Math.floor((index2 - skip) / swiper.params.slidesPerGroup);
  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  if (translate >= swiper.snapGrid[snapIndex]) {
    var currentSnap = swiper.snapGrid[snapIndex];
    var nextSnap = swiper.snapGrid[snapIndex + 1];
    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
      index2 += swiper.params.slidesPerGroup;
    }
  } else {
    var prevSnap = swiper.snapGrid[snapIndex - 1];
    var _currentSnap = swiper.snapGrid[snapIndex];
    if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {
      index2 -= swiper.params.slidesPerGroup;
    }
  }
  index2 = Math.max(index2, 0);
  index2 = Math.min(index2, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index2, speed, runCallbacks, internal);
}

// node_modules/swiper/esm/components/core/slide/slideToClickedSlide.js
function slideToClickedSlide() {
  var swiper = this;
  var params = swiper.params, $wrapperEl = swiper.$wrapperEl;
  var slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  var slideToIndex = swiper.clickedIndex;
  var realIndex;
  if (params.loop) {
    if (swiper.animating)
      return;
    realIndex = parseInt(dom_default(swiper.clickedSlide).attr("data-swiper-slide-index"), 10);
    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children("." + params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + params.slideDuplicateClass + ")").eq(0).index();
        nextTick(function() {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl.children("." + params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + params.slideDuplicateClass + ")").eq(0).index();
      nextTick(function() {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}

// node_modules/swiper/esm/components/core/slide/index.js
var slide_default = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};

// node_modules/swiper/esm/components/core/loop/loopCreate.js
function loopCreate() {
  var swiper = this;
  var document2 = getDocument();
  var params = swiper.params, $wrapperEl = swiper.$wrapperEl;
  $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass).remove();
  var slides = $wrapperEl.children("." + params.slideClass);
  if (params.loopFillGroupWithBlank) {
    var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
    if (blankSlidesNum !== params.slidesPerGroup) {
      for (var i = 0; i < blankSlidesNum; i += 1) {
        var blankNode = dom_default(document2.createElement("div")).addClass(params.slideClass + " " + params.slideBlankClass);
        $wrapperEl.append(blankNode);
      }
      slides = $wrapperEl.children("." + params.slideClass);
    }
  }
  if (params.slidesPerView === "auto" && !params.loopedSlides)
    params.loopedSlides = slides.length;
  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
  swiper.loopedSlides += params.loopAdditionalSlides;
  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }
  var prependSlides = [];
  var appendSlides = [];
  slides.each(function(el, index2) {
    var slide = dom_default(el);
    if (index2 < swiper.loopedSlides) {
      appendSlides.push(el);
    }
    if (index2 < slides.length && index2 >= slides.length - swiper.loopedSlides) {
      prependSlides.push(el);
    }
    slide.attr("data-swiper-slide-index", index2);
  });
  for (var _i = 0; _i < appendSlides.length; _i += 1) {
    $wrapperEl.append(dom_default(appendSlides[_i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
  for (var _i2 = prependSlides.length - 1; _i2 >= 0; _i2 -= 1) {
    $wrapperEl.prepend(dom_default(prependSlides[_i2].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}

// node_modules/swiper/esm/components/core/loop/loopFix.js
function loopFix() {
  var swiper = this;
  swiper.emit("beforeLoopFix");
  var activeIndex = swiper.activeIndex, slides = swiper.slides, loopedSlides = swiper.loopedSlides, allowSlidePrev = swiper.allowSlidePrev, allowSlideNext = swiper.allowSlideNext, snapGrid = swiper.snapGrid, rtl = swiper.rtlTranslate;
  var newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  var snapTranslate = -snapGrid[activeIndex];
  var diff = snapTranslate - swiper.getTranslate();
  if (activeIndex < loopedSlides) {
    newIndex = slides.length - loopedSlides * 3 + activeIndex;
    newIndex += loopedSlides;
    var slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if (activeIndex >= slides.length - loopedSlides) {
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;
    var _slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (_slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  swiper.emit("loopFix");
}

// node_modules/swiper/esm/components/core/loop/loopDestroy.js
function loopDestroy() {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl, params = swiper.params, slides = swiper.slides;
  $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + ",." + params.slideClass + "." + params.slideBlankClass).remove();
  slides.removeAttr("data-swiper-slide-index");
}

// node_modules/swiper/esm/components/core/loop/index.js
var loop_default = {
  loopCreate,
  loopFix,
  loopDestroy
};

// node_modules/swiper/esm/components/core/grab-cursor/setGrabCursor.js
function setGrabCursor(moving) {
  var swiper = this;
  if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode)
    return;
  var el = swiper.el;
  el.style.cursor = "move";
  el.style.cursor = moving ? "-webkit-grabbing" : "-webkit-grab";
  el.style.cursor = moving ? "-moz-grabbin" : "-moz-grab";
  el.style.cursor = moving ? "grabbing" : "grab";
}

// node_modules/swiper/esm/components/core/grab-cursor/unsetGrabCursor.js
function unsetGrabCursor() {
  var swiper = this;
  if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }
  swiper.el.style.cursor = "";
}

// node_modules/swiper/esm/components/core/grab-cursor/index.js
var grab_cursor_default = {
  setGrabCursor,
  unsetGrabCursor
};

// node_modules/swiper/esm/components/core/manipulation/appendSlide.js
function appendSlide(slides) {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl, params = swiper.params;
  if (params.loop) {
    swiper.loopDestroy();
  }
  if (typeof slides === "object" && "length" in slides) {
    for (var i = 0; i < slides.length; i += 1) {
      if (slides[i])
        $wrapperEl.append(slides[i]);
    }
  } else {
    $wrapperEl.append(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }
}

// node_modules/swiper/esm/components/core/manipulation/prependSlide.js
function prependSlide(slides) {
  var swiper = this;
  var params = swiper.params, $wrapperEl = swiper.$wrapperEl, activeIndex = swiper.activeIndex;
  if (params.loop) {
    swiper.loopDestroy();
  }
  var newActiveIndex = activeIndex + 1;
  if (typeof slides === "object" && "length" in slides) {
    for (var i = 0; i < slides.length; i += 1) {
      if (slides[i])
        $wrapperEl.prepend(slides[i]);
    }
    newActiveIndex = activeIndex + slides.length;
  } else {
    $wrapperEl.prepend(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }
  swiper.slideTo(newActiveIndex, 0, false);
}

// node_modules/swiper/esm/components/core/manipulation/addSlide.js
function addSlide(index2, slides) {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl, params = swiper.params, activeIndex = swiper.activeIndex;
  var activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children("." + params.slideClass);
  }
  var baseLength = swiper.slides.length;
  if (index2 <= 0) {
    swiper.prependSlide(slides);
    return;
  }
  if (index2 >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }
  var newActiveIndex = activeIndexBuffer > index2 ? activeIndexBuffer + 1 : activeIndexBuffer;
  var slidesBuffer = [];
  for (var i = baseLength - 1; i >= index2; i -= 1) {
    var currentSlide = swiper.slides.eq(i);
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }
  if (typeof slides === "object" && "length" in slides) {
    for (var _i = 0; _i < slides.length; _i += 1) {
      if (slides[_i])
        $wrapperEl.append(slides[_i]);
    }
    newActiveIndex = activeIndexBuffer > index2 ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    $wrapperEl.append(slides);
  }
  for (var _i2 = 0; _i2 < slidesBuffer.length; _i2 += 1) {
    $wrapperEl.append(slidesBuffer[_i2]);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

// node_modules/swiper/esm/components/core/manipulation/removeSlide.js
function removeSlide(slidesIndexes) {
  var swiper = this;
  var params = swiper.params, $wrapperEl = swiper.$wrapperEl, activeIndex = swiper.activeIndex;
  var activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children("." + params.slideClass);
  }
  var newActiveIndex = activeIndexBuffer;
  var indexToRemove;
  if (typeof slidesIndexes === "object" && "length" in slidesIndexes) {
    for (var i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove])
        swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex)
        newActiveIndex -= 1;
    }
    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove])
      swiper.slides.eq(indexToRemove).remove();
    if (indexToRemove < newActiveIndex)
      newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}

// node_modules/swiper/esm/components/core/manipulation/removeAllSlides.js
function removeAllSlides() {
  var swiper = this;
  var slidesIndexes = [];
  for (var i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }
  swiper.removeSlide(slidesIndexes);
}

// node_modules/swiper/esm/components/core/manipulation/index.js
var manipulation_default = {
  appendSlide,
  prependSlide,
  addSlide,
  removeSlide,
  removeAllSlides
};

// node_modules/swiper/esm/components/core/events/onTouchStart.js
function onTouchStart(event2) {
  var swiper = this;
  var document2 = getDocument();
  var window2 = getWindow();
  var data2 = swiper.touchEventsData;
  var params = swiper.params, touches = swiper.touches;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  var e = event2;
  if (e.originalEvent)
    e = e.originalEvent;
  var $targetEl = dom_default(e.target);
  if (params.touchEventsTarget === "wrapper") {
    if (!$targetEl.closest(swiper.wrapperEl).length)
      return;
  }
  data2.isTouchEvent = e.type === "touchstart";
  if (!data2.isTouchEvent && "which" in e && e.which === 3)
    return;
  if (!data2.isTouchEvent && "button" in e && e.button > 0)
    return;
  if (data2.isTouched && data2.isMoved)
    return;
  var swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
  if (swipingClassHasValue && e.target && e.target.shadowRoot && event2.path && event2.path[0]) {
    $targetEl = dom_default(event2.path[0]);
  }
  if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : "." + params.noSwipingClass)[0]) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!$targetEl.closest(params.swipeHandler)[0])
      return;
  }
  touches.currentX = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
  var startX = touches.currentX;
  var startY = touches.currentY;
  var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === "prevent") {
      event2.preventDefault();
    } else {
      return;
    }
  }
  extend2(data2, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: void 0,
    startMoving: void 0
  });
  touches.startX = startX;
  touches.startY = startY;
  data2.touchStartTime = now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = void 0;
  if (params.threshold > 0)
    data2.allowThresholdMove = false;
  if (e.type !== "touchstart") {
    var preventDefault = true;
    if ($targetEl.is(data2.formElements))
      preventDefault = false;
    if (document2.activeElement && dom_default(document2.activeElement).is(data2.formElements) && document2.activeElement !== $targetEl[0]) {
      document2.activeElement.blur();
    }
    var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
      e.preventDefault();
    }
  }
  swiper.emit("touchStart", e);
}

// node_modules/swiper/esm/components/core/events/onTouchMove.js
function onTouchMove(event2) {
  var document2 = getDocument();
  var swiper = this;
  var data2 = swiper.touchEventsData;
  var params = swiper.params, touches = swiper.touches, rtl = swiper.rtlTranslate;
  var e = event2;
  if (e.originalEvent)
    e = e.originalEvent;
  if (!data2.isTouched) {
    if (data2.startMoving && data2.isScrolling) {
      swiper.emit("touchMoveOpposite", e);
    }
    return;
  }
  if (data2.isTouchEvent && e.type !== "touchmove")
    return;
  var targetTouch = e.type === "touchmove" && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
  var pageX = e.type === "touchmove" ? targetTouch.pageX : e.pageX;
  var pageY = e.type === "touchmove" ? targetTouch.pageY : e.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    swiper.allowClick = false;
    if (data2.isTouched) {
      extend2(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data2.touchStartTime = now();
    }
    return;
  }
  if (data2.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data2.isTouched = false;
        data2.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }
  if (data2.isTouchEvent && document2.activeElement) {
    if (e.target === document2.activeElement && dom_default(e.target).is(data2.formElements)) {
      data2.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data2.allowTouchCallbacks) {
    swiper.emit("touchMove", e);
  }
  if (e.targetTouches && e.targetTouches.length > 1)
    return;
  touches.currentX = pageX;
  touches.currentY = pageY;
  var diffX = touches.currentX - touches.startX;
  var diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold)
    return;
  if (typeof data2.isScrolling === "undefined") {
    var touchAngle;
    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data2.isScrolling = false;
    } else {
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data2.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }
  if (data2.isScrolling) {
    swiper.emit("touchMoveOpposite", e);
  }
  if (typeof data2.startMoving === "undefined") {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data2.startMoving = true;
    }
  }
  if (data2.isScrolling) {
    data2.isTouched = false;
    return;
  }
  if (!data2.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }
  if (!data2.isMoved) {
    if (params.loop) {
      swiper.loopFix();
    }
    data2.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      swiper.$wrapperEl.trigger("webkitTransitionEnd transitionend");
    }
    data2.allowMomentumBounce = false;
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit("sliderFirstMove", e);
  }
  swiper.emit("sliderMove", e);
  data2.isMoved = true;
  var diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl)
    diff = -diff;
  swiper.swipeDirection = diff > 0 ? "prev" : "next";
  data2.currentTranslate = diff + data2.startTranslate;
  var disableParentSwiper = true;
  var resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if (diff > 0 && data2.currentTranslate > swiper.minTranslate()) {
    disableParentSwiper = false;
    if (params.resistance)
      data2.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data2.startTranslate + diff, resistanceRatio);
  } else if (diff < 0 && data2.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance)
      data2.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data2.startTranslate - diff, resistanceRatio);
  }
  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }
  if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data2.currentTranslate < data2.startTranslate) {
    data2.currentTranslate = data2.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data2.currentTranslate > data2.startTranslate) {
    data2.currentTranslate = data2.startTranslate;
  }
  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data2.currentTranslate = data2.startTranslate;
  }
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data2.allowThresholdMove) {
      if (!data2.allowThresholdMove) {
        data2.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data2.currentTranslate = data2.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data2.currentTranslate = data2.startTranslate;
      return;
    }
  }
  if (!params.followFinger || params.cssMode)
    return;
  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode) {
    if (data2.velocities.length === 0) {
      data2.velocities.push({
        position: touches[swiper.isHorizontal() ? "startX" : "startY"],
        time: data2.touchStartTime
      });
    }
    data2.velocities.push({
      position: touches[swiper.isHorizontal() ? "currentX" : "currentY"],
      time: now()
    });
  }
  swiper.updateProgress(data2.currentTranslate);
  swiper.setTranslate(data2.currentTranslate);
}

// node_modules/swiper/esm/components/core/events/onTouchEnd.js
function onTouchEnd(event2) {
  var swiper = this;
  var data2 = swiper.touchEventsData;
  var params = swiper.params, touches = swiper.touches, rtl = swiper.rtlTranslate, $wrapperEl = swiper.$wrapperEl, slidesGrid = swiper.slidesGrid, snapGrid = swiper.snapGrid;
  var e = event2;
  if (e.originalEvent)
    e = e.originalEvent;
  if (data2.allowTouchCallbacks) {
    swiper.emit("touchEnd", e);
  }
  data2.allowTouchCallbacks = false;
  if (!data2.isTouched) {
    if (data2.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data2.isMoved = false;
    data2.startMoving = false;
    return;
  }
  if (params.grabCursor && data2.isMoved && data2.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }
  var touchEndTime = now();
  var timeDiff = touchEndTime - data2.touchStartTime;
  if (swiper.allowClick) {
    swiper.updateClickedSlide(e);
    swiper.emit("tap click", e);
    if (timeDiff < 300 && touchEndTime - data2.lastClickTime < 300) {
      swiper.emit("doubleTap doubleClick", e);
    }
  }
  data2.lastClickTime = now();
  nextTick(function() {
    if (!swiper.destroyed)
      swiper.allowClick = true;
  });
  if (!data2.isTouched || !data2.isMoved || !swiper.swipeDirection || touches.diff === 0 || data2.currentTranslate === data2.startTranslate) {
    data2.isTouched = false;
    data2.isMoved = false;
    data2.startMoving = false;
    return;
  }
  data2.isTouched = false;
  data2.isMoved = false;
  data2.startMoving = false;
  var currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data2.currentTranslate;
  }
  if (params.cssMode) {
    return;
  }
  if (params.freeMode) {
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }
      return;
    }
    if (params.freeModeMomentum) {
      if (data2.velocities.length > 1) {
        var lastMoveEvent = data2.velocities.pop();
        var velocityEvent = data2.velocities.pop();
        var distance = lastMoveEvent.position - velocityEvent.position;
        var time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;
        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
          swiper.velocity = 0;
        }
        if (time > 150 || now() - lastMoveEvent.time > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }
      swiper.velocity *= params.freeModeMomentumVelocityRatio;
      data2.velocities.length = 0;
      var momentumDuration = 1e3 * params.freeModeMomentumRatio;
      var momentumDistance = swiper.velocity * momentumDuration;
      var newPosition = swiper.translate + momentumDistance;
      if (rtl)
        newPosition = -newPosition;
      var doBounce = false;
      var afterBouncePosition;
      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
      var needsLoopFix;
      if (newPosition < swiper.maxTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }
          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data2.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }
        if (params.loop && params.centeredSlides)
          needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }
          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data2.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }
        if (params.loop && params.centeredSlides)
          needsLoopFix = true;
      } else if (params.freeModeSticky) {
        var nextSlide;
        for (var j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }
        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === "next") {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }
        newPosition = -newPosition;
      }
      if (needsLoopFix) {
        swiper.once("transitionEnd", function() {
          swiper.loopFix();
        });
      }
      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }
        if (params.freeModeSticky) {
          var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
          var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
          if (moveDistance < currentSlideSize) {
            momentumDuration = params.speed;
          } else if (moveDistance < 2 * currentSlideSize) {
            momentumDuration = params.speed * 1.5;
          } else {
            momentumDuration = params.speed * 2.5;
          }
        }
      } else if (params.freeModeSticky) {
        swiper.slideToClosest();
        return;
      }
      if (params.freeModeMomentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        $wrapperEl.transitionEnd(function() {
          if (!swiper || swiper.destroyed || !data2.allowMomentumBounce)
            return;
          swiper.emit("momentumBounce");
          swiper.setTransition(params.speed);
          setTimeout(function() {
            swiper.setTranslate(afterBouncePosition);
            $wrapperEl.transitionEnd(function() {
              if (!swiper || swiper.destroyed)
                return;
              swiper.transitionEnd();
            });
          }, 0);
        });
      } else if (swiper.velocity) {
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        if (!swiper.animating) {
          swiper.animating = true;
          $wrapperEl.transitionEnd(function() {
            if (!swiper || swiper.destroyed)
              return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.emit("_freeModeNoMomentumRelease");
        swiper.updateProgress(newPosition);
      }
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeModeSticky) {
      swiper.slideToClosest();
      return;
    } else if (params.freeMode) {
      swiper.emit("_freeModeNoMomentumRelease");
    }
    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    return;
  }
  var stopIndex = 0;
  var groupSize = swiper.slidesSizesGrid[0];
  for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (typeof slidesGrid[i + _increment] !== "undefined") {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + _increment] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }
  var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === "next") {
      if (ratio >= params.longSwipesRatio)
        swiper.slideTo(stopIndex + increment);
      else
        swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === "prev") {
      if (ratio > 1 - params.longSwipesRatio)
        swiper.slideTo(stopIndex + increment);
      else
        swiper.slideTo(stopIndex);
    }
  } else {
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === "next") {
        swiper.slideTo(stopIndex + increment);
      }
      if (swiper.swipeDirection === "prev") {
        swiper.slideTo(stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}

// node_modules/swiper/esm/components/core/events/onResize.js
function onResize() {
  var swiper = this;
  var params = swiper.params, el = swiper.el;
  if (el && el.offsetWidth === 0)
    return;
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }
  var allowSlideNext = swiper.allowSlideNext, allowSlidePrev = swiper.allowSlidePrev, snapGrid = swiper.snapGrid;
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();
  if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    swiper.slideTo(swiper.activeIndex, 0, false, true);
  }
  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    swiper.autoplay.run();
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}

// node_modules/swiper/esm/components/core/events/onClick.js
function onClick(e) {
  var swiper = this;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks)
      e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}

// node_modules/swiper/esm/components/core/events/onScroll.js
function onScroll() {
  var swiper = this;
  var wrapperEl = swiper.wrapperEl, rtlTranslate = swiper.rtlTranslate;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    if (rtlTranslate) {
      swiper.translate = wrapperEl.scrollWidth - wrapperEl.offsetWidth - wrapperEl.scrollLeft;
    } else {
      swiper.translate = -wrapperEl.scrollLeft;
    }
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  if (swiper.translate === -0)
    swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  var newProgress;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }
  swiper.emit("setTranslate", swiper.translate, false);
}

// node_modules/swiper/esm/components/core/events/index.js
var dummyEventAttached = false;
function dummyEventListener() {
}
function attachEvents() {
  var swiper = this;
  var document2 = getDocument();
  var params = swiper.params, touchEvents = swiper.touchEvents, el = swiper.el, wrapperEl = swiper.wrapperEl, device2 = swiper.device, support3 = swiper.support;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }
  swiper.onClick = onClick.bind(swiper);
  var capture = !!params.nested;
  if (!support3.touch && support3.pointerEvents) {
    el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
    document2.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
    document2.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
  } else {
    if (support3.touch) {
      var passiveListener = touchEvents.start === "touchstart" && support3.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
      el.addEventListener(touchEvents.move, swiper.onTouchMove, support3.passiveListener ? {
        passive: false,
        capture
      } : capture);
      el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
      if (touchEvents.cancel) {
        el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }
      if (!dummyEventAttached) {
        document2.addEventListener("touchstart", dummyEventListener);
        dummyEventAttached = true;
      }
    }
    if (params.simulateTouch && !device2.ios && !device2.android || params.simulateTouch && !support3.touch && device2.ios) {
      el.addEventListener("mousedown", swiper.onTouchStart, false);
      document2.addEventListener("mousemove", swiper.onTouchMove, capture);
      document2.addEventListener("mouseup", swiper.onTouchEnd, false);
    }
  }
  if (params.preventClicks || params.preventClicksPropagation) {
    el.addEventListener("click", swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl.addEventListener("scroll", swiper.onScroll);
  }
  if (params.updateOnWindowResize) {
    swiper.on(device2.ios || device2.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
  } else {
    swiper.on("observerUpdate", onResize, true);
  }
}
function detachEvents() {
  var swiper = this;
  var document2 = getDocument();
  var params = swiper.params, touchEvents = swiper.touchEvents, el = swiper.el, wrapperEl = swiper.wrapperEl, device2 = swiper.device, support3 = swiper.support;
  var capture = !!params.nested;
  if (!support3.touch && support3.pointerEvents) {
    el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
    document2.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
    document2.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
  } else {
    if (support3.touch) {
      var passiveListener = touchEvents.start === "onTouchStart" && support3.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
      el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
      el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
      if (touchEvents.cancel) {
        el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }
    }
    if (params.simulateTouch && !device2.ios && !device2.android || params.simulateTouch && !support3.touch && device2.ios) {
      el.removeEventListener("mousedown", swiper.onTouchStart, false);
      document2.removeEventListener("mousemove", swiper.onTouchMove, capture);
      document2.removeEventListener("mouseup", swiper.onTouchEnd, false);
    }
  }
  if (params.preventClicks || params.preventClicksPropagation) {
    el.removeEventListener("click", swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl.removeEventListener("scroll", swiper.onScroll);
  }
  swiper.off(device2.ios || device2.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize);
}
var events_default = {
  attachEvents,
  detachEvents
};

// node_modules/swiper/esm/components/core/breakpoints/setBreakpoint.js
function setBreakpoint() {
  var swiper = this;
  var activeIndex = swiper.activeIndex, initialized = swiper.initialized, _swiper$loopedSlides = swiper.loopedSlides, loopedSlides = _swiper$loopedSlides === void 0 ? 0 : _swiper$loopedSlides, params = swiper.params, $el = swiper.$el;
  var breakpoints = params.breakpoints;
  if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0)
    return;
  var breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
  if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
    var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;
    if (breakpointOnlyParams) {
      ["slidesPerView", "spaceBetween", "slidesPerGroup", "slidesPerGroupSkip", "slidesPerColumn"].forEach(function(param) {
        var paramValue = breakpointOnlyParams[param];
        if (typeof paramValue === "undefined")
          return;
        if (param === "slidesPerView" && (paramValue === "AUTO" || paramValue === "auto")) {
          breakpointOnlyParams[param] = "auto";
        } else if (param === "slidesPerView") {
          breakpointOnlyParams[param] = parseFloat(paramValue);
        } else {
          breakpointOnlyParams[param] = parseInt(paramValue, 10);
        }
      });
    }
    var breakpointParams = breakpointOnlyParams || swiper.originalParams;
    var wasMultiRow = params.slidesPerColumn > 1;
    var isMultiRow = breakpointParams.slidesPerColumn > 1;
    if (wasMultiRow && !isMultiRow) {
      $el.removeClass(params.containerModifierClass + "multirow " + params.containerModifierClass + "multirow-column");
      swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
      $el.addClass(params.containerModifierClass + "multirow");
      if (breakpointParams.slidesPerColumnFill === "column") {
        $el.addClass(params.containerModifierClass + "multirow-column");
      }
      swiper.emitContainerClasses();
    }
    var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
    if (directionChanged && initialized) {
      swiper.changeDirection();
    }
    extend2(swiper.params, breakpointParams);
    extend2(swiper, {
      allowTouchMove: swiper.params.allowTouchMove,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev
    });
    swiper.currentBreakpoint = breakpoint;
    swiper.emit("_beforeBreakpoint", breakpointParams);
    if (needsReLoop && initialized) {
      swiper.loopDestroy();
      swiper.loopCreate();
      swiper.updateSlides();
      swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
    }
    swiper.emit("breakpoint", breakpointParams);
  }
}

// node_modules/swiper/esm/components/core/breakpoints/getBreakpoint.js
function getBreakpoint(breakpoints, base, containerEl) {
  if (base === void 0) {
    base = "window";
  }
  if (!breakpoints || base === "container" && !containerEl)
    return void 0;
  var breakpoint = false;
  var window2 = getWindow();
  var currentWidth = base === "window" ? window2.innerWidth : containerEl.clientWidth;
  var currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
  var points = Object.keys(breakpoints).map(function(point2) {
    if (typeof point2 === "string" && point2.indexOf("@") === 0) {
      var minRatio = parseFloat(point2.substr(1));
      var value3 = currentHeight * minRatio;
      return {
        value: value3,
        point: point2
      };
    }
    return {
      value: point2,
      point: point2
    };
  });
  points.sort(function(a, b) {
    return parseInt(a.value, 10) - parseInt(b.value, 10);
  });
  for (var i = 0; i < points.length; i += 1) {
    var _points$i = points[i], point = _points$i.point, value2 = _points$i.value;
    if (value2 <= currentWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || "max";
}

// node_modules/swiper/esm/components/core/breakpoints/index.js
var breakpoints_default = {
  setBreakpoint,
  getBreakpoint
};

// node_modules/swiper/esm/components/core/classes/addClasses.js
function prepareClasses(entries, prefix) {
  var resultClasses = [];
  entries.forEach(function(item) {
    if (typeof item === "object") {
      Object.keys(item).forEach(function(classNames) {
        if (item[classNames]) {
          resultClasses.push(prefix + classNames);
        }
      });
    } else if (typeof item === "string") {
      resultClasses.push(prefix + item);
    }
  });
  return resultClasses;
}
function addClasses() {
  var swiper = this;
  var classNames = swiper.classNames, params = swiper.params, rtl = swiper.rtl, $el = swiper.$el, device2 = swiper.device, support3 = swiper.support;
  var suffixes = prepareClasses(["initialized", params.direction, {
    "pointer-events": support3.pointerEvents && !support3.touch
  }, {
    "free-mode": params.freeMode
  }, {
    autoheight: params.autoHeight
  }, {
    rtl
  }, {
    multirow: params.slidesPerColumn > 1
  }, {
    "multirow-column": params.slidesPerColumn > 1 && params.slidesPerColumnFill === "column"
  }, {
    android: device2.android
  }, {
    ios: device2.ios
  }, {
    "css-mode": params.cssMode
  }], params.containerModifierClass);
  classNames.push.apply(classNames, suffixes);
  $el.addClass([].concat(classNames).join(" "));
  swiper.emitContainerClasses();
}

// node_modules/swiper/esm/components/core/classes/removeClasses.js
function removeClasses() {
  var swiper = this;
  var $el = swiper.$el, classNames = swiper.classNames;
  $el.removeClass(classNames.join(" "));
  swiper.emitContainerClasses();
}

// node_modules/swiper/esm/components/core/classes/index.js
var classes_default = {
  addClasses,
  removeClasses
};

// node_modules/swiper/esm/components/core/images/loadImage.js
function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
  var window2 = getWindow();
  var image;
  function onReady() {
    if (callback)
      callback();
  }
  var isPicture = dom_default(imageEl).parent("picture")[0];
  if (!isPicture && (!imageEl.complete || !checkForComplete)) {
    if (src) {
      image = new window2.Image();
      image.onload = onReady;
      image.onerror = onReady;
      if (sizes) {
        image.sizes = sizes;
      }
      if (srcset) {
        image.srcset = srcset;
      }
      if (src) {
        image.src = src;
      }
    } else {
      onReady();
    }
  } else {
    onReady();
  }
}

// node_modules/swiper/esm/components/core/images/preloadImages.js
function preloadImages() {
  var swiper = this;
  swiper.imagesToLoad = swiper.$el.find("img");
  function onReady() {
    if (typeof swiper === "undefined" || swiper === null || !swiper || swiper.destroyed)
      return;
    if (swiper.imagesLoaded !== void 0)
      swiper.imagesLoaded += 1;
    if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
      if (swiper.params.updateOnImagesReady)
        swiper.update();
      swiper.emit("imagesReady");
    }
  }
  for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
    var imageEl = swiper.imagesToLoad[i];
    swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute("src"), imageEl.srcset || imageEl.getAttribute("srcset"), imageEl.sizes || imageEl.getAttribute("sizes"), true, onReady);
  }
}

// node_modules/swiper/esm/components/core/images/index.js
var images_default = {
  loadImage,
  preloadImages
};

// node_modules/swiper/esm/components/core/check-overflow/index.js
function checkOverflow() {
  var swiper = this;
  var params = swiper.params;
  var wasLocked = swiper.isLocked;
  var lastSlidePosition = swiper.slides.length > 0 && params.slidesOffsetBefore + params.spaceBetween * (swiper.slides.length - 1) + swiper.slides[0].offsetWidth * swiper.slides.length;
  if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
    swiper.isLocked = lastSlidePosition <= swiper.size;
  } else {
    swiper.isLocked = swiper.snapGrid.length === 1;
  }
  swiper.allowSlideNext = !swiper.isLocked;
  swiper.allowSlidePrev = !swiper.isLocked;
  if (wasLocked !== swiper.isLocked)
    swiper.emit(swiper.isLocked ? "lock" : "unlock");
  if (wasLocked && wasLocked !== swiper.isLocked) {
    swiper.isEnd = false;
    if (swiper.navigation)
      swiper.navigation.update();
  }
}
var check_overflow_default = {
  checkOverflow
};

// node_modules/swiper/esm/components/core/defaults.js
var defaults_default = {
  init: true,
  direction: "horizontal",
  touchEventsTarget: "container",
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: false,
  nested: false,
  width: null,
  height: null,
  preventInteractionOnTransition: false,
  userAgent: null,
  url: null,
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  freeMode: false,
  freeModeMomentum: true,
  freeModeMomentumRatio: 1,
  freeModeMomentumBounce: true,
  freeModeMomentumBounceRatio: 1,
  freeModeMomentumVelocityRatio: 1,
  freeModeSticky: false,
  freeModeMinimumVelocity: 0.02,
  autoHeight: false,
  setWrapperSize: false,
  virtualTranslate: false,
  effect: "slide",
  breakpoints: void 0,
  breakpointsBase: "window",
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerColumn: 1,
  slidesPerColumnFill: "column",
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  slidesOffsetAfter: 0,
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  watchOverflow: false,
  roundLengths: false,
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 0,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  uniqueNavElements: true,
  resistance: true,
  resistanceRatio: 0.85,
  watchSlidesProgress: false,
  watchSlidesVisibility: false,
  grabCursor: false,
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  preloadImages: true,
  updateOnImagesReady: true,
  loop: false,
  loopAdditionalSlides: 0,
  loopedSlides: null,
  loopFillGroupWithBlank: false,
  loopPreventsSlide: true,
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  noSwiping: true,
  noSwipingClass: "swiper-no-swiping",
  noSwipingSelector: null,
  passiveListeners: true,
  containerModifierClass: "swiper-container-",
  slideClass: "swiper-slide",
  slideBlankClass: "swiper-slide-invisible-blank",
  slideActiveClass: "swiper-slide-active",
  slideDuplicateActiveClass: "swiper-slide-duplicate-active",
  slideVisibleClass: "swiper-slide-visible",
  slideDuplicateClass: "swiper-slide-duplicate",
  slideNextClass: "swiper-slide-next",
  slideDuplicateNextClass: "swiper-slide-duplicate-next",
  slidePrevClass: "swiper-slide-prev",
  slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
  wrapperClass: "swiper-wrapper",
  runCallbacksOnInit: true,
  _emitClasses: false
};

// node_modules/swiper/esm/components/core/core-class.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
var prototypes = {
  modular: modular_default,
  eventsEmitter: events_emitter_default,
  update: update_default,
  translate: translate_default,
  transition: transition_default,
  slide: slide_default,
  loop: loop_default,
  grabCursor: grab_cursor_default,
  manipulation: manipulation_default,
  events: events_default,
  breakpoints: breakpoints_default,
  checkOverflow: check_overflow_default,
  classes: classes_default,
  images: images_default
};
var extendedDefaults = {};
var Swiper = function() {
  function Swiper2() {
    var el;
    var params;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
      params = args[0];
    } else {
      el = args[0];
      params = args[1];
    }
    if (!params)
      params = {};
    params = extend2({}, params);
    if (el && !params.el)
      params.el = el;
    if (params.el && dom_default(params.el).length > 1) {
      var swipers = [];
      dom_default(params.el).each(function(containerEl) {
        var newParams = extend2({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper2(newParams));
      });
      return swipers;
    }
    var swiper = this;
    swiper.__swiper__ = true;
    swiper.support = getSupport();
    swiper.device = getDevice({
      userAgent: params.userAgent
    });
    swiper.browser = getBrowser();
    swiper.eventsListeners = {};
    swiper.eventsAnyListeners = [];
    if (typeof swiper.modules === "undefined") {
      swiper.modules = {};
    }
    Object.keys(swiper.modules).forEach(function(moduleName) {
      var module = swiper.modules[moduleName];
      if (module.params) {
        var moduleParamName = Object.keys(module.params)[0];
        var moduleParams = module.params[moduleParamName];
        if (typeof moduleParams !== "object" || moduleParams === null)
          return;
        if (!(moduleParamName in params && "enabled" in moduleParams))
          return;
        if (params[moduleParamName] === true) {
          params[moduleParamName] = {
            enabled: true
          };
        }
        if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
          params[moduleParamName].enabled = true;
        }
        if (!params[moduleParamName])
          params[moduleParamName] = {
            enabled: false
          };
      }
    });
    var swiperParams = extend2({}, defaults_default);
    swiper.useParams(swiperParams);
    swiper.params = extend2({}, swiperParams, extendedDefaults, params);
    swiper.originalParams = extend2({}, swiper.params);
    swiper.passedParams = extend2({}, params);
    if (swiper.params && swiper.params.on) {
      Object.keys(swiper.params.on).forEach(function(eventName) {
        swiper.on(eventName, swiper.params.on[eventName]);
      });
    }
    if (swiper.params && swiper.params.onAny) {
      swiper.onAny(swiper.params.onAny);
    }
    swiper.$ = dom_default;
    extend2(swiper, {
      el,
      classNames: [],
      slides: dom_default(),
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      isHorizontal: function isHorizontal() {
        return swiper.params.direction === "horizontal";
      },
      isVertical: function isVertical() {
        return swiper.params.direction === "vertical";
      },
      activeIndex: 0,
      realIndex: 0,
      isBeginning: true,
      isEnd: false,
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      allowSlideNext: swiper.params.allowSlideNext,
      allowSlidePrev: swiper.params.allowSlidePrev,
      touchEvents: function touchEvents() {
        var touch = ["touchstart", "touchmove", "touchend", "touchcancel"];
        var desktop = ["mousedown", "mousemove", "mouseup"];
        if (swiper.support.pointerEvents) {
          desktop = ["pointerdown", "pointermove", "pointerup"];
        }
        swiper.touchEventsTouch = {
          start: touch[0],
          move: touch[1],
          end: touch[2],
          cancel: touch[3]
        };
        swiper.touchEventsDesktop = {
          start: desktop[0],
          move: desktop[1],
          end: desktop[2]
        };
        return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
      }(),
      touchEventsData: {
        isTouched: void 0,
        isMoved: void 0,
        allowTouchCallbacks: void 0,
        touchStartTime: void 0,
        isScrolling: void 0,
        currentTranslate: void 0,
        startTranslate: void 0,
        allowThresholdMove: void 0,
        formElements: "input, select, option, textarea, button, video, label",
        lastClickTime: now(),
        clickTimeout: void 0,
        velocities: [],
        allowMomentumBounce: void 0,
        isTouchEvent: void 0,
        startMoving: void 0
      },
      allowClick: true,
      allowTouchMove: swiper.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper.useModules();
    swiper.emit("_swiper");
    if (swiper.params.init) {
      swiper.init();
    }
    return swiper;
  }
  var _proto = Swiper2.prototype;
  _proto.setProgress = function setProgress(progress, speed) {
    var swiper = this;
    progress = Math.min(Math.max(progress, 0), 1);
    var min = swiper.minTranslate();
    var max = swiper.maxTranslate();
    var current = (max - min) * progress + min;
    swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  };
  _proto.emitContainerClasses = function emitContainerClasses() {
    var swiper = this;
    if (!swiper.params._emitClasses || !swiper.el)
      return;
    var classes = swiper.el.className.split(" ").filter(function(className) {
      return className.indexOf("swiper-container") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
    });
    swiper.emit("_containerClasses", classes.join(" "));
  };
  _proto.getSlideClasses = function getSlideClasses(slideEl) {
    var swiper = this;
    return slideEl.className.split(" ").filter(function(className) {
      return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0;
    }).join(" ");
  };
  _proto.emitSlidesClasses = function emitSlidesClasses() {
    var swiper = this;
    if (!swiper.params._emitClasses || !swiper.el)
      return;
    var updates = [];
    swiper.slides.each(function(slideEl) {
      var classNames = swiper.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      });
      swiper.emit("_slideClass", slideEl, classNames);
    });
    swiper.emit("_slideClasses", updates);
  };
  _proto.slidesPerViewDynamic = function slidesPerViewDynamic() {
    var swiper = this;
    var params = swiper.params, slides = swiper.slides, slidesGrid = swiper.slidesGrid, swiperSize = swiper.size, activeIndex = swiper.activeIndex;
    var spv = 1;
    if (params.centeredSlides) {
      var slideSize = slides[activeIndex].swiperSlideSize;
      var breakLoop;
      for (var i = activeIndex + 1; i < slides.length; i += 1) {
        if (slides[i] && !breakLoop) {
          slideSize += slides[i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize)
            breakLoop = true;
        }
      }
      for (var _i = activeIndex - 1; _i >= 0; _i -= 1) {
        if (slides[_i] && !breakLoop) {
          slideSize += slides[_i].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize)
            breakLoop = true;
        }
      }
    } else {
      for (var _i2 = activeIndex + 1; _i2 < slides.length; _i2 += 1) {
        if (slidesGrid[_i2] - slidesGrid[activeIndex] < swiperSize) {
          spv += 1;
        }
      }
    }
    return spv;
  };
  _proto.update = function update() {
    var swiper = this;
    if (!swiper || swiper.destroyed)
      return;
    var snapGrid = swiper.snapGrid, params = swiper.params;
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateProgress();
    swiper.updateSlidesClasses();
    function setTranslate2() {
      var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
      var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
      swiper.setTranslate(newTranslate);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    var translated;
    if (swiper.params.freeMode) {
      setTranslate2();
      if (swiper.params.autoHeight) {
        swiper.updateAutoHeight();
      }
    } else {
      if ((swiper.params.slidesPerView === "auto" || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate2();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
    swiper.emit("update");
  };
  _proto.changeDirection = function changeDirection(newDirection, needUpdate) {
    if (needUpdate === void 0) {
      needUpdate = true;
    }
    var swiper = this;
    var currentDirection = swiper.params.direction;
    if (!newDirection) {
      newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
    }
    if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
      return swiper;
    }
    swiper.$el.removeClass("" + swiper.params.containerModifierClass + currentDirection).addClass("" + swiper.params.containerModifierClass + newDirection);
    swiper.emitContainerClasses();
    swiper.params.direction = newDirection;
    swiper.slides.each(function(slideEl) {
      if (newDirection === "vertical") {
        slideEl.style.width = "";
      } else {
        slideEl.style.height = "";
      }
    });
    swiper.emit("changeDirection");
    if (needUpdate)
      swiper.update();
    return swiper;
  };
  _proto.mount = function mount(el) {
    var swiper = this;
    if (swiper.mounted)
      return true;
    var $el = dom_default(el || swiper.params.el);
    el = $el[0];
    if (!el) {
      return false;
    }
    el.swiper = swiper;
    var $wrapperEl;
    if (el && el.shadowRoot && el.shadowRoot.querySelector) {
      $wrapperEl = dom_default(el.shadowRoot.querySelector("." + swiper.params.wrapperClass));
      $wrapperEl.children = function(options) {
        return $el.children(options);
      };
    } else {
      $wrapperEl = $el.children("." + swiper.params.wrapperClass);
    }
    extend2(swiper, {
      $el,
      el,
      $wrapperEl,
      wrapperEl: $wrapperEl[0],
      mounted: true,
      rtl: el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl",
      rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || $el.css("direction") === "rtl"),
      wrongRTL: $wrapperEl.css("display") === "-webkit-box"
    });
    return true;
  };
  _proto.init = function init15(el) {
    var swiper = this;
    if (swiper.initialized)
      return swiper;
    var mounted = swiper.mount(el);
    if (mounted === false)
      return swiper;
    swiper.emit("beforeInit");
    if (swiper.params.breakpoints) {
      swiper.setBreakpoint();
    }
    swiper.addClasses();
    if (swiper.params.loop) {
      swiper.loopCreate();
    }
    swiper.updateSize();
    swiper.updateSlides();
    if (swiper.params.watchOverflow) {
      swiper.checkOverflow();
    }
    if (swiper.params.grabCursor) {
      swiper.setGrabCursor();
    }
    if (swiper.params.preloadImages) {
      swiper.preloadImages();
    }
    if (swiper.params.loop) {
      swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
    } else {
      swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
    }
    swiper.attachEvents();
    swiper.initialized = true;
    swiper.emit("init");
    swiper.emit("afterInit");
    return swiper;
  };
  _proto.destroy = function destroy5(deleteInstance, cleanStyles) {
    if (deleteInstance === void 0) {
      deleteInstance = true;
    }
    if (cleanStyles === void 0) {
      cleanStyles = true;
    }
    var swiper = this;
    var params = swiper.params, $el = swiper.$el, $wrapperEl = swiper.$wrapperEl, slides = swiper.slides;
    if (typeof swiper.params === "undefined" || swiper.destroyed) {
      return null;
    }
    swiper.emit("beforeDestroy");
    swiper.initialized = false;
    swiper.detachEvents();
    if (params.loop) {
      swiper.loopDestroy();
    }
    if (cleanStyles) {
      swiper.removeClasses();
      $el.removeAttr("style");
      $wrapperEl.removeAttr("style");
      if (slides && slides.length) {
        slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index");
      }
    }
    swiper.emit("destroy");
    Object.keys(swiper.eventsListeners).forEach(function(eventName) {
      swiper.off(eventName);
    });
    if (deleteInstance !== false) {
      swiper.$el[0].swiper = null;
      deleteProps(swiper);
    }
    swiper.destroyed = true;
    return null;
  };
  Swiper2.extendDefaults = function extendDefaults(newDefaults) {
    extend2(extendedDefaults, newDefaults);
  };
  Swiper2.installModule = function installModule(module) {
    if (!Swiper2.prototype.modules)
      Swiper2.prototype.modules = {};
    var name = module.name || Object.keys(Swiper2.prototype.modules).length + "_" + now();
    Swiper2.prototype.modules[name] = module;
  };
  Swiper2.use = function use(module) {
    if (Array.isArray(module)) {
      module.forEach(function(m) {
        return Swiper2.installModule(m);
      });
      return Swiper2;
    }
    Swiper2.installModule(module);
    return Swiper2;
  };
  _createClass(Swiper2, null, [{
    key: "extendedDefaults",
    get: function get2() {
      return extendedDefaults;
    }
  }, {
    key: "defaults",
    get: function get2() {
      return defaults_default;
    }
  }]);
  return Swiper2;
}();
Object.keys(prototypes).forEach(function(prototypeGroup) {
  Object.keys(prototypes[prototypeGroup]).forEach(function(protoMethod) {
    Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper.use([resize_default, observer_default]);
var core_class_default = Swiper;

// node_modules/framework7/esm/shared/utils.js
var utils_exports = {};
__export(utils_exports, {
  auroraPreloaderContent: () => auroraPreloaderContent,
  bindMethods: () => bindMethods,
  cancelAnimationFrame: () => cancelAnimationFrame,
  colorHexToRgb: () => colorHexToRgb,
  colorHsbToHsl: () => colorHsbToHsl,
  colorHslToHsb: () => colorHslToHsb,
  colorHslToRgb: () => colorHslToRgb,
  colorRgbToHex: () => colorRgbToHex,
  colorRgbToHsl: () => colorRgbToHsl,
  colorThemeCSSProperties: () => colorThemeCSSProperties,
  deleteProps: () => deleteProps2,
  eventNameToColonCase: () => eventNameToColonCase,
  extend: () => extend3,
  flattenArray: () => flattenArray,
  getTranslate: () => getTranslate2,
  id: () => id,
  iosPreloaderContent: () => iosPreloaderContent,
  isObject: () => isObject3,
  mdPreloaderContent: () => mdPreloaderContent,
  merge: () => merge,
  nextFrame: () => nextFrame,
  nextTick: () => nextTick2,
  now: () => now2,
  parseUrlQuery: () => parseUrlQuery,
  requestAnimationFrame: () => requestAnimationFrame,
  serializeObject: () => serializeObject,
  uniqueNumber: () => uniqueNumber
});
var uniqueNum = 0;
function uniqueNumber() {
  uniqueNum += 1;
  return uniqueNum;
}
function id(mask, map) {
  if (mask === void 0) {
    mask = "xxxxxxxxxx";
  }
  if (map === void 0) {
    map = "0123456789abcdef";
  }
  var length = map.length;
  return mask.replace(/x/g, function() {
    return map[Math.floor(Math.random() * length)];
  });
}
var mdPreloaderContent = '\n  <span class="preloader-inner">\n    <svg viewBox="0 0 36 36">\n      <circle cx="18" cy="18" r="16"></circle>\n    </svg>\n  </span>\n'.trim();
var iosPreloaderContent = ('\n  <span class="preloader-inner">\n    ' + [0, 1, 2, 3, 4, 5, 6, 7].map(function() {
  return '<span class="preloader-inner-line"></span>';
}).join("") + "\n  </span>\n").trim();
var auroraPreloaderContent = '\n  <span class="preloader-inner">\n    <span class="preloader-inner-circle"></span>\n  </span>\n';
function eventNameToColonCase(eventName) {
  var hasColon;
  return eventName.split("").map(function(char, index2) {
    if (char.match(/[A-Z]/) && index2 !== 0 && !hasColon) {
      hasColon = true;
      return ":" + char.toLowerCase();
    }
    return char.toLowerCase();
  }).join("");
}
function deleteProps2(obj) {
  var object = obj;
  Object.keys(object).forEach(function(key) {
    try {
      object[key] = null;
    } catch (e) {
    }
    try {
      delete object[key];
    } catch (e) {
    }
  });
}
function requestAnimationFrame(callback) {
  var window2 = getWindow();
  return window2.requestAnimationFrame(callback);
}
function cancelAnimationFrame(frameId) {
  var window2 = getWindow();
  return window2.cancelAnimationFrame(frameId);
}
function nextTick2(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return setTimeout(callback, delay);
}
function nextFrame(callback) {
  return requestAnimationFrame(function() {
    requestAnimationFrame(callback);
  });
}
function now2() {
  return Date.now();
}
function parseUrlQuery(url) {
  var window2 = getWindow();
  var query = {};
  var urlToParse = url || window2.location.href;
  var i;
  var params;
  var param;
  var length;
  if (typeof urlToParse === "string" && urlToParse.length) {
    urlToParse = urlToParse.indexOf("?") > -1 ? urlToParse.replace(/\S*\?/, "") : "";
    params = urlToParse.split("&").filter(function(paramsPart) {
      return paramsPart !== "";
    });
    length = params.length;
    for (i = 0; i < length; i += 1) {
      param = params[i].replace(/#\S+/g, "").split("=");
      query[decodeURIComponent(param[0])] = typeof param[1] === "undefined" ? void 0 : decodeURIComponent(param.slice(1).join("=")) || "";
    }
  }
  return query;
}
function getTranslate2(el, axis) {
  if (axis === void 0) {
    axis = "x";
  }
  var window2 = getWindow();
  var matrix;
  var curTransform;
  var transformMatrix;
  var curStyle = window2.getComputedStyle(el, null);
  if (window2.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(",").length > 6) {
      curTransform = curTransform.split(", ").map(function(a) {
        return a.replace(",", ".");
      }).join(", ");
    }
    transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
    matrix = transformMatrix.toString().split(",");
  }
  if (axis === "x") {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m41;
    else if (matrix.length === 16)
      curTransform = parseFloat(matrix[12]);
    else
      curTransform = parseFloat(matrix[4]);
  }
  if (axis === "y") {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m42;
    else if (matrix.length === 16)
      curTransform = parseFloat(matrix[13]);
    else
      curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function serializeObject(obj, parents2) {
  if (parents2 === void 0) {
    parents2 = [];
  }
  if (typeof obj === "string")
    return obj;
  var resultArray = [];
  var separator = "&";
  var newParents;
  function varName(name) {
    if (parents2.length > 0) {
      var parentParts = "";
      for (var j = 0; j < parents2.length; j += 1) {
        if (j === 0)
          parentParts += parents2[j];
        else
          parentParts += "[" + encodeURIComponent(parents2[j]) + "]";
      }
      return parentParts + "[" + encodeURIComponent(name) + "]";
    }
    return encodeURIComponent(name);
  }
  function varValue(value2) {
    return encodeURIComponent(value2);
  }
  Object.keys(obj).forEach(function(prop2) {
    var toPush;
    if (Array.isArray(obj[prop2])) {
      toPush = [];
      for (var i = 0; i < obj[prop2].length; i += 1) {
        if (!Array.isArray(obj[prop2][i]) && typeof obj[prop2][i] === "object") {
          newParents = parents2.slice();
          newParents.push(prop2);
          newParents.push(String(i));
          toPush.push(serializeObject(obj[prop2][i], newParents));
        } else {
          toPush.push(varName(prop2) + "[]=" + varValue(obj[prop2][i]));
        }
      }
      if (toPush.length > 0)
        resultArray.push(toPush.join(separator));
    } else if (obj[prop2] === null || obj[prop2] === "") {
      resultArray.push(varName(prop2) + "=");
    } else if (typeof obj[prop2] === "object") {
      newParents = parents2.slice();
      newParents.push(prop2);
      toPush = serializeObject(obj[prop2], newParents);
      if (toPush !== "")
        resultArray.push(toPush);
    } else if (typeof obj[prop2] !== "undefined" && obj[prop2] !== "") {
      resultArray.push(varName(prop2) + "=" + varValue(obj[prop2]));
    } else if (obj[prop2] === "")
      resultArray.push(varName(prop2));
  });
  return resultArray.join(separator);
}
function isObject3(o) {
  return typeof o === "object" && o !== null && o.constructor && o.constructor === Object;
}
function merge() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var to = args[0];
  args.splice(0, 1);
  var from = args;
  for (var i = 0; i < from.length; i += 1) {
    var nextSource = args[i];
    if (nextSource !== void 0 && nextSource !== null) {
      var keysArray = Object.keys(Object(nextSource));
      for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        var nextKey = keysArray[nextIndex];
        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          to[nextKey] = nextSource[nextKey];
        }
      }
    }
  }
  return to;
}
function extend3() {
  var deep = true;
  var to;
  var from;
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (typeof args[0] === "boolean") {
    deep = args[0];
    to = args[1];
    args.splice(0, 2);
    from = args;
  } else {
    to = args[0];
    args.splice(0, 1);
    from = args;
  }
  for (var i = 0; i < from.length; i += 1) {
    var nextSource = args[i];
    if (nextSource !== void 0 && nextSource !== null) {
      var keysArray = Object.keys(Object(nextSource));
      for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        var nextKey = keysArray[nextIndex];
        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          if (!deep) {
            to[nextKey] = nextSource[nextKey];
          } else if (isObject3(to[nextKey]) && isObject3(nextSource[nextKey])) {
            extend3(to[nextKey], nextSource[nextKey]);
          } else if (!isObject3(to[nextKey]) && isObject3(nextSource[nextKey])) {
            to[nextKey] = {};
            extend3(to[nextKey], nextSource[nextKey]);
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function colorHexToRgb(hex) {
  var h = hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function(m, r, g, b) {
    return r + r + g + g + b + b;
  });
  var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h);
  return result ? result.slice(1).map(function(n) {
    return parseInt(n, 16);
  }) : null;
}
function colorRgbToHex(r, g, b) {
  var result = [r, g, b].map(function(n) {
    var hex = n.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  }).join("");
  return "#" + result;
}
function colorRgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var d = max - min;
  var h;
  if (d === 0)
    h = 0;
  else if (max === r)
    h = (g - b) / d % 6;
  else if (max === g)
    h = (b - r) / d + 2;
  else if (max === b)
    h = (r - g) / d + 4;
  var l = (min + max) / 2;
  var s = d === 0 ? 0 : d / (1 - Math.abs(2 * l - 1));
  if (h < 0)
    h = 360 / 60 + h;
  return [h * 60, s, l];
}
function colorHslToRgb(h, s, l) {
  var c = (1 - Math.abs(2 * l - 1)) * s;
  var hp = h / 60;
  var x = c * (1 - Math.abs(hp % 2 - 1));
  var rgb1;
  if (Number.isNaN(h) || typeof h === "undefined") {
    rgb1 = [0, 0, 0];
  } else if (hp <= 1)
    rgb1 = [c, x, 0];
  else if (hp <= 2)
    rgb1 = [x, c, 0];
  else if (hp <= 3)
    rgb1 = [0, c, x];
  else if (hp <= 4)
    rgb1 = [0, x, c];
  else if (hp <= 5)
    rgb1 = [x, 0, c];
  else if (hp <= 6)
    rgb1 = [c, 0, x];
  var m = l - c / 2;
  return rgb1.map(function(n) {
    return Math.max(0, Math.min(255, Math.round(255 * (n + m))));
  });
}
function colorHsbToHsl(h, s, b) {
  var HSL = {
    h,
    s: 0,
    l: 0
  };
  var HSB = {
    h,
    s,
    b
  };
  HSL.l = (2 - HSB.s) * HSB.b / 2;
  HSL.s = HSL.l && HSL.l < 1 ? HSB.s * HSB.b / (HSL.l < 0.5 ? HSL.l * 2 : 2 - HSL.l * 2) : HSL.s;
  return [HSL.h, HSL.s, HSL.l];
}
function colorHslToHsb(h, s, l) {
  var HSB = {
    h,
    s: 0,
    b: 0
  };
  var HSL = {
    h,
    s,
    l
  };
  var t = HSL.s * (HSL.l < 0.5 ? HSL.l : 1 - HSL.l);
  HSB.b = HSL.l + t;
  HSB.s = HSL.l > 0 ? 2 * t / HSB.b : HSB.s;
  return [HSB.h, HSB.s, HSB.b];
}
function colorThemeCSSProperties() {
  var hex;
  var rgb;
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }
  if (args.length === 1) {
    hex = args[0];
    rgb = colorHexToRgb(hex);
  } else if (args.length === 3) {
    rgb = args;
    hex = colorRgbToHex.apply(void 0, rgb);
  }
  if (!rgb)
    return {};
  var hsl = colorRgbToHsl.apply(void 0, rgb);
  var hslShade = [hsl[0], hsl[1], Math.max(0, hsl[2] - 0.08)];
  var hslTint = [hsl[0], hsl[1], Math.max(0, hsl[2] + 0.08)];
  var shade = colorRgbToHex.apply(void 0, colorHslToRgb.apply(void 0, hslShade));
  var tint = colorRgbToHex.apply(void 0, colorHslToRgb.apply(void 0, hslTint));
  return {
    "--f7-theme-color": hex,
    "--f7-theme-color-rgb": rgb.join(", "),
    "--f7-theme-color-shade": shade,
    "--f7-theme-color-tint": tint
  };
}
function bindMethods(instance, obj) {
  Object.keys(obj).forEach(function(key) {
    if (isObject3(obj[key])) {
      Object.keys(obj[key]).forEach(function(subKey) {
        if (typeof obj[key][subKey] === "function") {
          obj[key][subKey] = obj[key][subKey].bind(instance);
        }
      });
    }
    instance[key] = obj[key];
  });
}
function flattenArray() {
  var arr = [];
  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }
  args.forEach(function(arg) {
    if (Array.isArray(arg))
      arr.push.apply(arr, flattenArray.apply(void 0, arg));
    else
      arr.push(arg);
  });
  return arr;
}

// node_modules/framework7/esm/shared/get-support.js
var support2;
function calcSupport2() {
  var window2 = getWindow();
  var document2 = getDocument();
  return {
    touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch),
    pointerEvents: !!window2.PointerEvent && "maxTouchPoints" in window2.navigator && window2.navigator.maxTouchPoints >= 0,
    passiveListener: function checkPassiveListener() {
      var supportsPassive = false;
      try {
        var opts = Object.defineProperty({}, "passive", {
          get: function get2() {
            supportsPassive = true;
          }
        });
        window2.addEventListener("testPassiveListener", null, opts);
      } catch (e) {
      }
      return supportsPassive;
    }(),
    intersectionObserver: function checkObserver() {
      return "IntersectionObserver" in window2;
    }()
  };
}
function getSupport2() {
  if (!support2) {
    support2 = calcSupport2();
  }
  return support2;
}

// node_modules/framework7/esm/shared/get-device.js
var deviceCalculated;
function calcDevice2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, userAgent = _ref.userAgent;
  var support3 = getSupport2();
  var window2 = getWindow();
  var platform = window2.navigator.platform;
  var ua = userAgent || window2.navigator.userAgent;
  var device2 = {
    ios: false,
    android: false,
    androidChrome: false,
    desktop: false,
    iphone: false,
    ipod: false,
    ipad: false,
    edge: false,
    ie: false,
    firefox: false,
    macos: false,
    windows: false,
    cordova: !!(window2.cordova || window2.phonegap),
    phonegap: !!(window2.cordova || window2.phonegap),
    electron: false,
    capacitor: !!window2.Capacitor,
    nwjs: false
  };
  var screenWidth = window2.screen.width;
  var screenHeight = window2.screen.height;
  var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
  var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  var iphone = !ipad && ua.match(/(iPhone\sOS|iOS|iPhone;\sCPU\sOS)\s([\d_]+)/);
  var ie = ua.indexOf("MSIE ") >= 0 || ua.indexOf("Trident/") >= 0;
  var edge = ua.indexOf("Edge/") >= 0;
  var firefox = ua.indexOf("Gecko/") >= 0 && ua.indexOf("Firefox/") >= 0;
  var windows = platform === "Win32";
  var electron = ua.toLowerCase().indexOf("electron") >= 0;
  var nwjs = typeof nw !== "undefined" && typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.nw !== "undefined";
  var macos = platform === "MacIntel";
  var iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
  if (!ipad && macos && support3.touch && iPadScreens.indexOf(screenWidth + "x" + screenHeight) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad)
      ipad = [0, 1, "13_0_0"];
    macos = false;
  }
  device2.ie = ie;
  device2.edge = edge;
  device2.firefox = firefox;
  if (android && !windows) {
    device2.os = "android";
    device2.osVersion = android[2];
    device2.android = true;
    device2.androidChrome = ua.toLowerCase().indexOf("chrome") >= 0;
  }
  if (ipad || iphone || ipod) {
    device2.os = "ios";
    device2.ios = true;
  }
  if (iphone && !ipod) {
    device2.osVersion = iphone[2].replace(/_/g, ".");
    device2.iphone = true;
  }
  if (ipad) {
    device2.osVersion = ipad[2].replace(/_/g, ".");
    device2.ipad = true;
  }
  if (ipod) {
    device2.osVersion = ipod[3] ? ipod[3].replace(/_/g, ".") : null;
    device2.ipod = true;
  }
  if (device2.ios && device2.osVersion && ua.indexOf("Version/") >= 0) {
    if (device2.osVersion.split(".")[0] === "10") {
      device2.osVersion = ua.toLowerCase().split("version/")[1].split(" ")[0];
    }
  }
  device2.webView = !!((iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || window2.navigator.standalone)) || window2.matchMedia && window2.matchMedia("(display-mode: standalone)").matches;
  device2.webview = device2.webView;
  device2.standalone = device2.webView;
  device2.desktop = !(device2.ios || device2.android) || electron || nwjs;
  if (device2.desktop) {
    device2.electron = electron;
    device2.nwjs = nwjs;
    device2.macos = macos;
    device2.windows = windows;
    if (device2.macos) {
      device2.os = "macos";
    }
    if (device2.windows) {
      device2.os = "windows";
    }
  }
  device2.pixelRatio = window2.devicePixelRatio || 1;
  var DARK = "(prefers-color-scheme: dark)";
  var LIGHT = "(prefers-color-scheme: light)";
  device2.prefersColorScheme = function prefersColorTheme() {
    var theme;
    if (window2.matchMedia && window2.matchMedia(LIGHT).matches) {
      theme = "light";
    }
    if (window2.matchMedia && window2.matchMedia(DARK).matches) {
      theme = "dark";
    }
    return theme;
  };
  return device2;
}
function getDevice2(overrides, reset) {
  if (overrides === void 0) {
    overrides = {};
  }
  if (!deviceCalculated || reset) {
    deviceCalculated = calcDevice2(overrides);
  }
  return deviceCalculated;
}

// node_modules/framework7/esm/shared/events-class.js
var EventsClass = function() {
  function EventsClass2(parents2) {
    if (parents2 === void 0) {
      parents2 = [];
    }
    var self = this;
    self.eventsParents = parents2;
    self.eventsListeners = {};
  }
  var _proto = EventsClass2.prototype;
  _proto.on = function on3(events, handler, priority) {
    var self = this;
    if (typeof handler !== "function")
      return self;
    var method = priority ? "unshift" : "push";
    events.split(" ").forEach(function(event2) {
      if (!self.eventsListeners[event2])
        self.eventsListeners[event2] = [];
      self.eventsListeners[event2][method](handler);
    });
    return self;
  };
  _proto.once = function once3(events, handler, priority) {
    var self = this;
    if (typeof handler !== "function")
      return self;
    function onceHandler() {
      self.off(events, onceHandler);
      if (onceHandler.f7proxy) {
        delete onceHandler.f7proxy;
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      handler.apply(self, args);
    }
    onceHandler.f7proxy = handler;
    return self.on(events, onceHandler, priority);
  };
  _proto.off = function off3(events, handler) {
    var self = this;
    if (!self.eventsListeners)
      return self;
    events.split(" ").forEach(function(event2) {
      if (typeof handler === "undefined") {
        self.eventsListeners[event2] = [];
      } else if (self.eventsListeners[event2]) {
        self.eventsListeners[event2].forEach(function(eventHandler, index2) {
          if (eventHandler === handler || eventHandler.f7proxy && eventHandler.f7proxy === handler) {
            self.eventsListeners[event2].splice(index2, 1);
          }
        });
      }
    });
    return self;
  };
  _proto.emit = function emit2() {
    var self = this;
    if (!self.eventsListeners)
      return self;
    var events;
    var data2;
    var context;
    var eventsParents;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (typeof args[0] === "string" || Array.isArray(args[0])) {
      events = args[0];
      data2 = args.slice(1, args.length);
      context = self;
      eventsParents = self.eventsParents;
    } else {
      events = args[0].events;
      data2 = args[0].data;
      context = args[0].context || self;
      eventsParents = args[0].local ? [] : args[0].parents || self.eventsParents;
    }
    var eventsArray = Array.isArray(events) ? events : events.split(" ");
    var localEvents = eventsArray.map(function(eventName) {
      return eventName.replace("local::", "");
    });
    var parentEvents = eventsArray.filter(function(eventName) {
      return eventName.indexOf("local::") < 0;
    });
    localEvents.forEach(function(event2) {
      if (self.eventsListeners && self.eventsListeners[event2]) {
        var handlers = [];
        self.eventsListeners[event2].forEach(function(eventHandler) {
          handlers.push(eventHandler);
        });
        handlers.forEach(function(eventHandler) {
          eventHandler.apply(context, data2);
        });
      }
    });
    if (eventsParents && eventsParents.length > 0) {
      eventsParents.forEach(function(eventsParent) {
        eventsParent.emit.apply(eventsParent, [parentEvents].concat(data2));
      });
    }
    return self;
  };
  return EventsClass2;
}();
var events_class_default = EventsClass;

// node_modules/framework7/esm/shared/class.js
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  return Constructor;
}
function _assertThisInitialized2(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var Framework7Class = function(_EventsClass) {
  _inheritsLoose2(Framework7Class2, _EventsClass);
  function Framework7Class2(params, parents2) {
    var _this;
    if (params === void 0) {
      params = {};
    }
    if (parents2 === void 0) {
      parents2 = [];
    }
    _this = _EventsClass.call(this, parents2) || this;
    var self = _assertThisInitialized2(_this);
    self.params = params;
    if (self.params && self.params.on) {
      Object.keys(self.params.on).forEach(function(eventName) {
        self.on(eventName, self.params.on[eventName]);
      });
    }
    return _this;
  }
  var _proto = Framework7Class2.prototype;
  _proto.useModuleParams = function useModuleParams(module, instanceParams) {
    if (module.params) {
      var originalParams = {};
      Object.keys(module.params).forEach(function(paramKey) {
        if (typeof instanceParams[paramKey] === "undefined")
          return;
        originalParams[paramKey] = extend3({}, instanceParams[paramKey]);
      });
      extend3(instanceParams, module.params);
      Object.keys(originalParams).forEach(function(paramKey) {
        extend3(instanceParams[paramKey], originalParams[paramKey]);
      });
    }
  };
  _proto.useModulesParams = function useModulesParams(instanceParams) {
    var instance = this;
    if (!instance.modules)
      return;
    Object.keys(instance.modules).forEach(function(moduleName) {
      var module = instance.modules[moduleName];
      if (module.params) {
        extend3(instanceParams, module.params);
      }
    });
  };
  _proto.useModule = function useModule(moduleName, moduleParams) {
    if (moduleName === void 0) {
      moduleName = "";
    }
    if (moduleParams === void 0) {
      moduleParams = {};
    }
    var instance = this;
    if (!instance.modules)
      return;
    var module = typeof moduleName === "string" ? instance.modules[moduleName] : moduleName;
    if (!module)
      return;
    if (module.instance) {
      Object.keys(module.instance).forEach(function(modulePropName) {
        var moduleProp = module.instance[modulePropName];
        if (typeof moduleProp === "function") {
          instance[modulePropName] = moduleProp.bind(instance);
        } else {
          instance[modulePropName] = moduleProp;
        }
      });
    }
    if (module.on && instance.on) {
      Object.keys(module.on).forEach(function(moduleEventName) {
        instance.on(moduleEventName, module.on[moduleEventName]);
      });
    }
    if (module.vnode) {
      if (!instance.vnodeHooks)
        instance.vnodeHooks = {};
      Object.keys(module.vnode).forEach(function(vnodeId) {
        Object.keys(module.vnode[vnodeId]).forEach(function(hookName) {
          var handler = module.vnode[vnodeId][hookName];
          if (!instance.vnodeHooks[hookName])
            instance.vnodeHooks[hookName] = {};
          if (!instance.vnodeHooks[hookName][vnodeId])
            instance.vnodeHooks[hookName][vnodeId] = [];
          instance.vnodeHooks[hookName][vnodeId].push(handler.bind(instance));
        });
      });
    }
    if (module.create) {
      module.create.bind(instance)(moduleParams);
    }
  };
  _proto.useModules = function useModules2(modulesParams) {
    if (modulesParams === void 0) {
      modulesParams = {};
    }
    var instance = this;
    if (!instance.modules)
      return;
    Object.keys(instance.modules).forEach(function(moduleName) {
      var moduleParams = modulesParams[moduleName] || {};
      instance.useModule(moduleName, moduleParams);
    });
  };
  Framework7Class2.installModule = function installModule(module) {
    var Class = this;
    if (!Class.prototype.modules)
      Class.prototype.modules = {};
    var name = module.name || Object.keys(Class.prototype.modules).length + "_" + now2();
    Class.prototype.modules[name] = module;
    if (module.proto) {
      Object.keys(module.proto).forEach(function(key) {
        Class.prototype[key] = module.proto[key];
      });
    }
    if (module.static) {
      Object.keys(module.static).forEach(function(key) {
        Class[key] = module.static[key];
      });
    }
    if (module.install) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      module.install.apply(Class, params);
    }
    return Class;
  };
  Framework7Class2.use = function use(module) {
    var Class = this;
    if (Array.isArray(module)) {
      module.forEach(function(m) {
        return Class.installModule(m);
      });
      return Class;
    }
    for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      params[_key2 - 1] = arguments[_key2];
    }
    return Class.installModule.apply(Class, [module].concat(params));
  };
  _createClass2(Framework7Class2, null, [{
    key: "components",
    set: function set(components) {
      var Class = this;
      if (!Class.use)
        return;
      Class.use(components);
    }
  }]);
  return Framework7Class2;
}(events_class_default);
var class_default = Framework7Class;

// node_modules/framework7/esm/shared/dom7.js
Object.keys(dom7_esm_exports).forEach(function(methodName) {
  if (methodName === "$")
    return;
  $.fn[methodName] = dom7_esm_exports[methodName];
});
var dom7_default = $;

// node_modules/framework7/esm/shared/constructor-methods.js
function _construct2(Parent, args, Class) {
  if (_isNativeReflectConstruct2()) {
    _construct2 = Reflect.construct;
  } else {
    _construct2 = function _construct5(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf2(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct2.apply(null, arguments);
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _setPrototypeOf2(o, p) {
  _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf5(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf2(o, p);
}
function ConstructorMethods(parameters) {
  if (parameters === void 0) {
    parameters = {};
  }
  var _parameters = parameters, defaultSelector = _parameters.defaultSelector, Constructor = _parameters.constructor, domProp = _parameters.domProp, app = _parameters.app, addMethods = _parameters.addMethods;
  var methods = {
    create: function create13() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (app)
        return _construct2(Constructor, [app].concat(args));
      return _construct2(Constructor, args);
    },
    get: function get2(el) {
      if (el === void 0) {
        el = defaultSelector;
      }
      if (el instanceof Constructor)
        return el;
      var $el = dom7_default(el);
      if ($el.length === 0)
        return void 0;
      return $el[0][domProp];
    },
    destroy: function destroy5(el) {
      var instance = methods.get(el);
      if (instance && instance.destroy)
        return instance.destroy();
      return void 0;
    }
  };
  if (addMethods && Array.isArray(addMethods)) {
    addMethods.forEach(function(methodName) {
      methods[methodName] = function(el) {
        if (el === void 0) {
          el = defaultSelector;
        }
        var instance = methods.get(el);
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        if (instance && instance[methodName])
          return instance[methodName].apply(instance, args);
        return void 0;
      };
    });
  }
  return methods;
}

// node_modules/framework7/esm/shared/modal-methods.js
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function ModalMethods(parameters) {
  if (parameters === void 0) {
    parameters = {};
  }
  var _parameters = parameters, defaultSelector = _parameters.defaultSelector, Constructor = _parameters.constructor, app = _parameters.app;
  var methods = extend3(ConstructorMethods({
    defaultSelector,
    constructor: Constructor,
    app,
    domProp: "f7Modal"
  }), {
    open: function open(el, animate2, targetEl) {
      var $el = dom7_default(el);
      if ($el.length > 1 && targetEl) {
        var $targetPage = dom7_default(targetEl).parents(".page");
        if ($targetPage.length) {
          $el.each(function(modalEl) {
            var $modalEl = dom7_default(modalEl);
            if ($modalEl.parents($targetPage)[0] === $targetPage[0]) {
              $el = $modalEl;
            }
          });
        }
      }
      if ($el.length > 1) {
        $el = $el.eq($el.length - 1);
      }
      if (!$el.length)
        return void 0;
      var instance = $el[0].f7Modal;
      if (!instance) {
        var params = $el.dataset();
        instance = new Constructor(app, _extends2({
          el: $el
        }, params));
      }
      return instance.open(animate2);
    },
    close: function close(el, animate2, targetEl) {
      if (el === void 0) {
        el = defaultSelector;
      }
      var $el = dom7_default(el);
      if (!$el.length)
        return void 0;
      if ($el.length > 1) {
        var $parentEl;
        if (targetEl) {
          var $targetEl = dom7_default(targetEl);
          if ($targetEl.length) {
            $parentEl = $targetEl.parents($el);
          }
        }
        if ($parentEl && $parentEl.length > 0) {
          $el = $parentEl;
        } else {
          $el = $el.eq($el.length - 1);
        }
      }
      var instance = $el[0].f7Modal;
      if (!instance) {
        var params = $el.dataset();
        instance = new Constructor(app, _extends2({
          el: $el
        }, params));
      }
      return instance.close(animate2);
    }
  });
  return methods;
}

// node_modules/framework7/esm/components/app/load-module.js
var fetchedModules = [];
function loadModule(moduleToLoad) {
  var Framework72 = this;
  var window2 = getWindow();
  var document2 = getDocument();
  return new Promise(function(resolve, reject) {
    var app = Framework72.instance;
    var modulePath;
    var moduleObj;
    var moduleFunc;
    if (!moduleToLoad) {
      reject(new Error("Framework7: Lazy module must be specified"));
      return;
    }
    function install(module2) {
      Framework72.use(module2);
      if (app) {
        app.useModuleParams(module2, app.params);
        app.useModule(module2);
      }
    }
    if (typeof moduleToLoad === "string") {
      var matchNamePattern = moduleToLoad.match(/([a-z0-9-]*)/i);
      if (moduleToLoad.indexOf(".") < 0 && matchNamePattern && matchNamePattern[0].length === moduleToLoad.length) {
        if (!app || app && !app.params.lazyModulesPath) {
          reject(new Error('Framework7: "lazyModulesPath" app parameter must be specified to fetch module by name'));
          return;
        }
        modulePath = app.params.lazyModulesPath + "/" + moduleToLoad + "/" + moduleToLoad + ".js";
      } else {
        modulePath = moduleToLoad;
      }
    } else if (typeof moduleToLoad === "function") {
      moduleFunc = moduleToLoad;
    } else {
      moduleObj = moduleToLoad;
    }
    if (moduleFunc) {
      var module = moduleFunc(Framework72, false);
      if (!module) {
        reject(new Error("Framework7: Can't find Framework7 component in specified component function"));
        return;
      }
      if (Framework72.prototype.modules && Framework72.prototype.modules[module.name]) {
        resolve();
        return;
      }
      install(module);
      resolve();
    }
    if (moduleObj) {
      var _module = moduleObj;
      if (!_module) {
        reject(new Error("Framework7: Can't find Framework7 component in specified component"));
        return;
      }
      if (Framework72.prototype.modules && Framework72.prototype.modules[_module.name]) {
        resolve();
        return;
      }
      install(_module);
      resolve();
    }
    if (modulePath) {
      if (fetchedModules.indexOf(modulePath) >= 0) {
        resolve();
        return;
      }
      fetchedModules.push(modulePath);
      var scriptLoad = new Promise(function(resolveScript, rejectScript) {
        Framework72.request.get(modulePath, function(scriptContent) {
          var callbackId = id();
          var callbackLoadName = "f7_component_loader_callback_" + callbackId;
          var scriptEl = document2.createElement("script");
          scriptEl.innerHTML = "window." + callbackLoadName + " = function (Framework7, Framework7AutoInstallComponent) {return " + scriptContent.trim() + "}";
          dom7_default("head").append(scriptEl);
          var componentLoader = window2[callbackLoadName];
          delete window2[callbackLoadName];
          dom7_default(scriptEl).remove();
          var module2 = componentLoader(Framework72, false);
          if (!module2) {
            rejectScript(new Error("Framework7: Can't find Framework7 component in " + modulePath + " file"));
            return;
          }
          if (Framework72.prototype.modules && Framework72.prototype.modules[module2.name]) {
            resolveScript();
            return;
          }
          install(module2);
          resolveScript();
        }, function(xhr, status) {
          rejectScript(xhr, status);
        });
      });
      var styleLoad = new Promise(function(resolveStyle) {
        Framework72.request.get(modulePath.replace(".js", app.rtl ? ".rtl.css" : ".css"), function(styleContent) {
          var styleEl = document2.createElement("style");
          styleEl.innerHTML = styleContent;
          dom7_default("head").append(styleEl);
          resolveStyle();
        }, function() {
          resolveStyle();
        });
      });
      Promise.all([scriptLoad, styleLoad]).then(function() {
        resolve();
      }).catch(function(err) {
        reject(err);
      });
    }
  });
}
var load_module_default = loadModule;

// node_modules/framework7/esm/components/app/app-class.js
function _defineProperties3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties3(Constructor, staticProps);
  return Constructor;
}
function _assertThisInitialized3(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _inheritsLoose3(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var Framework7 = function(_Framework7Class) {
  _inheritsLoose3(Framework72, _Framework7Class);
  function Framework72(params) {
    var _this;
    if (params === void 0) {
      params = {};
    }
    _this = _Framework7Class.call(this, params) || this;
    if (Framework72.instance && typeof window !== "undefined") {
      throw new Error("Framework7 is already initialized and can't be initialized more than once");
    }
    var device2 = getDevice2({
      userAgent: params.userAgent || void 0
    });
    var support3 = getSupport2();
    var passedParams = extend3({}, params);
    var app = _assertThisInitialized3(_this);
    app.device = device2;
    app.support = support3;
    var w = getWindow();
    var d = getDocument();
    Framework72.instance = app;
    var defaults = {
      version: "1.0.0",
      id: "io.framework7.myapp",
      el: "body",
      theme: "auto",
      language: w.navigator.language,
      routes: [],
      name: "Framework7",
      lazyModulesPath: null,
      initOnDeviceReady: true,
      init: true,
      autoDarkTheme: false,
      iosTranslucentBars: true,
      iosTranslucentModals: true,
      component: void 0,
      componentUrl: void 0,
      userAgent: null,
      url: null
    };
    app.useModulesParams(defaults);
    app.params = extend3(defaults, params);
    extend3(app, {
      id: app.params.id,
      name: app.params.name,
      version: app.params.version,
      routes: app.params.routes,
      language: app.params.language,
      theme: function getTheme() {
        if (app.params.theme === "auto") {
          if (device2.ios)
            return "ios";
          if (device2.desktop && device2.electron)
            return "aurora";
          return "md";
        }
        return app.params.theme;
      }(),
      passedParams,
      online: w.navigator.onLine
    });
    if (params.store)
      app.params.store = params.store;
    if (app.$el && app.$el[0]) {
      app.$el[0].f7 = app;
    }
    app.useModules();
    app.initStore();
    if (app.params.init) {
      if (device2.cordova && app.params.initOnDeviceReady) {
        dom7_default(d).on("deviceready", function() {
          app.init();
        });
      } else {
        app.init();
      }
    }
    return app || _assertThisInitialized3(_this);
  }
  var _proto = Framework72.prototype;
  _proto.mount = function mount(rootEl) {
    var app = this;
    var window2 = getWindow();
    var document2 = getDocument();
    var $rootEl = dom7_default(rootEl || app.params.el).eq(0);
    app.$el = $rootEl;
    if (app.$el && app.$el[0]) {
      app.el = app.$el[0];
      app.el.f7 = app;
      app.rtl = $rootEl.css("direction") === "rtl";
    }
    var DARK = "(prefers-color-scheme: dark)";
    var LIGHT = "(prefers-color-scheme: light)";
    app.mq = {};
    if (window2.matchMedia) {
      app.mq.dark = window2.matchMedia(DARK);
      app.mq.light = window2.matchMedia(LIGHT);
    }
    app.colorSchemeListener = function colorSchemeListener(_ref) {
      var matches = _ref.matches, media = _ref.media;
      if (!matches) {
        return;
      }
      var html2 = document2.querySelector("html");
      if (media === DARK) {
        html2.classList.add("theme-dark");
        app.darkTheme = true;
        app.emit("darkThemeChange", true);
      } else if (media === LIGHT) {
        html2.classList.remove("theme-dark");
        app.darkTheme = false;
        app.emit("darkThemeChange", false);
      }
    };
    app.emit("mount");
  };
  _proto.initStore = function initStore() {
    var app = this;
    if (typeof app.params.store !== "undefined" && app.params.store.__store) {
      app.store = app.params.store;
    } else {
      app.store = app.createStore(app.params.store);
    }
  };
  _proto.enableAutoDarkTheme = function enableAutoDarkTheme() {
    var window2 = getWindow();
    var document2 = getDocument();
    if (!window2.matchMedia)
      return;
    var app = this;
    var html2 = document2.querySelector("html");
    if (app.mq.dark && app.mq.light) {
      app.mq.dark.addListener(app.colorSchemeListener);
      app.mq.light.addListener(app.colorSchemeListener);
    }
    if (app.mq.dark && app.mq.dark.matches) {
      html2.classList.add("theme-dark");
      app.darkTheme = true;
      app.emit("darkThemeChange", true);
    } else if (app.mq.light && app.mq.light.matches) {
      html2.classList.remove("theme-dark");
      app.darkTheme = false;
      app.emit("darkThemeChange", false);
    }
  };
  _proto.disableAutoDarkTheme = function disableAutoDarkTheme() {
    var window2 = getWindow();
    if (!window2.matchMedia)
      return;
    var app = this;
    if (app.mq.dark)
      app.mq.dark.removeListener(app.colorSchemeListener);
    if (app.mq.light)
      app.mq.light.removeListener(app.colorSchemeListener);
  };
  _proto.initAppComponent = function initAppComponent(callback) {
    var app = this;
    app.router.componentLoader(app.params.component, app.params.componentUrl, {
      componentOptions: {
        el: app.$el[0]
      }
    }, function(el) {
      app.$el = dom7_default(el);
      app.$el[0].f7 = app;
      app.$elComponent = el.f7Component;
      app.el = app.$el[0];
      if (callback)
        callback();
    }, function() {
    });
  };
  _proto.init = function init15(rootEl) {
    var app = this;
    app.mount(rootEl);
    var init16 = function init17() {
      if (app.initialized)
        return;
      app.$el.addClass("framework7-initializing");
      if (app.rtl) {
        dom7_default("html").attr("dir", "rtl");
      }
      if (app.params.autoDarkTheme) {
        app.enableAutoDarkTheme();
      }
      var window2 = getWindow();
      window2.addEventListener("offline", function() {
        app.online = false;
        app.emit("offline");
        app.emit("connection", false);
      });
      window2.addEventListener("online", function() {
        app.online = true;
        app.emit("online");
        app.emit("connection", true);
      });
      app.$el.addClass("framework7-root");
      dom7_default("html").removeClass("ios md aurora").addClass(app.theme);
      var device2 = app.device;
      if (app.params.iosTranslucentBars && app.theme === "ios" && device2.ios) {
        dom7_default("html").addClass("ios-translucent-bars");
      }
      if (app.params.iosTranslucentModals && app.theme === "ios" && device2.ios) {
        dom7_default("html").addClass("ios-translucent-modals");
      }
      nextFrame(function() {
        app.$el.removeClass("framework7-initializing");
      });
      app.initialized = true;
      app.emit("init");
    };
    if (app.params.component || app.params.componentUrl) {
      app.initAppComponent(function() {
        init16();
      });
    } else {
      init16();
    }
    return app;
  };
  _proto.loadModule = function loadModule2() {
    return Framework72.loadModule.apply(Framework72, arguments);
  };
  _proto.loadModules = function loadModules2() {
    return Framework72.loadModules.apply(Framework72, arguments);
  };
  _proto.getVnodeHooks = function getVnodeHooks(hook, id2) {
    var app = this;
    if (!app.vnodeHooks || !app.vnodeHooks[hook])
      return [];
    return app.vnodeHooks[hook][id2] || [];
  };
  _createClass3(Framework72, [{
    key: "$",
    get: function get2() {
      return dom7_default;
    }
  }], [{
    key: "Dom7",
    get: function get2() {
      return dom7_default;
    }
  }, {
    key: "$",
    get: function get2() {
      return dom7_default;
    }
  }, {
    key: "device",
    get: function get2() {
      return getDevice2();
    }
  }, {
    key: "support",
    get: function get2() {
      return getSupport2();
    }
  }, {
    key: "Class",
    get: function get2() {
      return class_default;
    }
  }, {
    key: "Events",
    get: function get2() {
      return events_class_default;
    }
  }]);
  return Framework72;
}(class_default);
Framework7.ModalMethods = ModalMethods;
Framework7.ConstructorMethods = ConstructorMethods;
Framework7.loadModule = load_module_default;
Framework7.loadModules = function loadModules(modules) {
  return Promise.all(modules.map(function(module) {
    return Framework7.loadModule(module);
  }));
};
var app_class_default = Framework7;

// node_modules/framework7/esm/components/modal/modal-class.js
function _assertThisInitialized4(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _inheritsLoose4(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var openedModals = [];
var dialogsQueue = [];
function clearDialogsQueue() {
  if (dialogsQueue.length === 0)
    return;
  var dialog = dialogsQueue.shift();
  dialog.open();
}
var Modal = function(_Framework7Class) {
  _inheritsLoose4(Modal2, _Framework7Class);
  function Modal2(app, params) {
    var _this;
    _this = _Framework7Class.call(this, params, [app]) || this;
    var modal = _assertThisInitialized4(_this);
    var defaults = {};
    modal.useModulesParams(defaults);
    modal.params = extend3(defaults, params);
    modal.opened = false;
    var $containerEl = modal.params.containerEl ? dom7_default(modal.params.containerEl).eq(0) : app.$el;
    if (!$containerEl.length)
      $containerEl = app.$el;
    modal.$containerEl = $containerEl;
    modal.containerEl = $containerEl[0];
    modal.useModules();
    return _assertThisInitialized4(_this) || _assertThisInitialized4(_this);
  }
  var _proto = Modal2.prototype;
  _proto.onOpen = function onOpen2() {
    var modal = this;
    modal.opened = true;
    openedModals.push(modal);
    dom7_default("html").addClass("with-modal-" + modal.type.toLowerCase());
    modal.$el.trigger("modal:open " + modal.type.toLowerCase() + ":open");
    modal.emit("local::open modalOpen " + modal.type + "Open", modal);
  };
  _proto.onOpened = function onOpened() {
    var modal = this;
    modal.$el.trigger("modal:opened " + modal.type.toLowerCase() + ":opened");
    modal.emit("local::opened modalOpened " + modal.type + "Opened", modal);
  };
  _proto.onClose = function onClose2() {
    var modal = this;
    modal.opened = false;
    if (!modal.type || !modal.$el)
      return;
    openedModals.splice(openedModals.indexOf(modal), 1);
    dom7_default("html").removeClass("with-modal-" + modal.type.toLowerCase());
    modal.$el.trigger("modal:close " + modal.type.toLowerCase() + ":close");
    modal.emit("local::close modalClose " + modal.type + "Close", modal);
  };
  _proto.onClosed = function onClosed() {
    var modal = this;
    if (!modal.type || !modal.$el)
      return;
    modal.$el.removeClass("modal-out");
    modal.$el.hide();
    modal.$el.trigger("modal:closed " + modal.type.toLowerCase() + ":closed");
    modal.emit("local::closed modalClosed " + modal.type + "Closed", modal);
  };
  _proto.open = function open(animateModal) {
    var modal = this;
    var document2 = getDocument();
    var app = modal.app;
    var $el = modal.$el;
    var $backdropEl = modal.$backdropEl;
    var type = modal.type;
    var animate2 = true;
    if (typeof animateModal !== "undefined")
      animate2 = animateModal;
    else if (typeof modal.params.animate !== "undefined") {
      animate2 = modal.params.animate;
    }
    if (!$el || $el.hasClass("modal-in")) {
      if (animateModal === false && $el[0] && type !== "dialog") {
        $el[0].style.display = "block";
      }
      return modal;
    }
    if (type === "dialog" && app.params.modal.queueDialogs) {
      var pushToQueue;
      if (dom7_default(".dialog.modal-in").length > 0) {
        pushToQueue = true;
      } else if (openedModals.length > 0) {
        openedModals.forEach(function(openedModal) {
          if (openedModal.type === "dialog")
            pushToQueue = true;
        });
      }
      if (pushToQueue) {
        dialogsQueue.push(modal);
        return modal;
      }
    }
    var $modalParentEl = $el.parent();
    var wasInDom = $el.parents(document2).length > 0;
    if (!$modalParentEl.is(modal.$containerEl)) {
      modal.$containerEl.append($el);
      modal.once(type + "Closed", function() {
        if (wasInDom) {
          $modalParentEl.append($el);
        } else {
          $el.remove();
        }
      });
    }
    $el.show();
    modal._clientLeft = $el[0].clientLeft;
    function transitionEnd3() {
      if ($el.hasClass("modal-out")) {
        modal.onClosed();
      } else if ($el.hasClass("modal-in")) {
        modal.onOpened();
      }
    }
    if (animate2) {
      if ($backdropEl) {
        $backdropEl.removeClass("not-animated");
        $backdropEl.addClass("backdrop-in");
      }
      $el.animationEnd(function() {
        transitionEnd3();
      });
      $el.transitionEnd(function() {
        transitionEnd3();
      });
      $el.removeClass("modal-out not-animated").addClass("modal-in");
      modal.onOpen();
    } else {
      if ($backdropEl) {
        $backdropEl.addClass("backdrop-in not-animated");
      }
      $el.removeClass("modal-out").addClass("modal-in not-animated");
      modal.onOpen();
      modal.onOpened();
    }
    return modal;
  };
  _proto.close = function close(animateModal) {
    var modal = this;
    var $el = modal.$el;
    var $backdropEl = modal.$backdropEl;
    var animate2 = true;
    if (typeof animateModal !== "undefined")
      animate2 = animateModal;
    else if (typeof modal.params.animate !== "undefined") {
      animate2 = modal.params.animate;
    }
    if (!$el || !$el.hasClass("modal-in")) {
      if (dialogsQueue.indexOf(modal) >= 0) {
        dialogsQueue.splice(dialogsQueue.indexOf(modal), 1);
      }
      return modal;
    }
    if ($backdropEl) {
      var needToHideBackdrop = true;
      if (modal.type === "popup") {
        modal.$el.prevAll(".popup.modal-in").add(modal.$el.nextAll(".popup.modal-in")).each(function(popupEl) {
          var popupInstance = popupEl.f7Modal;
          if (!popupInstance)
            return;
          if (popupInstance.params.closeByBackdropClick && popupInstance.params.backdrop && popupInstance.backdropEl === modal.backdropEl) {
            needToHideBackdrop = false;
          }
        });
      }
      if (needToHideBackdrop) {
        $backdropEl[animate2 ? "removeClass" : "addClass"]("not-animated");
        $backdropEl.removeClass("backdrop-in");
      }
    }
    $el[animate2 ? "removeClass" : "addClass"]("not-animated");
    function transitionEnd3() {
      if ($el.hasClass("modal-out")) {
        modal.onClosed();
      } else if ($el.hasClass("modal-in")) {
        modal.onOpened();
      }
    }
    if (animate2) {
      $el.animationEnd(function() {
        transitionEnd3();
      });
      $el.transitionEnd(function() {
        transitionEnd3();
      });
      $el.removeClass("modal-in").addClass("modal-out");
      modal.onClose();
    } else {
      $el.addClass("not-animated").removeClass("modal-in").addClass("modal-out");
      modal.onClose();
      modal.onClosed();
    }
    if (modal.type === "dialog") {
      clearDialogsQueue();
    }
    return modal;
  };
  _proto.destroy = function destroy5() {
    var modal = this;
    if (modal.destroyed)
      return;
    modal.emit("local::beforeDestroy modalBeforeDestroy " + modal.type + "BeforeDestroy", modal);
    if (modal.$el) {
      modal.$el.trigger("modal:beforedestroy " + modal.type.toLowerCase() + ":beforedestroy");
      if (modal.$el.length && modal.$el[0].f7Modal) {
        delete modal.$el[0].f7Modal;
      }
    }
    deleteProps2(modal);
    modal.destroyed = true;
  };
  return Modal2;
}(class_default);
var modal_class_default = Modal;

// node_modules/framework7/esm/components/modal/custom-modal-class.js
function _assertThisInitialized5(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _inheritsLoose5(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var CustomModal = function(_Modal) {
  _inheritsLoose5(CustomModal2, _Modal);
  function CustomModal2(app, params) {
    var _this;
    var extendedParams = extend3({
      backdrop: true,
      closeByBackdropClick: true,
      on: {}
    }, params);
    _this = _Modal.call(this, app, extendedParams) || this;
    var customModal = _assertThisInitialized5(_this);
    customModal.params = extendedParams;
    var $el;
    if (!customModal.params.el) {
      $el = dom7_default(customModal.params.content);
    } else {
      $el = dom7_default(customModal.params.el);
    }
    if ($el && $el.length > 0 && $el[0].f7Modal) {
      return $el[0].f7Modal || _assertThisInitialized5(_this);
    }
    if ($el.length === 0) {
      return customModal.destroy() || _assertThisInitialized5(_this);
    }
    var $backdropEl;
    if (customModal.params.backdrop) {
      $backdropEl = app.$el.children(".custom-modal-backdrop");
      if ($backdropEl.length === 0) {
        $backdropEl = dom7_default('<div class="custom-modal-backdrop"></div>');
        app.$el.append($backdropEl);
      }
    }
    function handleClick(e) {
      if (!customModal || customModal.destroyed)
        return;
      if ($backdropEl && e.target === $backdropEl[0]) {
        customModal.close();
      }
    }
    customModal.on("customModalOpened", function() {
      if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
        app.on("click", handleClick);
      }
    });
    customModal.on("customModalClose", function() {
      if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
        app.off("click", handleClick);
      }
    });
    extend3(customModal, {
      app,
      $el,
      el: $el[0],
      $backdropEl,
      backdropEl: $backdropEl && $backdropEl[0],
      type: "customModal"
    });
    $el[0].f7Modal = customModal;
    return customModal || _assertThisInitialized5(_this);
  }
  return CustomModal2;
}(modal_class_default);
var custom_modal_class_default = CustomModal;

// node_modules/framework7/esm/components/modal/modal.js
var modal_default = {
  name: "modal",
  static: {
    Modal: modal_class_default,
    CustomModal: custom_modal_class_default
  },
  create: function create3() {
    var app = this;
    app.customModal = {
      create: function create13(params) {
        return new custom_modal_class_default(app, params);
      }
    };
  },
  params: {
    modal: {
      queueDialogs: true
    }
  }
};

// node_modules/framework7/esm/components/navbar/navbar.js
var Navbar = {
  size: function size(el) {
    var app = this;
    var $el = dom7_default(el);
    if ($el.hasClass("navbars")) {
      $el = $el.children(".navbar").each(function(navbarEl) {
        app.navbar.size(navbarEl);
      });
      return;
    }
    var $innerEl = $el.children(".navbar-inner");
    if (!$innerEl.length)
      return;
    var needCenterTitle = $innerEl.hasClass("navbar-inner-centered-title") || app.params.navbar[app.theme + "CenterTitle"];
    var needLeftTitle = app.theme === "ios" && !app.params.navbar[app.theme + "CenterTitle"];
    if (!needCenterTitle && !needLeftTitle)
      return;
    if ($el.hasClass("stacked") || $el.parents(".stacked").length > 0 || $el.parents(".tab:not(.tab-active)").length > 0 || $el.parents(".popup:not(.modal-in)").length > 0) {
      return;
    }
    if (app.theme !== "ios" && app.params.navbar[app.theme + "CenterTitle"]) {
      $innerEl.addClass("navbar-inner-centered-title");
    }
    if (app.theme === "ios" && !app.params.navbar.iosCenterTitle) {
      $innerEl.addClass("navbar-inner-left-title");
    }
    var $viewEl = $el.parents(".view").eq(0);
    var left = app.rtl ? $innerEl.children(".right") : $innerEl.children(".left");
    var right = app.rtl ? $innerEl.children(".left") : $innerEl.children(".right");
    var title = $innerEl.children(".title");
    var subnavbar = $innerEl.children(".subnavbar");
    var noLeft = left.length === 0;
    var noRight = right.length === 0;
    var leftWidth = noLeft ? 0 : left.outerWidth(true);
    var rightWidth = noRight ? 0 : right.outerWidth(true);
    var titleWidth = title.outerWidth(true);
    var navbarStyles = $innerEl.styles();
    var navbarWidth = $innerEl[0].offsetWidth;
    var navbarInnerWidth = navbarWidth - parseInt(navbarStyles.paddingLeft, 10) - parseInt(navbarStyles.paddingRight, 10);
    var isPrevious = $el.hasClass("navbar-previous");
    var sliding = $innerEl.hasClass("sliding");
    var router;
    var dynamicNavbar;
    if ($viewEl.length > 0 && $viewEl[0].f7View) {
      router = $viewEl[0].f7View.router;
      dynamicNavbar = router && router.dynamicNavbar;
    }
    var currLeft;
    var diff;
    if (noRight) {
      currLeft = navbarInnerWidth - titleWidth;
    }
    if (noLeft) {
      currLeft = 0;
    }
    if (!noLeft && !noRight) {
      currLeft = (navbarInnerWidth - rightWidth - titleWidth + leftWidth) / 2;
    }
    var requiredLeft = (navbarInnerWidth - titleWidth) / 2;
    if (navbarInnerWidth - leftWidth - rightWidth > titleWidth) {
      if (requiredLeft < leftWidth) {
        requiredLeft = leftWidth;
      }
      if (requiredLeft + titleWidth > navbarInnerWidth - rightWidth) {
        requiredLeft = navbarInnerWidth - rightWidth - titleWidth;
      }
      diff = requiredLeft - currLeft;
    } else {
      diff = 0;
    }
    var inverter = app.rtl ? -1 : 1;
    if (dynamicNavbar && app.theme === "ios") {
      if (title.hasClass("sliding") || title.length > 0 && sliding) {
        var titleLeftOffset = -(currLeft + diff) * inverter;
        var titleRightOffset = (navbarInnerWidth - currLeft - diff - titleWidth) * inverter;
        if (isPrevious) {
          if (router && router.params.iosAnimateNavbarBackIcon) {
            var activeNavbarBackLink = $el.parent().find(".navbar-current").children(".left.sliding").find(".back .icon ~ span");
            if (activeNavbarBackLink.length > 0) {
              titleLeftOffset += activeNavbarBackLink[0].offsetLeft;
            }
          }
        }
        title[0].f7NavbarLeftOffset = titleLeftOffset;
        title[0].f7NavbarRightOffset = titleRightOffset;
      }
      if (!noLeft && (left.hasClass("sliding") || sliding)) {
        if (app.rtl) {
          left[0].f7NavbarLeftOffset = -(navbarInnerWidth - left[0].offsetWidth) / 2 * inverter;
          left[0].f7NavbarRightOffset = leftWidth * inverter;
        } else {
          left[0].f7NavbarLeftOffset = -leftWidth;
          left[0].f7NavbarRightOffset = (navbarInnerWidth - left[0].offsetWidth) / 2;
          if (router && router.params.iosAnimateNavbarBackIcon && left.find(".back .icon").length > 0) {
            if (left.find(".back .icon ~ span").length) {
              var leftOffset = left[0].f7NavbarLeftOffset;
              var rightOffset = left[0].f7NavbarRightOffset;
              left[0].f7NavbarLeftOffset = 0;
              left[0].f7NavbarRightOffset = 0;
              left.find(".back .icon ~ span")[0].f7NavbarLeftOffset = leftOffset;
              left.find(".back .icon ~ span")[0].f7NavbarRightOffset = rightOffset - left.find(".back .icon")[0].offsetWidth;
            }
          }
        }
      }
      if (!noRight && (right.hasClass("sliding") || sliding)) {
        if (app.rtl) {
          right[0].f7NavbarLeftOffset = -rightWidth * inverter;
          right[0].f7NavbarRightOffset = (navbarInnerWidth - right[0].offsetWidth) / 2 * inverter;
        } else {
          right[0].f7NavbarLeftOffset = -(navbarInnerWidth - right[0].offsetWidth) / 2;
          right[0].f7NavbarRightOffset = rightWidth;
        }
      }
      if (subnavbar.length && (subnavbar.hasClass("sliding") || sliding)) {
        subnavbar[0].f7NavbarLeftOffset = app.rtl ? subnavbar[0].offsetWidth : -subnavbar[0].offsetWidth;
        subnavbar[0].f7NavbarRightOffset = -subnavbar[0].f7NavbarLeftOffset;
      }
    }
    if (needCenterTitle) {
      var titleLeft = diff;
      if (app.rtl && noLeft && noRight && title.length > 0)
        titleLeft = -titleLeft;
      title.css({
        left: titleLeft + "px"
      });
    }
  },
  hide: function hide2(el, animate2, hideStatusbar, hideOnlyCurrent) {
    if (animate2 === void 0) {
      animate2 = true;
    }
    if (hideStatusbar === void 0) {
      hideStatusbar = false;
    }
    if (hideOnlyCurrent === void 0) {
      hideOnlyCurrent = false;
    }
    var app = this;
    var $el = dom7_default(el);
    var isDynamic = $el.hasClass("navbar") && $el.parent(".navbars").length && !hideOnlyCurrent;
    if (isDynamic)
      $el = $el.parents(".navbars");
    if (!$el.length)
      return;
    if ($el.hasClass("navbar-hidden"))
      return;
    var className = "navbar-hidden" + (animate2 ? " navbar-transitioning" : "");
    var currentIsLarge = isDynamic ? $el.find(".navbar-current .title-large").length : $el.find(".title-large").length;
    if (currentIsLarge) {
      className += " navbar-large-hidden";
    }
    if (hideStatusbar) {
      className += " navbar-hidden-statusbar";
    }
    $el.transitionEnd(function() {
      $el.removeClass("navbar-transitioning");
    });
    $el.addClass(className);
    if (isDynamic) {
      $el.children(".navbar").each(function(subEl) {
        dom7_default(subEl).trigger("navbar:hide");
        app.emit("navbarHide", subEl);
      });
    } else {
      $el.trigger("navbar:hide");
      app.emit("navbarHide", $el[0]);
    }
  },
  show: function show2(el, animate2, hideOnlyCurrent) {
    if (el === void 0) {
      el = ".navbar-hidden";
    }
    if (animate2 === void 0) {
      animate2 = true;
    }
    if (hideOnlyCurrent === void 0) {
      hideOnlyCurrent = false;
    }
    var app = this;
    var $el = dom7_default(el);
    var isDynamic = $el.hasClass("navbar") && $el.parent(".navbars").length && !hideOnlyCurrent;
    if (isDynamic)
      $el = $el.parents(".navbars");
    if (!$el.length)
      return;
    if (!$el.hasClass("navbar-hidden"))
      return;
    if (animate2) {
      $el.addClass("navbar-transitioning");
      $el.transitionEnd(function() {
        $el.removeClass("navbar-transitioning");
      });
    }
    $el.removeClass("navbar-hidden navbar-large-hidden navbar-hidden-statusbar");
    if (isDynamic) {
      $el.children(".navbar").each(function(subEl) {
        dom7_default(subEl).trigger("navbar:show");
        app.emit("navbarShow", subEl);
      });
    } else {
      $el.trigger("navbar:show");
      app.emit("navbarShow", $el[0]);
    }
  },
  getElByPage: function getElByPage(page) {
    var $pageEl;
    var $navbarEl;
    var pageData;
    if (page.$navbarEl || page.$el) {
      pageData = page;
      $pageEl = page.$el;
    } else {
      $pageEl = dom7_default(page);
      if ($pageEl.length > 0)
        pageData = $pageEl[0].f7Page;
    }
    if (pageData && pageData.$navbarEl && pageData.$navbarEl.length > 0) {
      $navbarEl = pageData.$navbarEl;
    } else if ($pageEl) {
      $navbarEl = $pageEl.children(".navbar");
    }
    if (!$navbarEl || $navbarEl && $navbarEl.length === 0)
      return void 0;
    return $navbarEl[0];
  },
  getPageByEl: function getPageByEl(navbarEl) {
    var $navbarEl = dom7_default(navbarEl);
    if ($navbarEl.parents(".page").length) {
      return $navbarEl.parents(".page")[0];
    }
    var pageEl;
    $navbarEl.parents(".view").find(".page").each(function(el) {
      if (el && el.f7Page && el.f7Page.navbarEl && $navbarEl[0] === el.f7Page.navbarEl) {
        pageEl = el;
      }
    });
    return pageEl;
  },
  collapseLargeTitle: function collapseLargeTitle(navbarEl) {
    var app = this;
    var $navbarEl = dom7_default(navbarEl);
    if ($navbarEl.hasClass("navbars")) {
      $navbarEl = $navbarEl.find(".navbar");
      if ($navbarEl.length > 1) {
        $navbarEl = dom7_default(navbarEl).find(".navbar-large.navbar-current");
      }
      if ($navbarEl.length > 1 || !$navbarEl.length) {
        return;
      }
    }
    var $pageEl = dom7_default(app.navbar.getPageByEl($navbarEl));
    $navbarEl.addClass("navbar-large-collapsed");
    $pageEl.eq(0).addClass("page-with-navbar-large-collapsed").trigger("page:navbarlargecollapsed");
    app.emit("pageNavbarLargeCollapsed", $pageEl[0]);
    $navbarEl.trigger("navbar:collapse");
    app.emit("navbarCollapse", $navbarEl[0]);
  },
  expandLargeTitle: function expandLargeTitle(navbarEl) {
    var app = this;
    var $navbarEl = dom7_default(navbarEl);
    if ($navbarEl.hasClass("navbars")) {
      $navbarEl = $navbarEl.find(".navbar-large");
      if ($navbarEl.length > 1) {
        $navbarEl = dom7_default(navbarEl).find(".navbar-large.navbar-current");
      }
      if ($navbarEl.length > 1 || !$navbarEl.length) {
        return;
      }
    }
    var $pageEl = dom7_default(app.navbar.getPageByEl($navbarEl));
    $navbarEl.removeClass("navbar-large-collapsed");
    $pageEl.eq(0).removeClass("page-with-navbar-large-collapsed").trigger("page:navbarlargeexpanded");
    app.emit("pageNavbarLargeExpanded", $pageEl[0]);
    $navbarEl.trigger("navbar:expand");
    app.emit("navbarExpand", $navbarEl[0]);
  },
  toggleLargeTitle: function toggleLargeTitle(navbarEl) {
    var app = this;
    var $navbarEl = dom7_default(navbarEl);
    if ($navbarEl.hasClass("navbars")) {
      $navbarEl = $navbarEl.find(".navbar-large");
      if ($navbarEl.length > 1) {
        $navbarEl = dom7_default(navbarEl).find(".navbar-large.navbar-current");
      }
      if ($navbarEl.length > 1 || !$navbarEl.length) {
        return;
      }
    }
    if ($navbarEl.hasClass("navbar-large-collapsed")) {
      app.navbar.expandLargeTitle($navbarEl);
    } else {
      app.navbar.collapseLargeTitle($navbarEl);
    }
  },
  initNavbarOnScroll: function initNavbarOnScroll(pageEl, navbarEl, needHide, needCollapse, needTransparent) {
    var app = this;
    var support3 = getSupport2();
    var $pageEl = dom7_default(pageEl);
    var $navbarEl = dom7_default(navbarEl);
    var $titleLargeEl = $navbarEl.find(".title-large");
    var isLarge = $titleLargeEl.length || $navbarEl.hasClass(".navbar-large");
    var navbarHideHeight = 44;
    var snapPageScrollToLargeTitle = app.params.navbar.snapPageScrollToLargeTitle;
    var snapPageScrollToTransparentNavbar = app.params.navbar.snapPageScrollToTransparentNavbar;
    var previousScrollTop;
    var currentScrollTop;
    var scrollHeight;
    var offsetHeight;
    var reachEnd;
    var action;
    var navbarHidden;
    var navbarCollapsed;
    var navbarTitleLargeHeight;
    var navbarOffsetHeight;
    if (needCollapse || needHide && isLarge) {
      navbarTitleLargeHeight = $navbarEl.css("--f7-navbar-large-title-height");
      if (navbarTitleLargeHeight && navbarTitleLargeHeight.indexOf("px") >= 0) {
        navbarTitleLargeHeight = parseInt(navbarTitleLargeHeight, 10);
        if (Number.isNaN(navbarTitleLargeHeight) && $titleLargeEl.length) {
          navbarTitleLargeHeight = $titleLargeEl[0].offsetHeight;
        } else if (Number.isNaN(navbarTitleLargeHeight)) {
          if (app.theme === "ios")
            navbarTitleLargeHeight = 52;
          else if (app.theme === "md")
            navbarTitleLargeHeight = 48;
          else if (app.theme === "aurora")
            navbarTitleLargeHeight = 38;
        }
      } else if ($titleLargeEl.length) {
        navbarTitleLargeHeight = $titleLargeEl[0].offsetHeight;
      } else {
        if (app.theme === "ios")
          navbarTitleLargeHeight = 52;
        else if (app.theme === "md")
          navbarTitleLargeHeight = 48;
        else if (app.theme === "aurora")
          navbarTitleLargeHeight = 38;
      }
    }
    if (needHide && isLarge) {
      navbarHideHeight += navbarTitleLargeHeight;
    }
    var scrollChanged;
    var scrollContent;
    var scrollTimeoutId;
    var touchEndTimeoutId;
    var touchSnapTimeout = 70;
    var desktopSnapTimeout = 300;
    function snapLargeNavbar() {
      var inSearchbarExpanded = $navbarEl.hasClass("with-searchbar-expandable-enabled");
      if (inSearchbarExpanded)
        return;
      if (!scrollContent || currentScrollTop < 0)
        return;
      if (currentScrollTop >= navbarTitleLargeHeight / 2 && currentScrollTop < navbarTitleLargeHeight) {
        dom7_default(scrollContent).scrollTop(navbarTitleLargeHeight, 100);
      } else if (currentScrollTop < navbarTitleLargeHeight) {
        dom7_default(scrollContent).scrollTop(0, 200);
      }
    }
    function snapTransparentNavbar() {
      var inSearchbarExpanded = $navbarEl.hasClass("with-searchbar-expandable-enabled");
      if (inSearchbarExpanded)
        return;
      if (!scrollContent || currentScrollTop < 0)
        return;
      if (currentScrollTop >= navbarOffsetHeight / 2 && currentScrollTop < navbarOffsetHeight) {
        dom7_default(scrollContent).scrollTop(navbarOffsetHeight, 100);
      } else if (currentScrollTop < navbarOffsetHeight) {
        dom7_default(scrollContent).scrollTop(0, 200);
      }
    }
    function handleNavbarTransparent() {
      var isHidden = $navbarEl.hasClass("navbar-hidden") || $navbarEl.parent(".navbars").hasClass("navbar-hidden");
      var inSearchbarExpanded = $navbarEl.hasClass("with-searchbar-expandable-enabled");
      if (inSearchbarExpanded || isHidden)
        return;
      if (!navbarOffsetHeight) {
        navbarOffsetHeight = navbarEl.offsetHeight;
      }
      var opacity = currentScrollTop / navbarOffsetHeight;
      var notTransparent = $navbarEl.hasClass("navbar-transparent-visible");
      opacity = Math.max(Math.min(opacity, 1), 0);
      if (notTransparent && opacity === 1 || !notTransparent && opacity === 0) {
        $navbarEl.find(".navbar-bg, .title").css("opacity", "");
        return;
      }
      if (notTransparent && opacity === 0) {
        $navbarEl.trigger("navbar:transparenthide");
        app.emit("navbarTransparentHide", $navbarEl[0]);
        $navbarEl.removeClass("navbar-transparent-visible");
        $navbarEl.find(".navbar-bg, .title").css("opacity", "");
        return;
      }
      if (!notTransparent && opacity === 1) {
        $navbarEl.trigger("navbar:transparentshow");
        app.emit("navbarTransparentShow", $navbarEl[0]);
        $navbarEl.addClass("navbar-transparent-visible");
        $navbarEl.find(".navbar-bg, .title").css("opacity", "");
        return;
      }
      $navbarEl.find(".navbar-bg, .title").css("opacity", opacity);
      if (snapPageScrollToTransparentNavbar) {
        if (!support3.touch) {
          clearTimeout(scrollTimeoutId);
          scrollTimeoutId = setTimeout(function() {
            snapTransparentNavbar();
          }, desktopSnapTimeout);
        } else if (touchEndTimeoutId) {
          clearTimeout(touchEndTimeoutId);
          touchEndTimeoutId = null;
          touchEndTimeoutId = setTimeout(function() {
            snapTransparentNavbar();
            clearTimeout(touchEndTimeoutId);
            touchEndTimeoutId = null;
          }, touchSnapTimeout);
        }
      }
    }
    var previousCollapseProgress = null;
    var collapseProgress = null;
    function handleLargeNavbarCollapse() {
      var isHidden = $navbarEl.hasClass("navbar-hidden") || $navbarEl.parent(".navbars").hasClass("navbar-hidden");
      if (isHidden)
        return;
      var isLargeTransparent = $navbarEl.hasClass("navbar-large-transparent") || $navbarEl.hasClass("navbar-large") && $navbarEl.hasClass("navbar-transparent");
      previousCollapseProgress = collapseProgress;
      collapseProgress = Math.min(Math.max(currentScrollTop / navbarTitleLargeHeight, 0), 1);
      var previousCollapseWasInMiddle = previousCollapseProgress > 0 && previousCollapseProgress < 1;
      var inSearchbarExpanded = $navbarEl.hasClass("with-searchbar-expandable-enabled");
      if (inSearchbarExpanded)
        return;
      navbarCollapsed = $navbarEl.hasClass("navbar-large-collapsed");
      if (collapseProgress === 0 && navbarCollapsed) {
        app.navbar.expandLargeTitle($navbarEl[0]);
      } else if (collapseProgress === 1 && !navbarCollapsed) {
        app.navbar.collapseLargeTitle($navbarEl[0]);
      }
      if (collapseProgress === 0 && navbarCollapsed || collapseProgress === 0 && previousCollapseWasInMiddle || collapseProgress === 1 && !navbarCollapsed || collapseProgress === 1 && previousCollapseWasInMiddle) {
        if (app.theme === "md") {
          $navbarEl.find(".navbar-inner").css("overflow", "");
        }
        $navbarEl.find(".title").css("opacity", "");
        $navbarEl.find(".title-large-text, .subnavbar").css("transform", "");
        if (isLargeTransparent) {
          $navbarEl.find(".navbar-bg").css("opacity", "");
        } else {
          $navbarEl.find(".navbar-bg").css("transform", "");
        }
      } else if (collapseProgress > 0 && collapseProgress < 1) {
        if (app.theme === "md") {
          $navbarEl.find(".navbar-inner").css("overflow", "visible");
        }
        $navbarEl.find(".title").css("opacity", collapseProgress);
        $navbarEl.find(".title-large-text, .subnavbar").css("transform", "translate3d(0px, " + -1 * collapseProgress * navbarTitleLargeHeight + "px, 0)");
        if (isLargeTransparent) {
          $navbarEl.find(".navbar-bg").css("opacity", collapseProgress);
        } else {
          $navbarEl.find(".navbar-bg").css("transform", "translate3d(0px, " + -1 * collapseProgress * navbarTitleLargeHeight + "px, 0)");
        }
      }
      if (snapPageScrollToLargeTitle) {
        if (!support3.touch) {
          clearTimeout(scrollTimeoutId);
          scrollTimeoutId = setTimeout(function() {
            snapLargeNavbar();
          }, desktopSnapTimeout);
        } else if (touchEndTimeoutId) {
          clearTimeout(touchEndTimeoutId);
          touchEndTimeoutId = null;
          touchEndTimeoutId = setTimeout(function() {
            snapLargeNavbar();
            clearTimeout(touchEndTimeoutId);
            touchEndTimeoutId = null;
          }, touchSnapTimeout);
        }
      }
    }
    function handleTitleHideShow() {
      if ($pageEl.hasClass("page-with-card-opened"))
        return;
      scrollHeight = scrollContent.scrollHeight;
      offsetHeight = scrollContent.offsetHeight;
      reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
      navbarHidden = $navbarEl.hasClass("navbar-hidden") || $navbarEl.parent(".navbars").hasClass("navbar-hidden");
      if (reachEnd) {
        if (app.params.navbar.showOnPageScrollEnd) {
          action = "show";
        }
      } else if (previousScrollTop > currentScrollTop) {
        if (app.params.navbar.showOnPageScrollTop || currentScrollTop <= navbarHideHeight) {
          action = "show";
        } else {
          action = "hide";
        }
      } else if (currentScrollTop > navbarHideHeight) {
        action = "hide";
      } else {
        action = "show";
      }
      if (action === "show" && navbarHidden) {
        app.navbar.show($navbarEl, true, true);
        navbarHidden = false;
      } else if (action === "hide" && !navbarHidden) {
        app.navbar.hide($navbarEl, true, false, true);
        navbarHidden = true;
      }
      previousScrollTop = currentScrollTop;
    }
    function handleScroll(e) {
      scrollContent = this;
      if (e && e.target && e.target !== scrollContent) {
        return;
      }
      currentScrollTop = scrollContent.scrollTop;
      scrollChanged = currentScrollTop;
      if (needCollapse) {
        handleLargeNavbarCollapse();
      } else if (needTransparent) {
        handleNavbarTransparent();
      }
      if ($pageEl.hasClass("page-previous"))
        return;
      if (needHide) {
        handleTitleHideShow();
      }
    }
    function handeTouchStart() {
      scrollChanged = false;
    }
    function handleTouchEnd() {
      clearTimeout(touchEndTimeoutId);
      touchEndTimeoutId = null;
      touchEndTimeoutId = setTimeout(function() {
        if (scrollChanged !== false) {
          if (needTransparent && !needCollapse) {
            snapTransparentNavbar();
          } else {
            snapLargeNavbar();
          }
          clearTimeout(touchEndTimeoutId);
          touchEndTimeoutId = null;
        }
      }, touchSnapTimeout);
    }
    $pageEl.on("scroll", ".page-content", handleScroll, true);
    if (support3.touch && (needCollapse && snapPageScrollToLargeTitle || needTransparent && snapPageScrollToTransparentNavbar)) {
      app.on("touchstart:passive", handeTouchStart);
      app.on("touchend:passive", handleTouchEnd);
    }
    if (needCollapse) {
      $pageEl.find(".page-content").each(function(pageContentEl) {
        if (pageContentEl.scrollTop > 0)
          handleScroll.call(pageContentEl);
      });
    } else if (needTransparent) {
      $pageEl.find(".page-content").each(function(pageContentEl) {
        if (pageContentEl.scrollTop > 0)
          handleScroll.call(pageContentEl);
      });
    }
    $pageEl[0].f7DetachNavbarScrollHandlers = function f7DetachNavbarScrollHandlers() {
      delete $pageEl[0].f7DetachNavbarScrollHandlers;
      $pageEl.off("scroll", ".page-content", handleScroll, true);
      if (support3.touch && (needCollapse && snapPageScrollToLargeTitle || needTransparent && snapPageScrollToTransparentNavbar)) {
        app.off("touchstart:passive", handeTouchStart);
        app.off("touchend:passive", handleTouchEnd);
      }
    };
  }
};
var navbar_default = {
  name: "navbar",
  create: function create4() {
    var app = this;
    bindMethods(app, {
      navbar: Navbar
    });
  },
  params: {
    navbar: {
      scrollTopOnTitleClick: true,
      iosCenterTitle: true,
      mdCenterTitle: false,
      auroraCenterTitle: true,
      hideOnPageScroll: false,
      showOnPageScrollEnd: true,
      showOnPageScrollTop: true,
      collapseLargeTitleOnScroll: true,
      snapPageScrollToLargeTitle: true,
      snapPageScrollToTransparentNavbar: true
    }
  },
  on: {
    "panelBreakpoint panelCollapsedBreakpoint panelResize viewResize resize viewMasterDetailBreakpoint": function onPanelResize() {
      var app = this;
      dom7_default(".navbar").each(function(navbarEl) {
        app.navbar.size(navbarEl);
      });
    },
    pageBeforeRemove: function pageBeforeRemove(page) {
      if (page.$el[0].f7DetachNavbarScrollHandlers) {
        page.$el[0].f7DetachNavbarScrollHandlers();
      }
    },
    pageBeforeIn: function pageBeforeIn(page) {
      var app = this;
      if (app.theme !== "ios")
        return;
      var $navbarsEl;
      var view = page.$el.parents(".view")[0].f7View;
      var navbarEl = app.navbar.getElByPage(page);
      if (!navbarEl) {
        $navbarsEl = page.$el.parents(".view").children(".navbars");
      } else {
        $navbarsEl = dom7_default(navbarEl).parents(".navbars");
      }
      if (page.$el.hasClass("no-navbar") || view.router.dynamicNavbar && !navbarEl) {
        var animate2 = !!(page.pageFrom && page.router.history.length > 0);
        app.navbar.hide($navbarsEl, animate2);
      } else {
        app.navbar.show($navbarsEl);
      }
    },
    pageReinit: function pageReinit(page) {
      var app = this;
      var $navbarEl = dom7_default(app.navbar.getElByPage(page));
      if (!$navbarEl || $navbarEl.length === 0)
        return;
      app.navbar.size($navbarEl);
    },
    pageInit: function pageInit(page) {
      var app = this;
      var $navbarEl = dom7_default(app.navbar.getElByPage(page));
      if (!$navbarEl || $navbarEl.length === 0)
        return;
      app.navbar.size($navbarEl);
      var needCollapseOnScrollHandler;
      if ($navbarEl.find(".title-large").length > 0) {
        $navbarEl.addClass("navbar-large");
      }
      if ($navbarEl.hasClass("navbar-large")) {
        if (app.params.navbar.collapseLargeTitleOnScroll)
          needCollapseOnScrollHandler = true;
        page.$el.addClass("page-with-navbar-large");
      }
      var needTransparentOnScroll;
      if (!needCollapseOnScrollHandler && $navbarEl.hasClass("navbar-transparent")) {
        needTransparentOnScroll = true;
      }
      var needHideOnScrollHandler;
      if (app.params.navbar.hideOnPageScroll || page.$el.find(".hide-navbar-on-scroll").length || page.$el.hasClass("hide-navbar-on-scroll") || page.$el.find(".hide-bars-on-scroll").length || page.$el.hasClass("hide-bars-on-scroll")) {
        if (page.$el.find(".keep-navbar-on-scroll").length || page.$el.hasClass("keep-navbar-on-scroll") || page.$el.find(".keep-bars-on-scroll").length || page.$el.hasClass("keep-bars-on-scroll")) {
          needHideOnScrollHandler = false;
        } else {
          needHideOnScrollHandler = true;
        }
      }
      if (needCollapseOnScrollHandler || needHideOnScrollHandler || needTransparentOnScroll) {
        app.navbar.initNavbarOnScroll(page.el, $navbarEl[0], needHideOnScrollHandler, needCollapseOnScrollHandler, needTransparentOnScroll);
      }
    },
    "panelOpen panelSwipeOpen modalOpen": function onPanelModalOpen(instance) {
      var app = this;
      instance.$el.find(".navbar:not(.navbar-previous):not(.stacked)").each(function(navbarEl) {
        app.navbar.size(navbarEl);
      });
    },
    tabShow: function tabShow(tabEl) {
      var app = this;
      dom7_default(tabEl).find(".navbar:not(.navbar-previous):not(.stacked)").each(function(navbarEl) {
        app.navbar.size(navbarEl);
      });
    }
  },
  clicks: {
    ".navbar .title": function onTitleClick($clickedEl) {
      var app = this;
      if (!app.params.navbar.scrollTopOnTitleClick)
        return;
      if ($clickedEl.closest("a").length > 0) {
        return;
      }
      var $pageContentEl;
      var $navbarEl = $clickedEl.parents(".navbar");
      var $navbarsEl = $navbarEl.parents(".navbars");
      $pageContentEl = $navbarEl.parents(".page-content");
      if ($pageContentEl.length === 0) {
        if ($navbarEl.parents(".page").length > 0) {
          $pageContentEl = $navbarEl.parents(".page").find(".page-content");
        }
        if ($pageContentEl.length === 0 && $navbarsEl.length) {
          if ($navbarsEl.nextAll(".page-current:not(.stacked)").length > 0) {
            $pageContentEl = $navbarsEl.nextAll(".page-current:not(.stacked)").find(".page-content");
          }
        }
        if ($pageContentEl.length === 0) {
          if ($navbarEl.nextAll(".page-current:not(.stacked)").length > 0) {
            $pageContentEl = $navbarEl.nextAll(".page-current:not(.stacked)").find(".page-content");
          }
        }
      }
      if ($pageContentEl && $pageContentEl.length > 0) {
        if ($pageContentEl.hasClass("tab")) {
          $pageContentEl = $pageContentEl.parent(".tabs").children(".page-content.tab-active");
        }
        if ($pageContentEl.length > 0)
          $pageContentEl.scrollTop(0, 300);
      }
    }
  },
  vnode: {
    navbar: {
      postpatch: function postpatch(vnode) {
        var app = this;
        app.navbar.size(vnode.elm);
      }
    }
  }
};

// node_modules/framework7/esm/components/statusbar/statusbar.js
var isCapacitor = function isCapacitor2() {
  var window2 = getWindow();
  return window2.Capacitor && window2.Capacitor.isNative && window2.Capacitor.Plugins && window2.Capacitor.Plugins.StatusBar;
};
var Statusbar = {
  hide: function hide3() {
    var window2 = getWindow();
    var device2 = getDevice2();
    if (device2.cordova && window2.StatusBar) {
      window2.StatusBar.hide();
    }
    if (isCapacitor()) {
      window2.Capacitor.Plugins.StatusBar.hide();
    }
  },
  show: function show3() {
    var window2 = getWindow();
    var device2 = getDevice2();
    if (device2.cordova && window2.StatusBar) {
      window2.StatusBar.show();
    }
    if (isCapacitor()) {
      window2.Capacitor.Plugins.StatusBar.show();
    }
  },
  onClick: function onClick2() {
    var app = this;
    var pageContent;
    if (dom7_default(".popup.modal-in").length > 0) {
      pageContent = dom7_default(".popup.modal-in").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content");
    } else if (dom7_default(".panel.panel-in").length > 0) {
      pageContent = dom7_default(".panel.panel-in").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content");
    } else if (dom7_default(".views > .view.tab-active").length > 0) {
      pageContent = dom7_default(".views > .view.tab-active").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content");
    } else if (dom7_default(".views").length > 0) {
      pageContent = dom7_default(".views").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content");
    } else {
      pageContent = app.$el.children(".view").find(".page:not(.page-previous):not(.page-next):not(.cached)").find(".page-content");
    }
    if (pageContent && pageContent.length > 0) {
      if (pageContent.hasClass("tab")) {
        pageContent = pageContent.parent(".tabs").children(".page-content.tab-active");
      }
      if (pageContent.length > 0)
        pageContent.scrollTop(0, 300);
    }
  },
  setTextColor: function setTextColor(color) {
    var window2 = getWindow();
    var device2 = getDevice2();
    if (device2.cordova && window2.StatusBar) {
      if (color === "white") {
        window2.StatusBar.styleLightContent();
      } else {
        window2.StatusBar.styleDefault();
      }
    }
    if (isCapacitor()) {
      if (color === "white") {
        window2.Capacitor.Plugins.StatusBar.setStyle({
          style: "DARK"
        });
      } else {
        window2.Capacitor.Plugins.StatusBar.setStyle({
          style: "LIGHT"
        });
      }
    }
  },
  setBackgroundColor: function setBackgroundColor(color) {
    var window2 = getWindow();
    var device2 = getDevice2();
    if (device2.cordova && window2.StatusBar) {
      window2.StatusBar.backgroundColorByHexString(color);
    }
    if (isCapacitor()) {
      window2.Capacitor.Plugins.StatusBar.setBackgroundColor({
        color
      });
    }
  },
  isVisible: function isVisible() {
    var window2 = getWindow();
    var device2 = getDevice2();
    return new Promise(function(resolve) {
      if (device2.cordova && window2.StatusBar) {
        resolve(window2.StatusBar.isVisible);
      }
      if (isCapacitor()) {
        window2.Capacitor.Plugins.StatusBar.getInfo().then(function(info) {
          resolve(info.visible);
        });
      }
      resolve(false);
    });
  },
  overlaysWebView: function overlaysWebView(overlays) {
    if (overlays === void 0) {
      overlays = true;
    }
    var window2 = getWindow();
    var device2 = getDevice2();
    if (device2.cordova && window2.StatusBar) {
      window2.StatusBar.overlaysWebView(overlays);
    }
    if (isCapacitor()) {
      window2.Capacitor.Plugins.StatusBar.setOverlaysWebView({
        overlay: overlays
      });
    }
  },
  init: function init4() {
    var app = this;
    var window2 = getWindow();
    var device2 = getDevice2();
    var params = app.params.statusbar;
    if (!params.enabled)
      return;
    var isCordova = device2.cordova && window2.StatusBar;
    var isCap = isCapacitor();
    if (isCordova || isCap) {
      if (params.scrollTopOnClick) {
        dom7_default(window2).on("statusTap", Statusbar.onClick.bind(app));
      }
      if (device2.ios) {
        if (params.iosOverlaysWebView) {
          Statusbar.overlaysWebView(true);
        } else {
          Statusbar.overlaysWebView(false);
        }
        if (params.iosTextColor === "white") {
          Statusbar.setTextColor("white");
        } else {
          Statusbar.setTextColor("black");
        }
      }
      if (device2.android) {
        if (params.androidOverlaysWebView) {
          Statusbar.overlaysWebView(true);
        } else {
          Statusbar.overlaysWebView(false);
        }
        if (params.androidTextColor === "white") {
          Statusbar.setTextColor("white");
        } else {
          Statusbar.setTextColor("black");
        }
      }
    }
    if (params.iosBackgroundColor && device2.ios) {
      Statusbar.setBackgroundColor(params.iosBackgroundColor);
    }
    if (params.androidBackgroundColor && device2.android) {
      Statusbar.setBackgroundColor(params.androidBackgroundColor);
    }
  }
};
var statusbar_default = {
  name: "statusbar",
  params: {
    statusbar: {
      enabled: true,
      scrollTopOnClick: true,
      iosOverlaysWebView: true,
      iosTextColor: "black",
      iosBackgroundColor: null,
      androidOverlaysWebView: false,
      androidTextColor: "black",
      androidBackgroundColor: null
    }
  },
  create: function create5() {
    var app = this;
    bindMethods(app, {
      statusbar: Statusbar
    });
  },
  on: {
    init: function init5() {
      var app = this;
      Statusbar.init.call(app);
    }
  }
};

// node_modules/framework7/esm/components/subnavbar/subnavbar.js
var subnavbar_default = {
  name: "subnavbar",
  on: {
    pageInit: function pageInit2(page) {
      if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find(".subnavbar").length) {
        page.$el.addClass("page-with-subnavbar");
      }
      var $innerSubnavbars = page.$el.find(".subnavbar").filter(function(subnavbarEl) {
        return dom7_default(subnavbarEl).parents(".page")[0] === page.$el[0];
      });
      if ($innerSubnavbars.length) {
        page.$el.addClass("page-with-subnavbar");
      }
    }
  }
};

// node_modules/framework7/esm/components/toolbar/toolbar.js
var Toolbar = {
  setHighlight: function setHighlight(tabbarEl) {
    var app = this;
    if (app.theme === "ios")
      return;
    var $tabbarEl = dom7_default(tabbarEl);
    if ($tabbarEl.length === 0 || !($tabbarEl.hasClass("tabbar") || $tabbarEl.hasClass("tabbar-labels")))
      return;
    var $highlightEl = $tabbarEl.find(".tab-link-highlight");
    var tabLinksCount = $tabbarEl.find(".tab-link").length;
    if (tabLinksCount === 0) {
      $highlightEl.remove();
      return;
    }
    if ($highlightEl.length === 0) {
      $tabbarEl.children(".toolbar-inner").append('<span class="tab-link-highlight"></span>');
      $highlightEl = $tabbarEl.find(".tab-link-highlight");
    } else if ($highlightEl.next().length) {
      $tabbarEl.children(".toolbar-inner").append($highlightEl);
    }
    var $activeLink = $tabbarEl.find(".tab-link-active");
    var highlightWidth;
    var highlightTranslate;
    if ($tabbarEl.hasClass("tabbar-scrollable") && $activeLink && $activeLink[0]) {
      highlightWidth = $activeLink[0].offsetWidth + "px";
      highlightTranslate = $activeLink[0].offsetLeft + "px";
    } else {
      var activeIndex = $activeLink.index();
      highlightWidth = 100 / tabLinksCount + "%";
      highlightTranslate = (app.rtl ? -activeIndex : activeIndex) * 100 + "%";
    }
    nextFrame(function() {
      $highlightEl.css("width", highlightWidth).transform("translate3d(" + highlightTranslate + ",0,0)");
    });
  },
  init: function init6(tabbarEl) {
    var app = this;
    app.toolbar.setHighlight(tabbarEl);
  },
  hide: function hide4(el, animate2) {
    if (animate2 === void 0) {
      animate2 = true;
    }
    var app = this;
    var $el = dom7_default(el);
    if ($el.hasClass("toolbar-hidden"))
      return;
    var className = "toolbar-hidden" + (animate2 ? " toolbar-transitioning" : "");
    $el.transitionEnd(function() {
      $el.removeClass("toolbar-transitioning");
    });
    $el.addClass(className);
    $el.trigger("toolbar:hide");
    app.emit("toolbarHide", $el[0]);
  },
  show: function show4(el, animate2) {
    if (animate2 === void 0) {
      animate2 = true;
    }
    var app = this;
    var $el = dom7_default(el);
    if (!$el.hasClass("toolbar-hidden"))
      return;
    if (animate2) {
      $el.addClass("toolbar-transitioning");
      $el.transitionEnd(function() {
        $el.removeClass("toolbar-transitioning");
      });
    }
    $el.removeClass("toolbar-hidden");
    $el.trigger("toolbar:show");
    app.emit("toolbarShow", $el[0]);
  },
  initToolbarOnScroll: function initToolbarOnScroll(pageEl) {
    var app = this;
    var $pageEl = dom7_default(pageEl);
    var $toolbarEl = $pageEl.parents(".view").children(".toolbar");
    if ($toolbarEl.length === 0) {
      $toolbarEl = $pageEl.find(".toolbar");
    }
    if ($toolbarEl.length === 0) {
      $toolbarEl = $pageEl.parents(".views").children(".tabbar, .tabbar-labels");
    }
    if ($toolbarEl.length === 0) {
      return;
    }
    var previousScrollTop;
    var currentScrollTop;
    var scrollHeight;
    var offsetHeight;
    var reachEnd;
    var action;
    var toolbarHidden;
    function handleScroll(e) {
      if ($pageEl.hasClass("page-with-card-opened"))
        return;
      if ($pageEl.hasClass("page-previous"))
        return;
      var scrollContent = this;
      if (e && e.target && e.target !== scrollContent) {
        return;
      }
      currentScrollTop = scrollContent.scrollTop;
      scrollHeight = scrollContent.scrollHeight;
      offsetHeight = scrollContent.offsetHeight;
      reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
      toolbarHidden = $toolbarEl.hasClass("toolbar-hidden");
      if (reachEnd) {
        if (app.params.toolbar.showOnPageScrollEnd) {
          action = "show";
        }
      } else if (previousScrollTop > currentScrollTop) {
        if (app.params.toolbar.showOnPageScrollTop || currentScrollTop <= 44) {
          action = "show";
        } else {
          action = "hide";
        }
      } else if (currentScrollTop > 44) {
        action = "hide";
      } else {
        action = "show";
      }
      if (action === "show" && toolbarHidden) {
        app.toolbar.show($toolbarEl);
        toolbarHidden = false;
      } else if (action === "hide" && !toolbarHidden) {
        app.toolbar.hide($toolbarEl);
        toolbarHidden = true;
      }
      previousScrollTop = currentScrollTop;
    }
    $pageEl.on("scroll", ".page-content", handleScroll, true);
    $pageEl[0].f7ScrollToolbarHandler = handleScroll;
  }
};
var toolbar_default = {
  name: "toolbar",
  create: function create6() {
    var app = this;
    bindMethods(app, {
      toolbar: Toolbar
    });
  },
  params: {
    toolbar: {
      hideOnPageScroll: false,
      showOnPageScrollEnd: true,
      showOnPageScrollTop: true
    }
  },
  on: {
    pageBeforeRemove: function pageBeforeRemove2(page) {
      if (page.$el[0].f7ScrollToolbarHandler) {
        page.$el.off("scroll", ".page-content", page.$el[0].f7ScrollToolbarHandler, true);
      }
    },
    pageBeforeIn: function pageBeforeIn2(page) {
      var app = this;
      var $toolbarEl = page.$el.parents(".view").children(".toolbar");
      if ($toolbarEl.length === 0) {
        $toolbarEl = page.$el.parents(".views").children(".tabbar, .tabbar-labels");
      }
      if ($toolbarEl.length === 0) {
        $toolbarEl = page.$el.find(".toolbar");
      }
      if ($toolbarEl.length === 0) {
        return;
      }
      if (page.$el.hasClass("no-toolbar")) {
        app.toolbar.hide($toolbarEl);
      } else {
        app.toolbar.show($toolbarEl);
      }
    },
    pageInit: function pageInit3(page) {
      var app = this;
      page.$el.find(".tabbar, .tabbar-labels").each(function(tabbarEl) {
        app.toolbar.init(tabbarEl);
      });
      if (app.params.toolbar.hideOnPageScroll || page.$el.find(".hide-toolbar-on-scroll").length || page.$el.hasClass("hide-toolbar-on-scroll") || page.$el.find(".hide-bars-on-scroll").length || page.$el.hasClass("hide-bars-on-scroll")) {
        if (page.$el.find(".keep-toolbar-on-scroll").length || page.$el.hasClass("keep-toolbar-on-scroll") || page.$el.find(".keep-bars-on-scroll").length || page.$el.hasClass("keep-bars-on-scroll")) {
          return;
        }
        app.toolbar.initToolbarOnScroll(page.el);
      }
    },
    init: function init7() {
      var app = this;
      app.$el.find(".tabbar, .tabbar-labels").each(function(tabbarEl) {
        app.toolbar.init(tabbarEl);
      });
    }
  },
  vnode: {
    tabbar: {
      insert: function insert(vnode) {
        var app = this;
        app.toolbar.init(vnode.elm);
      }
    }
  }
};

// node_modules/framework7/esm/components/touch-ripple/touch-ripple-class.js
var TouchRipple = function() {
  function TouchRipple2(app, $el, x, y) {
    var ripple = this;
    if (!$el)
      return void 0;
    var _$el$0$getBoundingCli = $el[0].getBoundingClientRect(), left = _$el$0$getBoundingCli.left, top = _$el$0$getBoundingCli.top, width2 = _$el$0$getBoundingCli.width, height2 = _$el$0$getBoundingCli.height;
    var center = {
      x: x - left,
      y: y - top
    };
    var diameter = Math.max(Math.pow(Math.pow(height2, 2) + Math.pow(width2, 2), 0.5), 48);
    var isInset = false;
    var insetElements = app.params.touch.touchRippleInsetElements || "";
    if (insetElements && $el.is(insetElements)) {
      isInset = true;
    }
    if (isInset) {
      diameter = Math.max(Math.min(width2, height2), 48);
    }
    if (!isInset && $el.css("overflow") === "hidden") {
      var distanceFromCenter = Math.pow(Math.pow(center.x - width2 / 2, 2) + Math.pow(center.y - height2 / 2, 2), 0.5);
      var scale = (diameter / 2 + distanceFromCenter) / (diameter / 2);
      ripple.rippleTransform = "translate3d(0px, 0px, 0) scale(" + scale + ")";
    } else {
      ripple.rippleTransform = "translate3d(" + (-center.x + width2 / 2) + "px, " + (-center.y + height2 / 2) + "px, 0) scale(1)";
    }
    if (isInset) {
      $el.addClass("ripple-inset");
    }
    ripple.$rippleWaveEl = dom7_default('<div class="ripple-wave" style="width: ' + diameter + "px; height: " + diameter + "px; margin-top:-" + diameter / 2 + "px; margin-left:-" + diameter / 2 + "px; left:" + center.x + "px; top:" + center.y + "px; --f7-ripple-transform: " + ripple.rippleTransform + '"></div>');
    $el.prepend(ripple.$rippleWaveEl);
    ripple.$rippleWaveEl.animationEnd(function() {
      if (!ripple.$rippleWaveEl)
        return;
      if (ripple.$rippleWaveEl.hasClass("ripple-wave-out"))
        return;
      ripple.$rippleWaveEl.addClass("ripple-wave-in");
      if (ripple.shouldBeRemoved) {
        ripple.out();
      }
    });
    return ripple;
  }
  var _proto = TouchRipple2.prototype;
  _proto.destroy = function destroy5() {
    var ripple = this;
    if (ripple.$rippleWaveEl) {
      ripple.$rippleWaveEl.remove();
    }
    Object.keys(ripple).forEach(function(key) {
      ripple[key] = null;
      delete ripple[key];
    });
    ripple = null;
  };
  _proto.out = function out() {
    var ripple = this;
    var $rippleWaveEl = this.$rippleWaveEl;
    clearTimeout(ripple.removeTimeout);
    $rippleWaveEl.addClass("ripple-wave-out");
    ripple.removeTimeout = setTimeout(function() {
      ripple.destroy();
    }, 300);
    $rippleWaveEl.animationEnd(function() {
      clearTimeout(ripple.removeTimeout);
      ripple.destroy();
    });
  };
  _proto.remove = function remove2() {
    var ripple = this;
    if (ripple.shouldBeRemoved)
      return;
    ripple.removeTimeout = setTimeout(function() {
      ripple.destroy();
    }, 400);
    ripple.shouldBeRemoved = true;
    if (ripple.$rippleWaveEl.hasClass("ripple-wave-in")) {
      ripple.out();
    }
  };
  return TouchRipple2;
}();

// node_modules/framework7/esm/components/touch-ripple/touch-ripple.js
function _construct3(Parent, args, Class) {
  if (_isNativeReflectConstruct3()) {
    _construct3 = Reflect.construct;
  } else {
    _construct3 = function _construct5(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf3(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct3.apply(null, arguments);
}
function _isNativeReflectConstruct3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _setPrototypeOf3(o, p) {
  _setPrototypeOf3 = Object.setPrototypeOf || function _setPrototypeOf5(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf3(o, p);
}
var touch_ripple_default = {
  name: "touch-ripple",
  static: {
    TouchRipple
  },
  create: function create7() {
    var app = this;
    app.touchRipple = {
      create: function create13() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _construct3(TouchRipple, args);
      }
    };
  }
};

// node_modules/path-to-regexp/dist.es2015/index.js
function lexer(str) {
  var tokens = [];
  var i = 0;
  while (i < str.length) {
    var char = str[i];
    if (char === "*" || char === "+" || char === "?") {
      tokens.push({type: "MODIFIER", index: i, value: str[i++]});
      continue;
    }
    if (char === "\\") {
      tokens.push({type: "ESCAPED_CHAR", index: i++, value: str[i++]});
      continue;
    }
    if (char === "{") {
      tokens.push({type: "OPEN", index: i, value: str[i++]});
      continue;
    }
    if (char === "}") {
      tokens.push({type: "CLOSE", index: i, value: str[i++]});
      continue;
    }
    if (char === ":") {
      var name = "";
      var j = i + 1;
      while (j < str.length) {
        var code = str.charCodeAt(j);
        if (code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || code === 95) {
          name += str[j++];
          continue;
        }
        break;
      }
      if (!name)
        throw new TypeError("Missing parameter name at " + i);
      tokens.push({type: "NAME", index: i, value: name});
      i = j;
      continue;
    }
    if (char === "(") {
      var count = 1;
      var pattern = "";
      var j = i + 1;
      if (str[j] === "?") {
        throw new TypeError('Pattern cannot start with "?" at ' + j);
      }
      while (j < str.length) {
        if (str[j] === "\\") {
          pattern += str[j++] + str[j++];
          continue;
        }
        if (str[j] === ")") {
          count--;
          if (count === 0) {
            j++;
            break;
          }
        } else if (str[j] === "(") {
          count++;
          if (str[j + 1] !== "?") {
            throw new TypeError("Capturing groups are not allowed at " + j);
          }
        }
        pattern += str[j++];
      }
      if (count)
        throw new TypeError("Unbalanced pattern at " + i);
      if (!pattern)
        throw new TypeError("Missing pattern at " + i);
      tokens.push({type: "PATTERN", index: i, value: pattern});
      i = j;
      continue;
    }
    tokens.push({type: "CHAR", index: i, value: str[i++]});
  }
  tokens.push({type: "END", index: i, value: ""});
  return tokens;
}
function parse(str, options) {
  if (options === void 0) {
    options = {};
  }
  var tokens = lexer(str);
  var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
  var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
  var result = [];
  var key = 0;
  var i = 0;
  var path = "";
  var tryConsume = function(type) {
    if (i < tokens.length && tokens[i].type === type)
      return tokens[i++].value;
  };
  var mustConsume = function(type) {
    var value3 = tryConsume(type);
    if (value3 !== void 0)
      return value3;
    var _a2 = tokens[i], nextType = _a2.type, index2 = _a2.index;
    throw new TypeError("Unexpected " + nextType + " at " + index2 + ", expected " + type);
  };
  var consumeText = function() {
    var result2 = "";
    var value3;
    while (value3 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
      result2 += value3;
    }
    return result2;
  };
  while (i < tokens.length) {
    var char = tryConsume("CHAR");
    var name = tryConsume("NAME");
    var pattern = tryConsume("PATTERN");
    if (name || pattern) {
      var prefix = char || "";
      if (prefixes.indexOf(prefix) === -1) {
        path += prefix;
        prefix = "";
      }
      if (path) {
        result.push(path);
        path = "";
      }
      result.push({
        name: name || key++,
        prefix,
        suffix: "",
        pattern: pattern || defaultPattern,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    var value2 = char || tryConsume("ESCAPED_CHAR");
    if (value2) {
      path += value2;
      continue;
    }
    if (path) {
      result.push(path);
      path = "";
    }
    var open = tryConsume("OPEN");
    if (open) {
      var prefix = consumeText();
      var name_1 = tryConsume("NAME") || "";
      var pattern_1 = tryConsume("PATTERN") || "";
      var suffix = consumeText();
      mustConsume("CLOSE");
      result.push({
        name: name_1 || (pattern_1 ? key++ : ""),
        pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
        prefix,
        suffix,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    mustConsume("END");
  }
  return result;
}
function compile(str, options) {
  return tokensToFunction(parse(str, options), options);
}
function tokensToFunction(tokens, options) {
  if (options === void 0) {
    options = {};
  }
  var reFlags = flags(options);
  var _a = options.encode, encode = _a === void 0 ? function(x) {
    return x;
  } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
  var matches = tokens.map(function(token) {
    if (typeof token === "object") {
      return new RegExp("^(?:" + token.pattern + ")$", reFlags);
    }
  });
  return function(data2) {
    var path = "";
    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];
      if (typeof token === "string") {
        path += token;
        continue;
      }
      var value2 = data2 ? data2[token.name] : void 0;
      var optional = token.modifier === "?" || token.modifier === "*";
      var repeat = token.modifier === "*" || token.modifier === "+";
      if (Array.isArray(value2)) {
        if (!repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but got an array');
        }
        if (value2.length === 0) {
          if (optional)
            continue;
          throw new TypeError('Expected "' + token.name + '" to not be empty');
        }
        for (var j = 0; j < value2.length; j++) {
          var segment = encode(value2[j], token);
          if (validate && !matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"');
          }
          path += token.prefix + segment + token.suffix;
        }
        continue;
      }
      if (typeof value2 === "string" || typeof value2 === "number") {
        var segment = encode(String(value2), token);
        if (validate && !matches[i].test(segment)) {
          throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"');
        }
        path += token.prefix + segment + token.suffix;
        continue;
      }
      if (optional)
        continue;
      var typeOfMessage = repeat ? "an array" : "a string";
      throw new TypeError('Expected "' + token.name + '" to be ' + typeOfMessage);
    }
    return path;
  };
}
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
function regexpToRegexp(path, keys) {
  if (!keys)
    return path;
  var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
  var index2 = 0;
  var execResult = groupsRegex.exec(path.source);
  while (execResult) {
    keys.push({
      name: execResult[1] || index2++,
      prefix: "",
      suffix: "",
      modifier: "",
      pattern: ""
    });
    execResult = groupsRegex.exec(path.source);
  }
  return path;
}
function arrayToRegexp(paths, keys, options) {
  var parts = paths.map(function(path) {
    return pathToRegexp(path, keys, options).source;
  });
  return new RegExp("(?:" + parts.join("|") + ")", flags(options));
}
function stringToRegexp(path, keys, options) {
  return tokensToRegexp(parse(path, options), keys, options);
}
function tokensToRegexp(tokens, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function(x) {
    return x;
  } : _d;
  var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
  var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
  var route = start ? "^" : "";
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    if (typeof token === "string") {
      route += escapeString(encode(token));
    } else {
      var prefix = escapeString(encode(token.prefix));
      var suffix = escapeString(encode(token.suffix));
      if (token.pattern) {
        if (keys)
          keys.push(token);
        if (prefix || suffix) {
          if (token.modifier === "+" || token.modifier === "*") {
            var mod = token.modifier === "*" ? "?" : "";
            route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
          } else {
            route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
          }
        } else {
          route += "(" + token.pattern + ")" + token.modifier;
        }
      } else {
        route += "(?:" + prefix + suffix + ")" + token.modifier;
      }
    }
  }
  if (end) {
    if (!strict)
      route += delimiter + "?";
    route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
  } else {
    var endToken = tokens[tokens.length - 1];
    var isEndDelimited = typeof endToken === "string" ? delimiter.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;
    if (!strict) {
      route += "(?:" + delimiter + "(?=" + endsWith + "))?";
    }
    if (!isEndDelimited) {
      route += "(?=" + delimiter + "|" + endsWith + ")";
    }
  }
  return new RegExp(route, flags(options));
}
function pathToRegexp(path, keys, options) {
  if (path instanceof RegExp)
    return regexpToRegexp(path, keys);
  if (Array.isArray(path))
    return arrayToRegexp(path, keys, options);
  return stringToRegexp(path, keys, options);
}

// node_modules/framework7/esm/shared/history.js
var History = {
  queue: [],
  clearQueue: function clearQueue() {
    if (History.queue.length === 0)
      return;
    var currentQueue = History.queue.shift();
    currentQueue();
  },
  routerQueue: [],
  clearRouterQueue: function clearRouterQueue() {
    if (History.routerQueue.length === 0)
      return;
    var currentQueue = History.routerQueue.pop();
    var router = currentQueue.router, stateUrl = currentQueue.stateUrl, action = currentQueue.action;
    var animate2 = router.params.animate;
    if (router.params.browserHistoryAnimate === false)
      animate2 = false;
    if (action === "back") {
      router.back({
        animate: animate2,
        browserHistory: false
      });
    }
    if (action === "load") {
      router.navigate(stateUrl, {
        animate: animate2,
        browserHistory: false
      });
    }
  },
  handle: function handle(e) {
    if (History.blockPopstate)
      return;
    var app = this;
    var state = e.state;
    History.previousState = History.state;
    History.state = state;
    History.allowChange = true;
    History.clearQueue();
    state = History.state;
    if (!state)
      state = {};
    app.views.forEach(function(view) {
      var router = view.router;
      var viewState = state[view.id];
      if (!viewState && view.params.browserHistory) {
        viewState = {
          url: view.router.history[0]
        };
      }
      if (!viewState)
        return;
      var stateUrl = viewState.url || void 0;
      var animate2 = router.params.animate;
      if (router.params.browserHistoryAnimate === false)
        animate2 = false;
      if (stateUrl !== router.url) {
        if (router.history.indexOf(stateUrl) >= 0) {
          if (router.allowPageChange) {
            router.back({
              animate: animate2,
              browserHistory: false
            });
          } else {
            History.routerQueue.push({
              action: "back",
              router
            });
          }
        } else if (router.allowPageChange) {
          router.navigate(stateUrl, {
            animate: animate2,
            browserHistory: false
          });
        } else {
          History.routerQueue.unshift({
            action: "load",
            stateUrl,
            router
          });
        }
      }
    });
  },
  initViewState: function initViewState(viewId, viewState) {
    var _extend;
    var window2 = getWindow();
    var newState = extend3({}, History.state || {}, (_extend = {}, _extend[viewId] = viewState, _extend));
    History.state = newState;
    window2.history.replaceState(newState, "");
  },
  push: function push(viewId, viewState, url) {
    var _extend2;
    var window2 = getWindow();
    if (url.substr(-3) === "#!/") {
      url = url.replace("#!/", "");
    }
    if (!History.allowChange) {
      History.queue.push(function() {
        History.push(viewId, viewState, url);
      });
      return;
    }
    History.previousState = History.state;
    var newState = extend3({}, History.previousState || {}, (_extend2 = {}, _extend2[viewId] = viewState, _extend2));
    History.state = newState;
    window2.history.pushState(newState, "", url);
  },
  replace: function replace(viewId, viewState, url) {
    var _extend3;
    var window2 = getWindow();
    if (url.substr(-3) === "#!/") {
      url = url.replace("#!/", "");
    }
    if (!History.allowChange) {
      History.queue.push(function() {
        History.replace(viewId, viewState, url);
      });
      return;
    }
    History.previousState = History.state;
    var newState = extend3({}, History.previousState || {}, (_extend3 = {}, _extend3[viewId] = viewState, _extend3));
    History.state = newState;
    window2.history.replaceState(newState, "", url);
  },
  go: function go(index2) {
    var window2 = getWindow();
    History.allowChange = false;
    window2.history.go(index2);
  },
  back: function back() {
    var window2 = getWindow();
    History.allowChange = false;
    window2.history.back();
  },
  allowChange: true,
  previousState: {},
  state: {},
  blockPopstate: true,
  init: function init8(app) {
    var window2 = getWindow();
    var document2 = getDocument();
    History.state = window2.history.state;
    dom7_default(window2).on("load", function() {
      setTimeout(function() {
        History.blockPopstate = false;
      }, 0);
    });
    if (document2.readyState && document2.readyState === "complete") {
      History.blockPopstate = false;
    }
    dom7_default(window2).on("popstate", History.handle.bind(app));
  }
};
var history_default = History;

// node_modules/framework7/esm/modules/router/swipe-back.js
function SwipeBack(r) {
  var router = r;
  var $el = router.$el, $navbarsEl = router.$navbarsEl, app = router.app, params = router.params;
  var support3 = getSupport2();
  var device2 = getDevice2();
  var isTouched = false;
  var isMoved = false;
  var touchesStart = {};
  var isScrolling;
  var $currentPageEl = [];
  var $previousPageEl = [];
  var viewContainerWidth;
  var touchesDiff;
  var allowViewTouchMove = true;
  var touchStartTime;
  var $currentNavbarEl = [];
  var $previousNavbarEl = [];
  var dynamicNavbar;
  var $pageShadowEl;
  var $pageOpacityEl;
  var animatableNavEls;
  var paramsSwipeBackAnimateShadow = params[app.theme + "SwipeBackAnimateShadow"];
  var paramsSwipeBackAnimateOpacity = params[app.theme + "SwipeBackAnimateOpacity"];
  var paramsSwipeBackActiveArea = params[app.theme + "SwipeBackActiveArea"];
  var paramsSwipeBackThreshold = params[app.theme + "SwipeBackThreshold"];
  var transformOrigin = app.rtl ? "right center" : "left center";
  var transformOriginTitleLarge = app.rtl ? "calc(100% - var(--f7-navbar-large-title-padding-left) - var(--f7-safe-area-left)) center" : "calc(var(--f7-navbar-large-title-padding-left) + var(--f7-safe-area-left)) center";
  function animatableNavElements() {
    var els = [];
    var inverter = app.rtl ? -1 : 1;
    var currentNavIsTransparent = $currentNavbarEl.hasClass("navbar-transparent") && !$currentNavbarEl.hasClass("navbar-large") && !$currentNavbarEl.hasClass("navbar-transparent-visible");
    var currentNavIsLarge = $currentNavbarEl.hasClass("navbar-large");
    var currentNavIsCollapsed = $currentNavbarEl.hasClass("navbar-large-collapsed");
    var currentNavIsLargeTransparent = $currentNavbarEl.hasClass("navbar-large-transparent") || $currentNavbarEl.hasClass("navbar-large") && $currentNavbarEl.hasClass("navbar-transparent");
    var previousNavIsTransparent = $previousNavbarEl.hasClass("navbar-transparent") && !$previousNavbarEl.hasClass("navbar-large") && !$previousNavbarEl.hasClass("navbar-transparent-visible");
    var previousNavIsLarge = $previousNavbarEl.hasClass("navbar-large");
    var previousNavIsCollapsed = $previousNavbarEl.hasClass("navbar-large-collapsed");
    var previousNavIsLargeTransparent = $previousNavbarEl.hasClass("navbar-large-transparent") || $previousNavbarEl.hasClass("navbar-large") && $previousNavbarEl.hasClass("navbar-transparent");
    var fromLarge = currentNavIsLarge && !currentNavIsCollapsed;
    var toLarge = previousNavIsLarge && !previousNavIsCollapsed;
    var $currentNavElements = $currentNavbarEl.find(".left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg");
    var $previousNavElements = $previousNavbarEl.find(".left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg");
    var activeNavBackIconText;
    var previousNavBackIconText;
    if (params.iosAnimateNavbarBackIcon) {
      if ($currentNavbarEl.hasClass("sliding") || $currentNavbarEl.find(".navbar-inner.sliding").length) {
        activeNavBackIconText = $currentNavbarEl.find(".left").find(".back .icon + span").eq(0);
      } else {
        activeNavBackIconText = $currentNavbarEl.find(".left.sliding").find(".back .icon + span").eq(0);
      }
      if ($previousNavbarEl.hasClass("sliding") || $previousNavbarEl.find(".navbar-inner.sliding").length) {
        previousNavBackIconText = $previousNavbarEl.find(".left").find(".back .icon + span").eq(0);
      } else {
        previousNavBackIconText = $previousNavbarEl.find(".left.sliding").find(".back .icon + span").eq(0);
      }
      if (activeNavBackIconText.length) {
        $previousNavElements.each(function(el) {
          if (!dom7_default(el).hasClass("title"))
            return;
          el.f7NavbarLeftOffset += activeNavBackIconText.prev(".icon")[0].offsetWidth;
        });
      }
    }
    $currentNavElements.each(function(navEl) {
      var $navEl = dom7_default(navEl);
      var isSubnavbar = $navEl.hasClass("subnavbar");
      var isLeft = $navEl.hasClass("left");
      var isTitle = $navEl.hasClass("title");
      var isBg = $navEl.hasClass("navbar-bg");
      if ((isTitle || isBg) && currentNavIsTransparent)
        return;
      if (!fromLarge && $navEl.hasClass(".title-large"))
        return;
      var el = {
        el: navEl
      };
      if (fromLarge) {
        if (isTitle)
          return;
        if ($navEl.hasClass("title-large")) {
          if (els.indexOf(el) < 0)
            els.push(el);
          el.overflow = "visible";
          $navEl.find(".title-large-text").each(function(subNavEl) {
            els.push({
              el: subNavEl,
              transform: function transform2(progress) {
                return "translateX(" + progress * 100 * inverter + "%)";
              }
            });
          });
          return;
        }
      }
      if (toLarge) {
        if (!fromLarge) {
          if ($navEl.hasClass("title-large")) {
            if (els.indexOf(el) < 0)
              els.push(el);
            el.opacity = 0;
          }
        }
        if (isLeft) {
          if (els.indexOf(el) < 0)
            els.push(el);
          el.opacity = function(progress) {
            return 1 - Math.pow(progress, 0.33);
          };
          $navEl.find(".back span").each(function(subNavEl) {
            els.push({
              el: subNavEl,
              "transform-origin": transformOrigin,
              transform: function transform2(progress) {
                return "translateX(calc(" + progress + " * (var(--f7-navbarTitleLargeOffset) - var(--f7-navbarLeftTextOffset)))) translateY(calc(" + progress + " * (var(--f7-navbar-large-title-height) - var(--f7-navbar-large-title-padding-vertical) / 2))) scale(" + (1 + 1 * progress) + ")";
              }
            });
          });
          return;
        }
      }
      if (isBg) {
        if (els.indexOf(el) < 0)
          els.push(el);
        if (!fromLarge && !toLarge) {
          if (currentNavIsCollapsed) {
            if (currentNavIsLargeTransparent) {
              el.className = "ios-swipeback-navbar-bg-large";
            }
            el.transform = function(progress) {
              return "translateX(" + 100 * progress * inverter + "%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))";
            };
          } else {
            el.transform = function(progress) {
              return "translateX(" + 100 * progress * inverter + "%)";
            };
          }
        }
        if (!fromLarge && toLarge) {
          el.className = "ios-swipeback-navbar-bg-large";
          el.transform = function(progress) {
            return "translateX(" + 100 * progress * inverter + "%) translateY(calc(-1 * " + (1 - progress) + " * var(--f7-navbar-large-title-height)))";
          };
        }
        if (fromLarge && toLarge) {
          el.transform = function(progress) {
            return "translateX(" + 100 * progress * inverter + "%)";
          };
        }
        if (fromLarge && !toLarge) {
          el.transform = function(progress) {
            return "translateX(" + 100 * progress * inverter + "%) translateY(calc(-" + progress + " * var(--f7-navbar-large-title-height)))";
          };
        }
        return;
      }
      if ($navEl.hasClass("title-large"))
        return;
      var isSliding = $navEl.hasClass("sliding") || $navEl.parents(".navbar-inner.sliding").length;
      if (els.indexOf(el) < 0)
        els.push(el);
      if (!isSubnavbar || isSubnavbar && !isSliding) {
        el.opacity = function(progress) {
          return 1 - Math.pow(progress, 0.33);
        };
      }
      if (isSliding) {
        var transformTarget = el;
        if (isLeft && activeNavBackIconText.length && params.iosAnimateNavbarBackIcon) {
          var textEl = {
            el: activeNavBackIconText[0]
          };
          transformTarget = textEl;
          els.push(textEl);
        }
        transformTarget.transform = function(progress) {
          var activeNavTranslate = progress * transformTarget.el.f7NavbarRightOffset;
          if (device2.pixelRatio === 1)
            activeNavTranslate = Math.round(activeNavTranslate);
          if (isSubnavbar && currentNavIsLarge) {
            return "translate3d(" + activeNavTranslate + "px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)";
          }
          return "translate3d(" + activeNavTranslate + "px,0,0)";
        };
      }
    });
    $previousNavElements.each(function(navEl) {
      var $navEl = dom7_default(navEl);
      var isSubnavbar = $navEl.hasClass("subnavbar");
      var isLeft = $navEl.hasClass("left");
      var isTitle = $navEl.hasClass("title");
      var isBg = $navEl.hasClass("navbar-bg");
      if ((isTitle || isBg) && previousNavIsTransparent)
        return;
      var el = {
        el: navEl
      };
      if (toLarge) {
        if (isTitle)
          return;
        if (els.indexOf(el) < 0)
          els.push(el);
        if ($navEl.hasClass("title-large")) {
          el.opacity = 1;
          el.overflow = "visible";
          $navEl.find(".title-large-text").each(function(subNavEl) {
            els.push({
              el: subNavEl,
              "transform-origin": transformOriginTitleLarge,
              opacity: function opacity(progress) {
                return Math.pow(progress, 3);
              },
              transform: function transform2(progress) {
                return "translateX(calc(" + (1 - progress) + " * (var(--f7-navbarLeftTextOffset) - var(--f7-navbarTitleLargeOffset)))) translateY(calc(" + (progress - 1) + " * var(--f7-navbar-large-title-height) + " + (1 - progress) + " * var(--f7-navbar-large-title-padding-vertical))) scale(" + (0.5 + progress * 0.5) + ")";
              }
            });
          });
          return;
        }
      }
      if (isBg) {
        if (els.indexOf(el) < 0)
          els.push(el);
        if (!fromLarge && !toLarge) {
          if (previousNavIsCollapsed) {
            if (previousNavIsLargeTransparent) {
              el.className = "ios-swipeback-navbar-bg-large";
            }
            el.transform = function(progress) {
              return "translateX(" + (-100 + 100 * progress) * inverter + "%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))";
            };
          } else {
            el.transform = function(progress) {
              return "translateX(" + (-100 + 100 * progress) * inverter + "%)";
            };
          }
        }
        if (!fromLarge && toLarge) {
          el.transform = function(progress) {
            return "translateX(" + (-100 + 100 * progress) * inverter + "%) translateY(calc(-1 * " + (1 - progress) + " * var(--f7-navbar-large-title-height)))";
          };
        }
        if (fromLarge && !toLarge) {
          el.className = "ios-swipeback-navbar-bg-large";
          el.transform = function(progress) {
            return "translateX(" + (-100 + 100 * progress) * inverter + "%) translateY(calc(-" + progress + " * var(--f7-navbar-large-title-height)))";
          };
        }
        if (fromLarge && toLarge) {
          el.transform = function(progress) {
            return "translateX(" + (-100 + 100 * progress) * inverter + "%)";
          };
        }
        return;
      }
      if ($navEl.hasClass("title-large"))
        return;
      var isSliding = $navEl.hasClass("sliding") || $previousNavbarEl.children(".navbar-inner.sliding").length;
      if (els.indexOf(el) < 0)
        els.push(el);
      if (!isSubnavbar || isSubnavbar && !isSliding) {
        el.opacity = function(progress) {
          return Math.pow(progress, 3);
        };
      }
      if (isSliding) {
        var transformTarget = el;
        if (isLeft && previousNavBackIconText.length && params.iosAnimateNavbarBackIcon) {
          var textEl = {
            el: previousNavBackIconText[0]
          };
          transformTarget = textEl;
          els.push(textEl);
        }
        transformTarget.transform = function(progress) {
          var previousNavTranslate = transformTarget.el.f7NavbarLeftOffset * (1 - progress);
          if (device2.pixelRatio === 1)
            previousNavTranslate = Math.round(previousNavTranslate);
          if (isSubnavbar && previousNavIsLarge) {
            return "translate3d(" + previousNavTranslate + "px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)";
          }
          return "translate3d(" + previousNavTranslate + "px,0,0)";
        };
      }
    });
    return els;
  }
  function setAnimatableNavElements(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, progress = _ref.progress, reset = _ref.reset, transition2 = _ref.transition, reflow = _ref.reflow;
    var styles2 = ["overflow", "transform", "transform-origin", "opacity"];
    if (transition2 === true || transition2 === false) {
      for (var i = 0; i < animatableNavEls.length; i += 1) {
        var el = animatableNavEls[i];
        if (el && el.el) {
          if (transition2 === true)
            el.el.classList.add("navbar-page-transitioning");
          if (transition2 === false)
            el.el.classList.remove("navbar-page-transitioning");
        }
      }
    }
    if (reflow && animatableNavEls.length && animatableNavEls[0] && animatableNavEls[0].el) {
      animatableNavEls[0].el._clientLeft = animatableNavEls[0].el.clientLeft;
    }
    for (var _i = 0; _i < animatableNavEls.length; _i += 1) {
      var _el = animatableNavEls[_i];
      if (_el && _el.el) {
        if (_el.className && !_el.classNameSet && !reset) {
          _el.el.classList.add(_el.className);
          _el.classNameSet = true;
        }
        if (_el.className && reset) {
          _el.el.classList.remove(_el.className);
        }
        for (var j = 0; j < styles2.length; j += 1) {
          var styleProp = styles2[j];
          if (_el[styleProp]) {
            if (reset) {
              _el.el.style[styleProp] = "";
            } else if (typeof _el[styleProp] === "function") {
              _el.el.style[styleProp] = _el[styleProp](progress);
            } else {
              _el.el.style[styleProp] = _el[styleProp];
            }
          }
        }
      }
    }
  }
  function handleTouchStart(e) {
    var swipeBackEnabled = params[app.theme + "SwipeBack"];
    if (!allowViewTouchMove || !swipeBackEnabled || isTouched || app.swipeout && app.swipeout.el || !router.allowPageChange)
      return;
    if (dom7_default(e.target).closest(".range-slider, .calendar-months").length > 0)
      return;
    if (dom7_default(e.target).closest(".page-master, .page-master-detail").length > 0 && params.masterDetailBreakpoint > 0 && app.width >= params.masterDetailBreakpoint)
      return;
    isMoved = false;
    isTouched = true;
    isScrolling = void 0;
    touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    touchStartTime = now2();
    dynamicNavbar = router.dynamicNavbar;
  }
  function handleTouchMove(e) {
    if (!isTouched)
      return;
    var pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
    var pageY = e.type === "touchmove" ? e.targetTouches[0].pageY : e.pageY;
    if (typeof isScrolling === "undefined") {
      isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x)) || pageX < touchesStart.x && !app.rtl || pageX > touchesStart.x && app.rtl;
    }
    if (isScrolling || e.f7PreventSwipeBack || app.preventSwipeBack) {
      isTouched = false;
      return;
    }
    if (!isMoved) {
      var cancel = false;
      var target = dom7_default(e.target);
      var swipeout = target.closest(".swipeout");
      if (swipeout.length > 0) {
        if (!app.rtl && swipeout.find(".swipeout-actions-left").length > 0)
          cancel = true;
        if (app.rtl && swipeout.find(".swipeout-actions-right").length > 0)
          cancel = true;
      }
      $currentPageEl = target.closest(".page");
      if ($currentPageEl.hasClass("no-swipeback") || target.closest(".no-swipeback, .card-opened").length > 0)
        cancel = true;
      $previousPageEl = $el.find(".page-previous:not(.stacked)");
      if ($previousPageEl.length > 1) {
        $previousPageEl = $previousPageEl.eq($previousPageEl.length - 1);
      }
      var notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
      viewContainerWidth = $el.width();
      if (app.rtl) {
        notFromBorder = touchesStart.x < $el.offset().left - $el[0].scrollLeft + (viewContainerWidth - paramsSwipeBackActiveArea);
      } else {
        notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
      }
      if (notFromBorder)
        cancel = true;
      if ($previousPageEl.length === 0 || $currentPageEl.length === 0)
        cancel = true;
      if (cancel) {
        isTouched = false;
        return;
      }
      if (paramsSwipeBackAnimateShadow) {
        $pageShadowEl = $currentPageEl.find(".page-shadow-effect");
        if ($pageShadowEl.length === 0) {
          $pageShadowEl = dom7_default('<div class="page-shadow-effect"></div>');
          $currentPageEl.append($pageShadowEl);
        }
      }
      if (paramsSwipeBackAnimateOpacity) {
        $pageOpacityEl = $previousPageEl.find(".page-opacity-effect");
        if ($pageOpacityEl.length === 0) {
          $pageOpacityEl = dom7_default('<div class="page-opacity-effect"></div>');
          $previousPageEl.append($pageOpacityEl);
        }
      }
      if (dynamicNavbar) {
        $currentNavbarEl = $navbarsEl.find(".navbar-current:not(.stacked)");
        $previousNavbarEl = $navbarsEl.find(".navbar-previous:not(.stacked)");
        if ($previousNavbarEl.length > 1) {
          $previousNavbarEl = $previousNavbarEl.eq($previousNavbarEl.length - 1);
        }
        animatableNavEls = animatableNavElements($previousNavbarEl, $currentNavbarEl);
      }
      if (dom7_default(".sheet.modal-in").length > 0 && app.sheet) {
        app.sheet.close(dom7_default(".sheet.modal-in"));
      }
    }
    e.f7PreventSwipePanel = true;
    isMoved = true;
    app.preventSwipePanelBySwipeBack = true;
    e.preventDefault();
    var inverter = app.rtl ? -1 : 1;
    touchesDiff = (pageX - touchesStart.x - paramsSwipeBackThreshold) * inverter;
    if (touchesDiff < 0)
      touchesDiff = 0;
    var percentage = Math.min(Math.max(touchesDiff / viewContainerWidth, 0), 1);
    var callbackData = {
      percentage,
      progress: percentage,
      currentPageEl: $currentPageEl[0],
      previousPageEl: $previousPageEl[0],
      currentNavbarEl: $currentNavbarEl[0],
      previousNavbarEl: $previousNavbarEl[0]
    };
    $el.trigger("swipeback:move", callbackData);
    router.emit("swipebackMove", callbackData);
    var currentPageTranslate = touchesDiff * inverter;
    var previousPageTranslate = (touchesDiff / 5 - viewContainerWidth / 5) * inverter;
    if (!app.rtl) {
      currentPageTranslate = Math.min(currentPageTranslate, viewContainerWidth);
      previousPageTranslate = Math.min(previousPageTranslate, 0);
    } else {
      currentPageTranslate = Math.max(currentPageTranslate, -viewContainerWidth);
      previousPageTranslate = Math.max(previousPageTranslate, 0);
    }
    if (device2.pixelRatio === 1) {
      currentPageTranslate = Math.round(currentPageTranslate);
      previousPageTranslate = Math.round(previousPageTranslate);
    }
    router.swipeBackActive = true;
    dom7_default([$currentPageEl[0], $previousPageEl[0]]).addClass("page-swipeback-active");
    $currentPageEl.transform("translate3d(" + currentPageTranslate + "px,0,0)");
    if (paramsSwipeBackAnimateShadow)
      $pageShadowEl[0].style.opacity = 1 - 1 * percentage;
    if (app.theme === "ios") {
      $previousPageEl.transform("translate3d(" + previousPageTranslate + "px,0,0)");
    }
    if (paramsSwipeBackAnimateOpacity)
      $pageOpacityEl[0].style.opacity = 1 - 1 * percentage;
    if (!dynamicNavbar)
      return;
    setAnimatableNavElements({
      progress: percentage
    });
  }
  function handleTouchEnd() {
    app.preventSwipePanelBySwipeBack = false;
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    isTouched = false;
    isMoved = false;
    router.swipeBackActive = false;
    var $pages = dom7_default([$currentPageEl[0], $previousPageEl[0]]);
    $pages.removeClass("page-swipeback-active");
    if (touchesDiff === 0) {
      $pages.transform("");
      if ($pageShadowEl && $pageShadowEl.length > 0)
        $pageShadowEl.remove();
      if ($pageOpacityEl && $pageOpacityEl.length > 0)
        $pageOpacityEl.remove();
      if (dynamicNavbar) {
        setAnimatableNavElements({
          reset: true
        });
      }
      return;
    }
    var timeDiff = now2() - touchStartTime;
    var pageChanged = false;
    if (timeDiff < 300 && touchesDiff > 10 || timeDiff >= 300 && touchesDiff > viewContainerWidth / 2) {
      $currentPageEl.removeClass("page-current").addClass("page-next" + (app.theme !== "ios" ? " page-next-on-right" : ""));
      $previousPageEl.removeClass("page-previous").addClass("page-current").removeAttr("aria-hidden");
      if ($pageShadowEl)
        $pageShadowEl[0].style.opacity = "";
      if ($pageOpacityEl)
        $pageOpacityEl[0].style.opacity = "";
      if (dynamicNavbar) {
        router.setNavbarPosition($currentNavbarEl, "next");
        router.setNavbarPosition($previousNavbarEl, "current", false);
      }
      pageChanged = true;
    }
    $pages.addClass("page-transitioning page-transitioning-swipeback");
    if (device2.ios) {
      $currentPageEl[0]._clientLeft = $currentPageEl[0].clientLeft;
    }
    $pages.transform("");
    if (dynamicNavbar) {
      setAnimatableNavElements({
        progress: pageChanged ? 1 : 0,
        transition: true,
        reflow: !!device2.ios
      });
    }
    allowViewTouchMove = false;
    router.allowPageChange = false;
    var callbackData = {
      currentPageEl: $currentPageEl[0],
      previousPageEl: $previousPageEl[0],
      currentNavbarEl: $currentNavbarEl[0],
      previousNavbarEl: $previousNavbarEl[0]
    };
    if (pageChanged) {
      router.currentRoute = $previousPageEl[0].f7Page.route;
      router.currentPage = $previousPageEl[0];
      router.pageCallback("beforeOut", $currentPageEl, $currentNavbarEl, "current", "next", {
        route: $currentPageEl[0].f7Page.route,
        swipeBack: true
      });
      router.pageCallback("beforeIn", $previousPageEl, $previousNavbarEl, "previous", "current", {
        route: $previousPageEl[0].f7Page.route,
        swipeBack: true
      }, $currentPageEl[0]);
      $el.trigger("swipeback:beforechange", callbackData);
      router.emit("swipebackBeforeChange", callbackData);
    } else {
      $el.trigger("swipeback:beforereset", callbackData);
      router.emit("swipebackBeforeReset", callbackData);
    }
    $currentPageEl.transitionEnd(function() {
      $pages.removeClass("page-transitioning page-transitioning-swipeback");
      if (dynamicNavbar) {
        setAnimatableNavElements({
          reset: true,
          transition: false
        });
      }
      allowViewTouchMove = true;
      router.allowPageChange = true;
      if (pageChanged) {
        if (router.history.length === 1) {
          router.history.unshift(router.url);
        }
        router.history.pop();
        router.saveHistory();
        if (params.browserHistory) {
          history_default.back();
        }
        router.pageCallback("afterOut", $currentPageEl, $currentNavbarEl, "current", "next", {
          route: $currentPageEl[0].f7Page.route,
          swipeBack: true
        });
        router.pageCallback("afterIn", $previousPageEl, $previousNavbarEl, "previous", "current", {
          route: $previousPageEl[0].f7Page.route,
          swipeBack: true
        });
        if (params.stackPages && router.initialPages.indexOf($currentPageEl[0]) >= 0) {
          $currentPageEl.addClass("stacked");
          if (dynamicNavbar) {
            $currentNavbarEl.addClass("stacked");
          }
        } else {
          router.pageCallback("beforeRemove", $currentPageEl, $currentNavbarEl, "next", {
            swipeBack: true
          });
          router.removePage($currentPageEl);
          if (dynamicNavbar) {
            router.removeNavbar($currentNavbarEl);
          }
        }
        $el.trigger("swipeback:afterchange", callbackData);
        router.emit("swipebackAfterChange", callbackData);
        router.emit("routeChanged", router.currentRoute, router.previousRoute, router);
        if (params.preloadPreviousPage) {
          router.back(router.history[router.history.length - 2], {
            preload: true
          });
        }
      } else {
        $el.trigger("swipeback:afterreset", callbackData);
        router.emit("swipebackAfterReset", callbackData);
      }
      if ($pageShadowEl && $pageShadowEl.length > 0)
        $pageShadowEl.remove();
      if ($pageOpacityEl && $pageOpacityEl.length > 0)
        $pageOpacityEl.remove();
    });
  }
  function attachEvents2() {
    var passiveListener = app.touchEvents.start === "touchstart" && support3.passiveListener ? {
      passive: true,
      capture: false
    } : false;
    $el.on(app.touchEvents.start, handleTouchStart, passiveListener);
    app.on("touchmove:active", handleTouchMove);
    app.on("touchend:passive", handleTouchEnd);
  }
  function detachEvents2() {
    var passiveListener = app.touchEvents.start === "touchstart" && support3.passiveListener ? {
      passive: true,
      capture: false
    } : false;
    $el.off(app.touchEvents.start, handleTouchStart, passiveListener);
    app.off("touchmove:active", handleTouchMove);
    app.off("touchend:passive", handleTouchEnd);
  }
  attachEvents2();
  router.on("routerDestroy", detachEvents2);
}
var swipe_back_default = SwipeBack;

// node_modules/framework7/esm/modules/router/redirect.js
function redirect(direction, route, options) {
  var router = this;
  var r = route.route.redirect;
  var method = direction === "forward" ? "navigate" : "back";
  if (options.initial && router.params.browserHistory) {
    options.replaceState = true;
    options.history = true;
  }
  function redirectResolve(redirectUrl2, redirectOptions) {
    if (redirectOptions === void 0) {
      redirectOptions = {};
    }
    router.allowPageChange = true;
    router[method](redirectUrl2, extend3({}, options, redirectOptions));
  }
  function redirectReject() {
    router.allowPageChange = true;
  }
  if (typeof r === "function") {
    router.allowPageChange = false;
    var redirectUrl = r.call(router, {
      router,
      to: route,
      resolve: redirectResolve,
      reject: redirectReject,
      direction,
      app: router.app
    });
    if (redirectUrl && typeof redirectUrl === "string") {
      router.allowPageChange = true;
      return router[method](redirectUrl, options);
    }
    return router;
  }
  return router[method](r, options);
}

// node_modules/framework7/esm/modules/router/process-route-queue.js
function processQueue(router, routerQueue, routeQueue, to, from, resolve, _reject, direction) {
  var queue = [];
  if (Array.isArray(routeQueue)) {
    queue.push.apply(queue, routeQueue);
  } else if (routeQueue && typeof routeQueue === "function") {
    queue.push(routeQueue);
  }
  if (routerQueue) {
    if (Array.isArray(routerQueue)) {
      queue.push.apply(queue, routerQueue);
    } else {
      queue.push(routerQueue);
    }
  }
  function next2() {
    if (queue.length === 0) {
      resolve();
      return;
    }
    var queueItem = queue.shift();
    queueItem.call(router, {
      router,
      to,
      from,
      resolve: function resolve2() {
        next2();
      },
      reject: function reject() {
        _reject();
      },
      direction,
      app: router.app
    });
  }
  next2();
}
function processRouteQueue(to, from, resolve, reject, direction) {
  var router = this;
  function enterNextRoute() {
    if (to && to.route && (router.params.routesBeforeEnter || to.route.beforeEnter)) {
      router.allowPageChange = false;
      processQueue(router, router.params.routesBeforeEnter, to.route.beforeEnter, to, from, function() {
        router.allowPageChange = true;
        resolve();
      }, function() {
        reject();
      }, direction);
    } else {
      resolve();
    }
  }
  function leaveCurrentRoute() {
    if (from && from.route && (router.params.routesBeforeLeave || from.route.beforeLeave)) {
      router.allowPageChange = false;
      processQueue(router, router.params.routesBeforeLeave, from.route.beforeLeave, to, from, function() {
        router.allowPageChange = true;
        enterNextRoute();
      }, function() {
        reject();
      }, direction);
    } else {
      enterNextRoute();
    }
  }
  leaveCurrentRoute();
}

// node_modules/framework7/esm/modules/router/app-router-check.js
function appRouterCheck(router, method) {
  if (!router.view) {
    throw new Error("Framework7: it is not allowed to use router methods on global app router. Use router methods only on related View, e.g. app.views.main.router." + method + "(...)");
  }
}

// node_modules/framework7/esm/modules/router/async-component.js
function asyncComponent(router, component, resolve, reject) {
  function resolvePromise(componentPromise) {
    componentPromise.then(function(c) {
      resolve({
        component: c.default || c._default || c
      });
    }).catch(function(err) {
      reject();
      throw new Error(err);
    });
  }
  if (component instanceof Promise) {
    resolvePromise(component);
    return;
  }
  var asyncComponentResult = component.call(router);
  if (asyncComponentResult instanceof Promise) {
    resolvePromise(asyncComponentResult);
  } else {
    resolve({
      component: asyncComponentResult
    });
  }
}

// node_modules/framework7/esm/modules/router/navigate.js
function _extends3() {
  _extends3 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
function refreshPage() {
  var router = this;
  appRouterCheck(router, "refreshPage");
  return router.navigate(router.currentRoute.url, {
    ignoreCache: true,
    reloadCurrent: true
  });
}
function forward(router, el, forwardOptions) {
  if (forwardOptions === void 0) {
    forwardOptions = {};
  }
  var document2 = getDocument();
  var $el = dom7_default(el);
  var app = router.app;
  var view = router.view;
  var options = extend3(false, {
    animate: router.params.animate,
    browserHistory: true,
    replaceState: false,
    history: true,
    reloadCurrent: router.params.reloadPages,
    reloadPrevious: false,
    reloadAll: false,
    clearPreviousHistory: false,
    reloadDetail: router.params.reloadDetail,
    on: {}
  }, forwardOptions);
  var masterDetailEnabled = router.params.masterDetailBreakpoint > 0;
  var isMaster = masterDetailEnabled && options.route && options.route.route && (options.route.route.master === true || typeof options.route.route.master === "function" && options.route.route.master(app, router));
  var masterPageEl;
  var otherDetailPageEl;
  var detailsInBetweenRemoved = 0;
  var currentRouteIsModal = router.currentRoute.modal;
  var modalType;
  if (!currentRouteIsModal) {
    "popup popover sheet loginScreen actions customModal panel".split(" ").forEach(function(modalLoadProp) {
      if (router.currentRoute && router.currentRoute.route && router.currentRoute.route[modalLoadProp]) {
        currentRouteIsModal = true;
        modalType = modalLoadProp;
      }
    });
  }
  if (currentRouteIsModal) {
    var modalToClose = router.currentRoute.modal || router.currentRoute.route.modalInstance || app[modalType].get();
    var previousUrl = router.history[router.history.length - 2];
    var previousRoute = router.findMatchingRoute(previousUrl);
    if (!previousRoute && previousUrl) {
      previousRoute = {
        url: previousUrl,
        path: previousUrl.split("?")[0],
        query: parseUrlQuery(previousUrl),
        route: {
          path: previousUrl.split("?")[0],
          url: previousUrl
        }
      };
    }
    router.modalRemove(modalToClose);
  }
  var dynamicNavbar = router.dynamicNavbar;
  var $viewEl = router.$el;
  var $newPage = $el;
  var reload = options.reloadPrevious || options.reloadCurrent || options.reloadAll;
  var $oldPage;
  var $navbarsEl;
  var $newNavbarEl;
  var $oldNavbarEl;
  router.allowPageChange = false;
  if ($newPage.length === 0) {
    router.allowPageChange = true;
    return router;
  }
  if ($newPage.length) {
    router.removeThemeElements($newPage);
  }
  if (dynamicNavbar) {
    $newNavbarEl = $newPage.children(".navbar");
    $navbarsEl = router.$navbarsEl;
    if ($newNavbarEl.length === 0 && $newPage[0] && $newPage[0].f7Page) {
      $newNavbarEl = $newPage[0].f7Page.$navbarEl;
    }
  }
  if (options.route && options.route.route && options.route.route.keepAlive && !options.route.route.keepAliveData) {
    options.route.route.keepAliveData = {
      pageEl: $el[0]
    };
  }
  var $pagesInView = $viewEl.children(".page:not(.stacked)").filter(function(pageInView) {
    return pageInView !== $newPage[0];
  });
  var $navbarsInView;
  if (dynamicNavbar) {
    $navbarsInView = $navbarsEl.children(".navbar:not(.stacked)").filter(function(navbarInView) {
      return navbarInView !== $newNavbarEl[0];
    });
  }
  if (options.reloadPrevious && $pagesInView.length < 2) {
    router.allowPageChange = true;
    return router;
  }
  var isDetail;
  var reloadDetail;
  var isDetailRoot;
  if (masterDetailEnabled && !options.reloadAll) {
    for (var i = 0; i < $pagesInView.length; i += 1) {
      if (!masterPageEl && $pagesInView[i].classList.contains("page-master")) {
        masterPageEl = $pagesInView[i];
        continue;
      }
    }
    isDetail = !isMaster && masterPageEl;
    if (isDetail) {
      if (masterPageEl) {
        for (var _i = 0; _i < $pagesInView.length; _i += 1) {
          if ($pagesInView[_i].classList.contains("page-master-detail")) {
            otherDetailPageEl = $pagesInView[_i];
            continue;
          }
        }
      }
    }
    reloadDetail = isDetail && options.reloadDetail && app.width >= router.params.masterDetailBreakpoint && masterPageEl;
  }
  if (isDetail) {
    isDetailRoot = !otherDetailPageEl || reloadDetail || options.reloadAll || options.reloadCurrent;
  }
  var newPagePosition = "next";
  if (options.reloadCurrent || options.reloadAll || reloadDetail) {
    newPagePosition = "current";
  } else if (options.reloadPrevious) {
    newPagePosition = "previous";
  }
  $newPage.removeClass("page-previous page-current page-next").addClass("page-" + newPagePosition + (isMaster ? " page-master" : "") + (isDetail ? " page-master-detail" : "") + (isDetailRoot ? " page-master-detail-root" : "")).removeClass("stacked").trigger("page:unstack").trigger("page:position", {
    position: newPagePosition
  });
  router.emit("pageUnstack", $newPage[0]);
  router.emit("pagePosition", $newPage[0], newPagePosition);
  if (isMaster || isDetail) {
    $newPage.trigger("page:role", {
      role: isMaster ? "master" : "detail",
      root: !!isDetailRoot
    });
    router.emit("pageRole", $newPage[0], {
      role: isMaster ? "master" : "detail",
      detailRoot: !!isDetailRoot
    });
  }
  if (dynamicNavbar && $newNavbarEl.length) {
    $newNavbarEl.removeClass("navbar-previous navbar-current navbar-next").addClass("navbar-" + newPagePosition + (isMaster ? " navbar-master" : "") + (isDetail ? " navbar-master-detail" : "") + (isDetailRoot ? " navbar-master-detail-root" : "")).removeClass("stacked");
    $newNavbarEl.trigger("navbar:position", {
      position: newPagePosition
    });
    router.emit("navbarPosition", $newNavbarEl[0], newPagePosition);
    if (isMaster || isDetail) {
      router.emit("navbarRole", $newNavbarEl[0], {
        role: isMaster ? "master" : "detail",
        detailRoot: !!isDetailRoot
      });
    }
  }
  if (options.reloadCurrent || reloadDetail) {
    if (reloadDetail) {
      $oldPage = $pagesInView.filter(function(pageEl) {
        return !pageEl.classList.contains("page-master");
      });
      if (dynamicNavbar) {
        $oldNavbarEl = dom7_default($oldPage.map(function(pageEl) {
          return app.navbar.getElByPage(pageEl);
        }));
      }
      if ($oldPage.length > 1 && masterPageEl) {
        detailsInBetweenRemoved = $oldPage.length - 1;
        dom7_default(masterPageEl).removeClass("page-master-stacked").trigger("page:masterunstack");
        router.emit("pageMasterUnstack", masterPageEl);
        if (dynamicNavbar) {
          dom7_default(app.navbar.getElByPage(masterPageEl)).removeClass("navbar-master-stacked");
          router.emit("navbarMasterUnstack", app.navbar.getElByPage(masterPageEl));
        }
      }
    } else {
      $oldPage = $pagesInView.eq($pagesInView.length - 1);
      if (dynamicNavbar) {
        $oldNavbarEl = dom7_default(app.navbar.getElByPage($oldPage));
      }
    }
  } else if (options.reloadPrevious) {
    $oldPage = $pagesInView.eq($pagesInView.length - 2);
    if (dynamicNavbar) {
      $oldNavbarEl = dom7_default(app.navbar.getElByPage($oldPage));
    }
  } else if (options.reloadAll) {
    $oldPage = $pagesInView.filter(function(pageEl) {
      return pageEl !== $newPage[0];
    });
    if (dynamicNavbar) {
      $oldNavbarEl = $navbarsInView.filter(function(navbarEl) {
        return navbarEl !== $newNavbarEl[0];
      });
    }
  } else {
    var removedPageEls = [];
    var removedNavbarEls = [];
    if ($pagesInView.length > 1) {
      var _i2 = 0;
      for (_i2 = 0; _i2 < $pagesInView.length - 1; _i2 += 1) {
        if (masterPageEl && $pagesInView[_i2] === masterPageEl) {
          $pagesInView.eq(_i2).addClass("page-master-stacked");
          $pagesInView.eq(_i2).trigger("page:masterstack");
          router.emit("pageMasterStack", $pagesInView[_i2]);
          if (dynamicNavbar) {
            dom7_default(app.navbar.getElByPage(masterPageEl)).addClass("navbar-master-stacked");
            router.emit("navbarMasterStack", app.navbar.getElByPage(masterPageEl));
          }
          continue;
        }
        var oldNavbarEl = app.navbar.getElByPage($pagesInView.eq(_i2));
        if (router.params.stackPages) {
          $pagesInView.eq(_i2).addClass("stacked");
          $pagesInView.eq(_i2).trigger("page:stack");
          router.emit("pageStack", $pagesInView[_i2]);
          if (dynamicNavbar) {
            dom7_default(oldNavbarEl).addClass("stacked");
          }
        } else {
          removedPageEls.push($pagesInView[_i2]);
          router.pageCallback("beforeRemove", $pagesInView[_i2], $navbarsInView && $navbarsInView[_i2], "previous", void 0, options);
          router.removePage($pagesInView[_i2]);
          if (dynamicNavbar && oldNavbarEl) {
            removedNavbarEls.push(oldNavbarEl);
            router.removeNavbar(oldNavbarEl);
          }
        }
      }
    }
    $oldPage = $viewEl.children(".page:not(.stacked)").filter(function(pageEl) {
      return pageEl !== $newPage[0] && removedPageEls.indexOf(pageEl) < 0;
    });
    if (dynamicNavbar) {
      $oldNavbarEl = $navbarsEl.children(".navbar:not(.stacked)").filter(function(navbarEl) {
        return navbarEl !== $newNavbarEl[0] && removedNavbarEls.indexOf(removedNavbarEls) < 0;
      });
    }
    removedPageEls = [];
    removedNavbarEls = [];
  }
  if (isDetail && !options.reloadAll) {
    if ($oldPage.length > 1 || reloadDetail) {
      $oldPage = $oldPage.filter(function(pageEl) {
        return !pageEl.classList.contains("page-master");
      });
    }
    if ($oldNavbarEl && ($oldNavbarEl.length > 1 || reloadDetail)) {
      $oldNavbarEl = $oldNavbarEl.filter(function(navbarEl) {
        return !navbarEl.classList.contains("navbar-master");
      });
    }
  }
  if (router.params.browserHistory && (options.browserHistory || options.replaceState) && !options.reloadPrevious) {
    var browserHistoryRoot = router.params.browserHistoryRoot || "";
    history_default[options.reloadCurrent || reloadDetail && otherDetailPageEl || options.reloadAll || options.replaceState ? "replace" : "push"](view.id, {
      url: options.route.url
    }, browserHistoryRoot + router.params.browserHistorySeparator + options.route.url);
  }
  if (!options.reloadPrevious) {
    router.currentPageEl = $newPage[0];
    if (dynamicNavbar && $newNavbarEl.length) {
      router.currentNavbarEl = $newNavbarEl[0];
    } else {
      delete router.currentNavbarEl;
    }
    router.currentRoute = options.route;
  }
  var url = options.route.url;
  if (options.history) {
    if (((options.reloadCurrent || reloadDetail && otherDetailPageEl) && router.history.length) > 0 || options.replaceState) {
      if (reloadDetail && detailsInBetweenRemoved > 0) {
        router.history = router.history.slice(0, router.history.length - detailsInBetweenRemoved);
      }
      router.history[router.history.length - (options.reloadPrevious ? 2 : 1)] = url;
    } else if (options.reloadPrevious) {
      router.history[router.history.length - 2] = url;
    } else if (options.reloadAll) {
      router.history = [url];
    } else {
      router.history.push(url);
    }
  }
  router.saveHistory();
  var newPageInDom = $newPage.parents(document2).length > 0;
  var f7Component = $newPage[0].f7Component;
  if (options.reloadPrevious) {
    if (f7Component && !newPageInDom) {
      f7Component.mount(function(componentEl) {
        dom7_default(componentEl).insertBefore($oldPage);
      });
    } else {
      $newPage.insertBefore($oldPage);
    }
    if (dynamicNavbar && $newNavbarEl.length) {
      if ($newNavbarEl.find(".title-large").length) {
        $newNavbarEl.addClass("navbar-large");
      }
      if ($oldNavbarEl.length) {
        $newNavbarEl.insertBefore($oldNavbarEl);
      } else {
        if (!router.$navbarsEl.parents(document2).length) {
          router.$el.prepend(router.$navbarsEl);
        }
        $navbarsEl.append($newNavbarEl);
      }
    }
  } else {
    if ($oldPage.next(".page")[0] !== $newPage[0]) {
      if (f7Component && !newPageInDom) {
        f7Component.mount(function(componentEl) {
          $viewEl.append(componentEl);
        });
      } else {
        $viewEl.append($newPage[0]);
      }
    }
    if (dynamicNavbar && $newNavbarEl.length) {
      if ($newNavbarEl.find(".title-large").length) {
        $newNavbarEl.addClass("navbar-large");
      }
      if (!router.$navbarsEl.parents(document2).length) {
        router.$el.prepend(router.$navbarsEl);
      }
      $navbarsEl.append($newNavbarEl[0]);
    }
  }
  if (!newPageInDom) {
    router.pageCallback("mounted", $newPage, $newNavbarEl, newPagePosition, reload ? newPagePosition : "current", options, $oldPage);
  } else if (options.route && options.route.route && options.route.route.keepAlive && !$newPage[0].f7PageMounted) {
    $newPage[0].f7PageMounted = true;
    router.pageCallback("mounted", $newPage, $newNavbarEl, newPagePosition, reload ? newPagePosition : "current", options, $oldPage);
  }
  if ((options.reloadCurrent || reloadDetail) && $oldPage.length > 0) {
    if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
      $oldPage.addClass("stacked");
      $oldPage.trigger("page:stack");
      router.emit("pageStack", $oldPage[0]);
      if (dynamicNavbar) {
        $oldNavbarEl.addClass("stacked");
      }
    } else {
      router.pageCallback("beforeOut", $oldPage, $oldNavbarEl, "current", void 0, options);
      router.pageCallback("afterOut", $oldPage, $oldNavbarEl, "current", void 0, options);
      router.pageCallback("beforeRemove", $oldPage, $oldNavbarEl, "current", void 0, options);
      router.removePage($oldPage);
      if (dynamicNavbar && $oldNavbarEl && $oldNavbarEl.length) {
        router.removeNavbar($oldNavbarEl);
      }
    }
  } else if (options.reloadAll) {
    $oldPage.each(function(pageEl, index2) {
      var $oldPageEl = dom7_default(pageEl);
      var $oldNavbarElEl = dom7_default(app.navbar.getElByPage($oldPageEl));
      if (router.params.stackPages && router.initialPages.indexOf($oldPageEl[0]) >= 0) {
        $oldPageEl.addClass("stacked");
        $oldPageEl.trigger("page:stack");
        router.emit("pageStack", $oldPageEl[0]);
        if (dynamicNavbar) {
          $oldNavbarElEl.addClass("stacked");
        }
      } else {
        if ($oldPageEl.hasClass("page-current")) {
          router.pageCallback("beforeOut", $oldPage, $oldNavbarEl, "current", void 0, options);
          router.pageCallback("afterOut", $oldPage, $oldNavbarEl, "current", void 0, options);
        }
        router.pageCallback("beforeRemove", $oldPageEl, $oldNavbarEl && $oldNavbarEl.eq(index2), "previous", void 0, options);
        router.removePage($oldPageEl);
        if (dynamicNavbar && $oldNavbarElEl.length) {
          router.removeNavbar($oldNavbarElEl);
        }
      }
    });
  } else if (options.reloadPrevious) {
    if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
      $oldPage.addClass("stacked");
      $oldPage.trigger("page:stack");
      router.emit("pageStack", $oldPage[0]);
      if (dynamicNavbar) {
        $oldNavbarEl.addClass("stacked");
      }
    } else {
      router.pageCallback("beforeRemove", $oldPage, $oldNavbarEl, "previous", void 0, options);
      router.removePage($oldPage);
      if (dynamicNavbar && $oldNavbarEl && $oldNavbarEl.length) {
        router.removeNavbar($oldNavbarEl);
      }
    }
  }
  if (options.route.route.tab) {
    router.tabLoad(options.route.route.tab, extend3({}, options, {
      history: false,
      browserHistory: false
    }));
  }
  if (masterDetailEnabled) {
    view.checkMasterDetailBreakpoint();
  }
  router.pageCallback("init", $newPage, $newNavbarEl, newPagePosition, reload ? newPagePosition : "current", options, $oldPage);
  if (options.reloadCurrent || options.reloadAll || reloadDetail) {
    router.allowPageChange = true;
    router.pageCallback("beforeIn", $newPage, $newNavbarEl, newPagePosition, "current", options);
    $newPage.removeAttr("aria-hidden");
    if (dynamicNavbar && $newNavbarEl) {
      $newNavbarEl.removeAttr("aria-hidden");
    }
    router.pageCallback("afterIn", $newPage, $newNavbarEl, newPagePosition, "current", options);
    if (options.reloadCurrent && options.clearPreviousHistory)
      router.clearPreviousHistory();
    if (reloadDetail) {
      router.setPagePosition(dom7_default(masterPageEl), "previous");
      if (masterPageEl.f7Page && masterPageEl.f7Page.navbarEl) {
        router.setNavbarPosition(dom7_default(masterPageEl.f7Page.navbarEl), "previous");
      }
    }
    return router;
  }
  if (options.reloadPrevious) {
    router.allowPageChange = true;
    return router;
  }
  router.pageCallback("beforeOut", $oldPage, $oldNavbarEl, "current", "previous", options);
  router.pageCallback("beforeIn", $newPage, $newNavbarEl, "next", "current", options);
  function afterAnimation() {
    router.setPagePosition($newPage, "current", false);
    router.setPagePosition($oldPage, "previous", !$oldPage.hasClass("page-master"));
    if (dynamicNavbar) {
      router.setNavbarPosition($newNavbarEl, "current", false);
      router.setNavbarPosition($oldNavbarEl, "previous", !$oldNavbarEl.hasClass("navbar-master"));
    }
    router.allowPageChange = true;
    router.pageCallback("afterOut", $oldPage, $oldNavbarEl, "current", "previous", options);
    router.pageCallback("afterIn", $newPage, $newNavbarEl, "next", "current", options);
    var keepOldPage = (router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"]) && !isMaster;
    if (!keepOldPage) {
      if ($newPage.hasClass("smart-select-page") || $newPage.hasClass("photo-browser-page") || $newPage.hasClass("autocomplete-page") || $newPage.hasClass("color-picker-page")) {
        keepOldPage = true;
      }
    }
    if (!keepOldPage) {
      if (router.params.stackPages) {
        $oldPage.addClass("stacked");
        $oldPage.trigger("page:stack");
        router.emit("pageStack", $oldPage[0]);
        if (dynamicNavbar) {
          $oldNavbarEl.addClass("stacked");
        }
      } else if (!($newPage.attr("data-name") && $newPage.attr("data-name") === "smart-select-page")) {
        router.pageCallback("beforeRemove", $oldPage, $oldNavbarEl, "previous", void 0, options);
        router.removePage($oldPage);
        if (dynamicNavbar && $oldNavbarEl.length) {
          router.removeNavbar($oldNavbarEl);
        }
      }
    }
    if (options.clearPreviousHistory)
      router.clearPreviousHistory();
    router.emit("routeChanged", router.currentRoute, router.previousRoute, router);
    if (router.params.browserHistory) {
      history_default.clearRouterQueue();
    }
  }
  function setPositionClasses() {
    router.setPagePosition($oldPage, "current", false);
    router.setPagePosition($newPage, "next", false);
    if (dynamicNavbar) {
      router.setNavbarPosition($oldNavbarEl, "current", false);
      router.setNavbarPosition($newNavbarEl, "next", false);
    }
  }
  if (options.animate && !(isMaster && app.width >= router.params.masterDetailBreakpoint)) {
    var delay = router.params[router.app.theme + "PageLoadDelay"];
    var transition2 = router.params.transition;
    if (options.transition)
      transition2 = options.transition;
    if (!transition2 && router.currentRoute && router.currentRoute.route) {
      transition2 = router.currentRoute.route.transition;
    }
    if (!transition2 && router.currentRoute && router.currentRoute.route.options) {
      transition2 = router.currentRoute.route.options.transition;
    }
    if (transition2) {
      $newPage[0].f7PageTransition = transition2;
    }
    if (delay) {
      setTimeout(function() {
        setPositionClasses();
        router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, "forward", transition2, function() {
          afterAnimation();
        });
      }, delay);
    } else {
      setPositionClasses();
      router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, "forward", transition2, function() {
        afterAnimation();
      });
    }
  } else {
    afterAnimation();
  }
  return router;
}
function load(router, loadParams, loadOptions, ignorePageChange) {
  if (loadParams === void 0) {
    loadParams = {};
  }
  if (loadOptions === void 0) {
    loadOptions = {};
  }
  if (!router.allowPageChange && !ignorePageChange)
    return router;
  var params = loadParams;
  var options = loadOptions;
  var url = params.url, content = params.content, el = params.el, pageName = params.pageName, component = params.component, componentUrl = params.componentUrl;
  if (!options.reloadCurrent && options.route && options.route.route && options.route.route.parentPath && router.currentRoute.route && router.currentRoute.route.parentPath === options.route.route.parentPath) {
    if (options.route.url === router.url) {
      router.allowPageChange = true;
      return false;
    }
    var sameParams = Object.keys(options.route.params).length === Object.keys(router.currentRoute.params).length;
    if (sameParams) {
      Object.keys(options.route.params).forEach(function(paramName) {
        if (!(paramName in router.currentRoute.params) || router.currentRoute.params[paramName] !== options.route.params[paramName]) {
          sameParams = false;
        }
      });
    }
    if (sameParams) {
      if (options.route.route.tab) {
        return router.tabLoad(options.route.route.tab, options);
      }
      return false;
    }
    if (!sameParams && options.route.route.tab && router.currentRoute.route.tab && router.currentRoute.parentPath === options.route.parentPath) {
      return router.tabLoad(options.route.route.tab, options);
    }
  }
  if (options.route && options.route.url && router.url === options.route.url && !(options.reloadCurrent || options.reloadPrevious) && !router.params.allowDuplicateUrls) {
    router.allowPageChange = true;
    return false;
  }
  if (!options.route && url) {
    options.route = router.parseRouteUrl(url);
    extend3(options.route, {
      route: {
        url,
        path: url
      }
    });
  }
  function resolve(pageEl, newOptions) {
    return forward(router, pageEl, extend3(options, newOptions));
  }
  function reject() {
    router.allowPageChange = true;
    return router;
  }
  if (url || componentUrl || component) {
    router.allowPageChange = false;
  }
  if (content) {
    forward(router, router.getPageEl(content), options);
  } else if (el) {
    forward(router, router.getPageEl(el), options);
  } else if (pageName) {
    forward(router, router.$el.children('.page[data-name="' + pageName + '"]').eq(0), options);
  } else if (component || componentUrl) {
    try {
      router.pageComponentLoader({
        routerEl: router.el,
        component,
        componentUrl,
        options,
        resolve,
        reject
      });
    } catch (err) {
      router.allowPageChange = true;
      throw err;
    }
  } else if (url) {
    if (router.xhrAbortController) {
      router.xhrAbortController.abort();
      router.xhrAbortController = false;
    }
    router.xhrRequest(url, options).then(function(pageContent) {
      forward(router, router.getPageEl(pageContent), options);
    }).catch(function() {
      router.allowPageChange = true;
    });
  }
  return router;
}
function openIn(router, url, options) {
  var navigateOptions = {
    url,
    route: {
      path: url,
      options: _extends3({}, options, {
        openIn: void 0
      })
    }
  };
  var params = _extends3({}, options);
  if (options.openIn === "popup") {
    params.content = '<div class="popup popup-router-open-in" data-url="' + url + '"><div class="view view-init" data-links-view="' + router.view.selector + '" data-url="' + url + '" data-ignore-open-in="true"></div></div>';
    navigateOptions.route.popup = params;
  }
  if (options.openIn === "loginScreen") {
    params.content = '<div class="login-screen login-screen-router-open-in" data-url="' + url + '"><div class="view view-init" data-links-view="' + router.view.selector + '" data-url="' + url + '" data-ignore-open-in="true"></div></div>';
    navigateOptions.route.loginScreen = params;
  }
  if (options.openIn === "sheet") {
    params.content = '<div class="sheet-modal sheet-modal-router-open-in" data-url="' + url + '"><div class="sheet-modal-inner"><div class="view view-init" data-links-view="' + router.view.selector + '" data-url="' + url + '" data-ignore-open-in="true"></div></div></div>';
    navigateOptions.route.sheet = params;
  }
  if (options.openIn === "popover") {
    params.targetEl = options.clickedEl || options.targetEl;
    params.content = '<div class="popover popover-router-open-in" data-url="' + url + '"><div class="popover-inner"><div class="view view-init" data-links-view="' + router.view.selector + '" data-url="' + url + '" data-ignore-open-in="true"></div></div></div>';
    navigateOptions.route.popover = params;
  }
  if (options.openIn.indexOf("panel") >= 0) {
    var parts = options.openIn.split(":");
    var side = parts[1] || "left";
    var effect = parts[2] || "cover";
    params.targetEl = options.clickedEl || options.targetEl;
    params.content = '<div class="panel panel-router-open-in panel-' + side + " panel-" + effect + '" data-url="' + url + '"><div class="view view-init" data-links-view="' + router.view.selector + '" data-url="' + url + '" data-ignore-open-in="true"></div></div>';
    navigateOptions.route.panel = params;
  }
  return router.navigate(navigateOptions);
}
function navigate(navigateParams, navigateOptions) {
  if (navigateOptions === void 0) {
    navigateOptions = {};
  }
  var router = this;
  if (router.swipeBackActive)
    return router;
  var url;
  var createRoute;
  var name;
  var path;
  var query;
  var params;
  var route;
  if (typeof navigateParams === "string") {
    url = navigateParams;
  } else {
    url = navigateParams.url;
    createRoute = navigateParams.route;
    name = navigateParams.name;
    path = navigateParams.path;
    query = navigateParams.query;
    params = navigateParams.params;
  }
  if (name || path) {
    url = router.generateUrl({
      path,
      name,
      params,
      query
    });
    if (url) {
      return router.navigate(url, navigateOptions);
    }
    return router;
  }
  var app = router.app;
  appRouterCheck(router, "navigate");
  if (url === "#" || url === "") {
    return router;
  }
  var navigateUrl = url.replace("./", "");
  if (navigateUrl[0] !== "/" && navigateUrl.indexOf("#") !== 0) {
    var currentPath = router.currentRoute.parentPath || router.currentRoute.path;
    navigateUrl = ((currentPath ? currentPath + "/" : "/") + navigateUrl).replace("///", "/").replace("//", "/");
  }
  if (createRoute) {
    route = extend3(router.parseRouteUrl(navigateUrl), {
      route: extend3({}, createRoute)
    });
  } else {
    route = router.findMatchingRoute(navigateUrl);
  }
  if (!route) {
    return router;
  }
  if (route.route && route.route.viewName) {
    var anotherViewName = route.route.viewName;
    var anotherView = app.views[anotherViewName];
    if (!anotherView) {
      throw new Error('Framework7: There is no View with "' + anotherViewName + '" name that was specified in this route');
    }
    if (anotherView !== router.view) {
      return anotherView.router.navigate(navigateParams, navigateOptions);
    }
  }
  if (route.route.redirect) {
    return redirect.call(router, "forward", route, navigateOptions);
  }
  var options = {};
  if (route.route.options) {
    extend3(options, route.route.options, navigateOptions);
  } else {
    extend3(options, navigateOptions);
  }
  if (options.openIn && (!router.params.ignoreOpenIn || router.params.ignoreOpenIn && router.history.length > 0)) {
    return openIn(router, navigateUrl, options);
  }
  options.route = route;
  function resolve() {
    var routerLoaded = false;
    "popup popover sheet loginScreen actions customModal panel".split(" ").forEach(function(modalLoadProp) {
      if (route.route[modalLoadProp] && !routerLoaded) {
        routerLoaded = true;
        router.modalLoad(modalLoadProp, route, options, "forward");
      }
    });
    if (route.route.keepAlive && route.route.keepAliveData) {
      load(router, {
        el: route.route.keepAliveData.pageEl
      }, options, false);
      routerLoaded = true;
    }
    "url content component pageName el componentUrl".split(" ").forEach(function(pageLoadProp) {
      if (route.route[pageLoadProp] && !routerLoaded) {
        var _load;
        routerLoaded = true;
        load(router, (_load = {}, _load[pageLoadProp] = route.route[pageLoadProp], _load), options, false);
      }
    });
    if (routerLoaded)
      return;
    function asyncResolve(resolveParams, resolveOptions) {
      router.allowPageChange = false;
      var resolvedAsModal = false;
      "popup popover sheet loginScreen actions customModal panel".split(" ").forEach(function(modalLoadProp) {
        if (resolveParams[modalLoadProp]) {
          resolvedAsModal = true;
          var modalRoute = extend3({}, route, {
            route: resolveParams
          });
          router.allowPageChange = true;
          router.modalLoad(modalLoadProp, modalRoute, extend3(options, resolveOptions), "forward");
        }
      });
      if (resolvedAsModal)
        return;
      load(router, resolveParams, extend3(options, resolveOptions), true);
    }
    function asyncReject() {
      router.allowPageChange = true;
    }
    if (route.route.async) {
      router.allowPageChange = false;
      route.route.async.call(router, {
        router,
        to: options.route,
        from: router.currentRoute,
        resolve: asyncResolve,
        reject: asyncReject,
        direction: "forward",
        app
      });
    }
    if (route.route.asyncComponent) {
      asyncComponent(router, route.route.asyncComponent, asyncResolve, asyncReject);
    }
  }
  function reject() {
    router.allowPageChange = true;
  }
  if (router.params.masterDetailBreakpoint > 0 && route.route.masterRoute) {
    var preloadMaster = true;
    var masterLoaded = false;
    if (router.currentRoute && router.currentRoute.route) {
      if ((router.currentRoute.route.master === true || typeof router.currentRoute.route.master === "function" && router.currentRoute.route.master(app, router)) && (router.currentRoute.route === route.route.masterRoute || router.currentRoute.route.path === route.route.masterRoute.path)) {
        preloadMaster = false;
      }
      if (router.currentRoute.route.masterRoute && (router.currentRoute.route.masterRoute === route.route.masterRoute || router.currentRoute.route.masterRoute.path === route.route.masterRoute.path)) {
        preloadMaster = false;
        masterLoaded = true;
      }
    }
    if (preloadMaster || masterLoaded && navigateOptions.reloadAll) {
      router.navigate({
        path: route.route.masterRoute.path,
        params: route.params || {}
      }, {
        animate: false,
        reloadAll: navigateOptions.reloadAll,
        reloadCurrent: navigateOptions.reloadCurrent,
        reloadPrevious: navigateOptions.reloadPrevious,
        browserHistory: !navigateOptions.initial,
        history: !navigateOptions.initial,
        once: {
          pageAfterIn: function pageAfterIn() {
            router.navigate(navigateParams, extend3({}, navigateOptions, {
              animate: false,
              reloadAll: false,
              reloadCurrent: false,
              reloadPrevious: false,
              history: !navigateOptions.initial,
              browserHistory: !navigateOptions.initial
            }));
          }
        }
      });
      return router;
    }
  }
  processRouteQueue.call(router, route, router.currentRoute, function() {
    if (route.route.modules) {
      app.loadModules(Array.isArray(route.route.modules) ? route.route.modules : [route.route.modules]).then(function() {
        resolve();
      }).catch(function() {
        reject();
      });
    } else {
      resolve();
    }
  }, function() {
    reject();
  }, "forward");
  return router;
}

// node_modules/framework7/esm/modules/router/tab.js
function tabLoad(tabRoute, loadOptions) {
  if (loadOptions === void 0) {
    loadOptions = {};
  }
  var router = this;
  var options = extend3({
    animate: router.params.animate,
    browserHistory: true,
    history: true,
    parentPageEl: null,
    preload: false,
    on: {}
  }, loadOptions);
  var currentRoute;
  var previousRoute;
  if (options.route) {
    if (!options.preload && options.route !== router.currentRoute) {
      previousRoute = router.previousRoute;
      router.currentRoute = options.route;
    }
    if (options.preload) {
      currentRoute = options.route;
      previousRoute = router.currentRoute;
    } else {
      currentRoute = router.currentRoute;
      if (!previousRoute)
        previousRoute = router.previousRoute;
    }
    if (router.params.browserHistory && options.browserHistory && !options.reloadPrevious) {
      history_default.replace(router.view.id, {
        url: options.route.url
      }, (router.params.browserHistoryRoot || "") + router.params.browserHistorySeparator + options.route.url);
    }
    if (options.history) {
      router.history[Math.max(router.history.length - 1, 0)] = options.route.url;
      router.saveHistory();
    }
  }
  var $parentPageEl = dom7_default(options.parentPageEl || router.currentPageEl);
  var tabEl;
  if ($parentPageEl.length && $parentPageEl.find("#" + tabRoute.id).length) {
    tabEl = $parentPageEl.find("#" + tabRoute.id).eq(0);
  } else if (router.view.selector) {
    tabEl = router.view.selector + " #" + tabRoute.id;
  } else {
    tabEl = "#" + tabRoute.id;
  }
  var tabShowResult = router.app.tab.show({
    tabEl,
    animate: options.animate,
    tabRoute: options.route
  });
  var $newTabEl = tabShowResult.$newTabEl, $oldTabEl = tabShowResult.$oldTabEl, animated = tabShowResult.animated, onTabsChanged = tabShowResult.onTabsChanged;
  if ($newTabEl && $newTabEl.parents(".page").length > 0 && options.route) {
    var tabParentPageData = $newTabEl.parents(".page")[0].f7Page;
    if (tabParentPageData && options.route) {
      tabParentPageData.route = options.route;
    }
  }
  function onTabLoaded(contentEl) {
    router.removeThemeElements($newTabEl);
    var tabEventTarget = $newTabEl;
    if (typeof contentEl !== "string")
      tabEventTarget = dom7_default(contentEl);
    tabEventTarget.trigger("tab:init tab:mounted", tabRoute);
    router.emit("tabInit tabMounted", $newTabEl[0], tabRoute);
    if ($oldTabEl && $oldTabEl.length) {
      if (animated) {
        onTabsChanged(function() {
          router.emit("routeChanged", router.currentRoute, router.previousRoute, router);
          if (router.params.unloadTabContent) {
            router.tabRemove($oldTabEl, $newTabEl, tabRoute);
          }
        });
      } else {
        router.emit("routeChanged", router.currentRoute, router.previousRoute, router);
        if (router.params.unloadTabContent) {
          router.tabRemove($oldTabEl, $newTabEl, tabRoute);
        }
      }
    }
  }
  if ($newTabEl[0].f7RouterTabLoaded) {
    if (!$oldTabEl || !$oldTabEl.length)
      return router;
    if (animated) {
      onTabsChanged(function() {
        router.emit("routeChanged", router.currentRoute, router.previousRoute, router);
      });
    } else {
      router.emit("routeChanged", router.currentRoute, router.previousRoute, router);
    }
    return router;
  }
  function loadTab(loadTabParams, loadTabOptions) {
    var url = loadTabParams.url, content = loadTabParams.content, el = loadTabParams.el, component = loadTabParams.component, componentUrl = loadTabParams.componentUrl;
    function resolve(contentEl) {
      router.allowPageChange = true;
      if (!contentEl)
        return;
      if (typeof contentEl === "string") {
        $newTabEl.html(contentEl);
      } else {
        $newTabEl.html("");
        if (contentEl.f7Component) {
          contentEl.f7Component.mount(function(componentEl) {
            $newTabEl.append(componentEl);
          });
        } else {
          $newTabEl.append(contentEl);
        }
      }
      $newTabEl[0].f7RouterTabLoaded = true;
      onTabLoaded(contentEl);
    }
    function reject() {
      router.allowPageChange = true;
      return router;
    }
    if (content) {
      resolve(content);
    } else if (el) {
      resolve(el);
    } else if (component || componentUrl) {
      try {
        router.tabComponentLoader({
          tabEl: $newTabEl[0],
          component,
          componentUrl,
          options: loadTabOptions,
          resolve,
          reject
        });
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (url) {
      if (router.xhrAbortController) {
        router.xhrAbortController.abort();
        router.xhrAbortController = false;
      }
      router.xhrRequest(url, loadTabOptions).then(function(tabContent) {
        resolve(tabContent);
      }).catch(function() {
        router.allowPageChange = true;
      });
    }
  }
  var hasContentLoadProp;
  "url content component el componentUrl".split(" ").forEach(function(tabLoadProp) {
    if (tabRoute[tabLoadProp]) {
      var _loadTab;
      hasContentLoadProp = true;
      loadTab((_loadTab = {}, _loadTab[tabLoadProp] = tabRoute[tabLoadProp], _loadTab), options);
    }
  });
  function asyncResolve(resolveParams, resolveOptions) {
    loadTab(resolveParams, extend3(options, resolveOptions));
  }
  function asyncReject() {
    router.allowPageChange = true;
  }
  if (tabRoute.async) {
    tabRoute.async.call(router, {
      router,
      to: currentRoute,
      from: previousRoute,
      resolve: asyncResolve,
      reject: asyncReject,
      app: router.app
    });
  } else if (tabRoute.asyncComponent) {
    asyncComponent(router, tabRoute.asyncComponent, asyncResolve, asyncReject);
  } else if (!hasContentLoadProp) {
    router.allowPageChange = true;
  }
  return router;
}
function tabRemove($oldTabEl, $newTabEl, tabRoute) {
  var router = this;
  var hasTabComponentChild;
  if ($oldTabEl[0]) {
    $oldTabEl[0].f7RouterTabLoaded = false;
    delete $oldTabEl[0].f7RouterTabLoaded;
  }
  $oldTabEl.children().each(function(tabChild) {
    if (tabChild.f7Component) {
      hasTabComponentChild = true;
      dom7_default(tabChild).trigger("tab:beforeremove", tabRoute);
      tabChild.f7Component.destroy();
    }
  });
  if (!hasTabComponentChild) {
    $oldTabEl.trigger("tab:beforeremove", tabRoute);
  }
  router.emit("tabBeforeRemove", $oldTabEl[0], $newTabEl[0], tabRoute);
  router.removeTabContent($oldTabEl[0], tabRoute);
}

// node_modules/framework7/esm/modules/router/modal.js
function modalLoad(modalType, route, loadOptions, direction) {
  if (loadOptions === void 0) {
    loadOptions = {};
  }
  var router = this;
  var app = router.app;
  var isPanel = modalType === "panel";
  var modalOrPanel = isPanel ? "panel" : "modal";
  var options = extend3({
    animate: router.params.animate,
    browserHistory: true,
    history: true,
    on: {},
    once: {}
  }, loadOptions);
  var modalParams = extend3({}, route.route[modalType]);
  var modalRoute = route.route;
  var routeCallback = function routeCallback2(modal, name) {
    var on3 = options.on, once3 = options.once;
    var callback;
    if (name === "open") {
      callback = on3.modalOpen || once3.modalOpen || on3.panelOpen || once3.panelOpen;
    }
    if (name === "close") {
      callback = on3.modalClose || once3.modalClose || on3.panelClose || once3.panelClose;
    }
    if (name === "closed") {
      callback = on3.modalClosed || once3.modalClosed || on3.panelClosed || once3.panelClosed;
    }
    if (callback)
      callback(modal);
  };
  function onModalLoaded() {
    var modal = app[modalType].create(modalParams);
    modalRoute.modalInstance = modal;
    var hasEl = modal.el;
    function closeOnSwipeBack() {
      modal.close();
    }
    modal.on(modalOrPanel + "Open", function() {
      if (!hasEl) {
        router.removeThemeElements(modal.el);
        modal.$el.trigger(modalType.toLowerCase() + ":init " + modalType.toLowerCase() + ":mounted", route, modal);
        router.emit((!isPanel ? "modalInit" : "") + " " + modalType + "Init " + modalType + "Mounted", modal.el, route, modal);
      }
      router.once("swipeBackMove", closeOnSwipeBack);
      routeCallback(modal, "open");
    });
    modal.on(modalOrPanel + "Close", function() {
      router.off("swipeBackMove", closeOnSwipeBack);
      if (!modal.closeByRouter) {
        router.back();
      }
      routeCallback(modal, "close");
    });
    modal.on(modalOrPanel + "Closed", function() {
      modal.$el.trigger(modalType.toLowerCase() + ":beforeremove", route, modal);
      modal.emit("" + (!isPanel ? "modalBeforeRemove " : "") + modalType + "BeforeRemove", modal.el, route, modal);
      var modalComponent = modal.el.f7Component;
      routeCallback(modal, "closed");
      if (modalComponent) {
        modalComponent.destroy();
      }
      nextTick2(function() {
        if (modalComponent || modalParams.component) {
          router.removeModal(modal.el);
        }
        modal.destroy();
        delete modal.route;
        delete modalRoute.modalInstance;
      });
    });
    if (options.route) {
      if (router.params.browserHistory && options.browserHistory) {
        history_default.push(router.view.id, {
          url: options.route.url,
          modal: modalType
        }, (router.params.browserHistoryRoot || "") + router.params.browserHistorySeparator + options.route.url);
      }
      if (options.route !== router.currentRoute) {
        modal.route = extend3(options.route, {
          modal
        });
        router.currentRoute = modal.route;
      }
      if (options.history && !options.reloadCurrent) {
        router.history.push(options.route.url);
        router.saveHistory();
      }
    }
    if (hasEl) {
      router.removeThemeElements(modal.el);
      modal.$el.trigger(modalType.toLowerCase() + ":init " + modalType.toLowerCase() + ":mounted", route, modal);
      router.emit(modalOrPanel + "Init " + modalType + "Init " + modalType + "Mounted", modal.el, route, modal);
    }
    modal.open(options.animate === false || options.animate === true ? options.animate : void 0);
  }
  function loadModal(loadModalParams, loadModalOptions) {
    var url = loadModalParams.url, content = loadModalParams.content, component = loadModalParams.component, componentUrl = loadModalParams.componentUrl;
    function resolve(contentEl) {
      if (contentEl) {
        if (typeof contentEl === "string") {
          modalParams.content = contentEl;
        } else if (contentEl.f7Component) {
          contentEl.f7Component.mount(function(componentEl) {
            modalParams.el = componentEl;
            app.$el.append(componentEl);
          });
        } else {
          modalParams.el = contentEl;
        }
        onModalLoaded();
      }
    }
    function reject() {
      router.allowPageChange = true;
      return router;
    }
    if (content) {
      resolve(content);
    } else if (component || componentUrl) {
      try {
        router.modalComponentLoader({
          rootEl: app.el,
          component,
          componentUrl,
          options: loadModalOptions,
          resolve,
          reject
        });
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (url) {
      if (router.xhrAbortController) {
        router.xhrAbortController.abort();
        router.xhrAbortController = false;
      }
      router.xhrRequest(url, loadModalOptions).then(function(modalContent) {
        modalParams.content = modalContent;
        onModalLoaded();
      }).catch(function() {
        router.allowPageChange = true;
      });
    } else {
      onModalLoaded();
    }
  }
  var foundLoadProp;
  "url content component el componentUrl template".split(" ").forEach(function(modalLoadProp) {
    if (modalParams[modalLoadProp] && !foundLoadProp) {
      var _loadModal;
      foundLoadProp = true;
      loadModal((_loadModal = {}, _loadModal[modalLoadProp] = modalParams[modalLoadProp], _loadModal), options);
    }
  });
  if (!foundLoadProp && modalType === "actions") {
    onModalLoaded();
  }
  function asyncResolve(resolveParams, resolveOptions) {
    loadModal(resolveParams, extend3(options, resolveOptions));
  }
  function asyncReject() {
    router.allowPageChange = true;
  }
  if (modalParams.async) {
    modalParams.async.call(router, {
      router,
      to: options.route,
      from: router.currentRoute,
      resolve: asyncResolve,
      reject: asyncReject,
      direction,
      app
    });
  }
  if (modalParams.asyncComponent) {
    asyncComponent(router, modalParams.asyncComponent, asyncResolve, asyncReject);
  }
  return router;
}
function modalRemove(modal) {
  extend3(modal, {
    closeByRouter: true
  });
  modal.close();
}

// node_modules/framework7/esm/modules/router/back.js
function backward(router, el, backwardOptions) {
  var device2 = getDevice2();
  var document2 = getDocument();
  var $el = dom7_default(el);
  var app = router.app;
  var view = router.view;
  var options = extend3({
    animate: router.params.animate,
    browserHistory: true,
    replaceState: false
  }, backwardOptions);
  var masterDetailEnabled = router.params.masterDetailBreakpoint > 0;
  var isMaster = masterDetailEnabled && options.route && options.route.route && (options.route.route.master === true || typeof options.route.route.master === "function" && options.route.route.master(app, router));
  var masterPageEl;
  var masterPageRemoved;
  var dynamicNavbar = router.dynamicNavbar;
  var $newPage = $el;
  var $oldPage = router.$el.children(".page-current");
  var initialPreload = $oldPage.length === 0 && options.preload;
  var currentIsMaster = masterDetailEnabled && $oldPage.hasClass("page-master");
  if ($newPage.length) {
    router.removeThemeElements($newPage);
  }
  var $navbarsEl;
  var $newNavbarEl;
  var $oldNavbarEl;
  if (dynamicNavbar) {
    $newNavbarEl = $newPage.children(".navbar");
    $navbarsEl = router.$navbarsEl;
    if ($newNavbarEl.length === 0 && $newPage[0] && $newPage[0].f7Page) {
      $newNavbarEl = $newPage[0].f7Page.$navbarEl;
    }
    $oldNavbarEl = $navbarsEl.find(".navbar-current");
  }
  router.allowPageChange = false;
  if ($newPage.length === 0 || $oldPage.length === 0 && !options.preload) {
    router.allowPageChange = true;
    return router;
  }
  router.removeThemeElements($newPage);
  if (options.route && options.route.route && options.route.route.keepAlive && !options.route.route.keepAliveData) {
    options.route.route.keepAliveData = {
      pageEl: $el[0]
    };
  }
  var isDetail;
  var isDetailRoot;
  if (masterDetailEnabled) {
    var $pagesInView = router.$el.children(".page:not(.stacked)").filter(function(pageInView) {
      return pageInView !== $newPage[0];
    });
    for (var i = 0; i < $pagesInView.length; i += 1) {
      if (!masterPageEl && $pagesInView[i].classList.contains("page-master")) {
        masterPageEl = $pagesInView[i];
        continue;
      }
    }
    isDetail = !isMaster && masterPageEl && router.history.indexOf(options.route.url) > router.history.indexOf(masterPageEl.f7Page.route.url);
    if (!isDetail && !isMaster && masterPageEl && masterPageEl.f7Page && options.route.route.masterRoute) {
      isDetail = options.route.route.masterRoute.path === masterPageEl.f7Page.route.route.path;
    }
  }
  if (isDetail && masterPageEl && masterPageEl.f7Page) {
    isDetailRoot = router.history.indexOf(options.route.url) - router.history.indexOf(masterPageEl.f7Page.route.url) === 1;
  }
  $newPage.addClass("page-" + (initialPreload ? "current" : "previous") + (isMaster ? " page-master" : "") + (isDetail ? " page-master-detail" : "") + (isDetailRoot ? " page-master-detail-root" : "")).removeClass("stacked").removeAttr("aria-hidden").trigger("page:unstack").trigger("page:position", {
    position: initialPreload ? "current" : "previous"
  });
  router.emit("pageUnstack", $newPage[0]);
  router.emit("pagePosition", $newPage[0], initialPreload ? "current" : "previous");
  if (isMaster || isDetail) {
    $newPage.trigger("page:role", {
      role: isMaster ? "master" : "detail",
      root: !!isDetailRoot
    });
    router.emit("pageRole", $newPage[0], {
      role: isMaster ? "master" : "detail",
      detailRoot: !!isDetailRoot
    });
  }
  if (dynamicNavbar && $newNavbarEl.length > 0) {
    $newNavbarEl.addClass("navbar-" + (initialPreload ? "current" : "previous") + (isMaster ? " navbar-master" : "") + (isDetail ? " navbar-master-detail" : "") + (isDetailRoot ? " navbar-master-detail-root" : "")).removeClass("stacked").removeAttr("aria-hidden");
    $newNavbarEl.trigger("navbar:position", {
      position: initialPreload ? "current" : "previous"
    });
    router.emit("navbarPosition", $newNavbarEl[0], initialPreload ? "current" : "previous");
    if (isMaster || isDetailRoot) {
      router.emit("navbarRole", $newNavbarEl[0], {
        role: isMaster ? "master" : "detail",
        detailRoot: !!isDetailRoot
      });
    }
  }
  var backIndex;
  if (options.force) {
    if ($oldPage.prev(".page-previous:not(.stacked)").length > 0 || $oldPage.prev(".page-previous").length === 0) {
      if (router.history.indexOf(options.route.url) >= 0) {
        backIndex = router.history.length - router.history.indexOf(options.route.url) - 1;
        router.history = router.history.slice(0, router.history.indexOf(options.route.url) + 2);
        view.history = router.history;
      } else if (router.history[[router.history.length - 2]]) {
        router.history[router.history.length - 2] = options.route.url;
      } else {
        router.history.unshift(router.url);
      }
      if (backIndex && router.params.stackPages) {
        $oldPage.prevAll(".page-previous").each(function(pageToRemove) {
          var $pageToRemove2 = dom7_default(pageToRemove);
          var $navbarToRemove2;
          if (dynamicNavbar) {
            $navbarToRemove2 = dom7_default(app.navbar.getElByPage($pageToRemove2));
          }
          if ($pageToRemove2[0] !== $newPage[0] && $pageToRemove2.index() > $newPage.index()) {
            if (router.initialPages.indexOf($pageToRemove2[0]) >= 0) {
              $pageToRemove2.addClass("stacked");
              $pageToRemove2.trigger("page:stack");
              router.emit("pageStack", $pageToRemove2[0]);
              if (dynamicNavbar) {
                $navbarToRemove2.addClass("stacked");
              }
            } else {
              router.pageCallback("beforeRemove", $pageToRemove2, $navbarToRemove2, "previous", void 0, options);
              if ($pageToRemove2[0] === masterPageEl) {
                masterPageRemoved = true;
              }
              router.removePage($pageToRemove2);
              if (dynamicNavbar && $navbarToRemove2.length > 0) {
                router.removeNavbar($navbarToRemove2);
              }
            }
          }
        });
      } else {
        var $pageToRemove = $oldPage.prev(".page-previous:not(.stacked)");
        var $navbarToRemove;
        if (dynamicNavbar) {
          $navbarToRemove = dom7_default(app.navbar.getElByPage($pageToRemove));
        }
        if (router.params.stackPages && router.initialPages.indexOf($pageToRemove[0]) >= 0) {
          $pageToRemove.addClass("stacked");
          $pageToRemove.trigger("page:stack");
          router.emit("pageStack", $pageToRemove[0]);
          $navbarToRemove.addClass("stacked");
        } else if ($pageToRemove.length > 0) {
          router.pageCallback("beforeRemove", $pageToRemove, $navbarToRemove, "previous", void 0, options);
          if ($pageToRemove[0] === masterPageEl) {
            masterPageRemoved = true;
          }
          router.removePage($pageToRemove);
          if (dynamicNavbar && $navbarToRemove.length) {
            router.removeNavbar($navbarToRemove);
          }
        }
      }
    }
  }
  var newPageInDom = $newPage.parents(document2).length > 0;
  var f7Component = $newPage[0].f7Component;
  function insertPage() {
    if (initialPreload) {
      if (!newPageInDom && f7Component) {
        f7Component.mount(function(componentEl) {
          router.$el.append(componentEl);
        });
      } else {
        router.$el.append($newPage);
      }
    }
    if ($newPage.next($oldPage).length === 0) {
      if (!newPageInDom && f7Component) {
        f7Component.mount(function(componentEl) {
          dom7_default(componentEl).insertBefore($oldPage);
        });
      } else {
        $newPage.insertBefore($oldPage);
      }
    }
    if (dynamicNavbar && $newNavbarEl.length) {
      if ($newNavbarEl.find(".title-large").length) {
        $newNavbarEl.addClass("navbar-large");
      }
      $newNavbarEl.insertBefore($oldNavbarEl);
      if ($oldNavbarEl.length > 0) {
        $newNavbarEl.insertBefore($oldNavbarEl);
      } else {
        if (!router.$navbarsEl.parents(document2).length) {
          router.$el.prepend(router.$navbarsEl);
        }
        $navbarsEl.append($newNavbarEl);
      }
    }
    if (!newPageInDom) {
      router.pageCallback("mounted", $newPage, $newNavbarEl, "previous", "current", options, $oldPage);
    } else if (options.route && options.route.route && options.route.route.keepAlive && !$newPage[0].f7PageMounted) {
      $newPage[0].f7PageMounted = true;
      router.pageCallback("mounted", $newPage, $newNavbarEl, "previous", "current", options, $oldPage);
    }
  }
  if (options.preload) {
    insertPage();
    if (options.route.route.tab) {
      router.tabLoad(options.route.route.tab, extend3({}, options, {
        history: false,
        browserHistory: false,
        preload: true
      }));
    }
    if (isMaster) {
      $newPage.removeClass("page-master-stacked").trigger("page:masterunstack");
      router.emit("pageMasterUnstack", $newPage[0]);
      if (dynamicNavbar) {
        dom7_default(app.navbar.getElByPage($newPage)).removeClass("navbar-master-stacked");
        router.emit("navbarMasterUnstack", app.navbar.getElByPage($newPage));
      }
    }
    router.pageCallback("init", $newPage, $newNavbarEl, "previous", "current", options, $oldPage);
    if (initialPreload) {
      router.pageCallback("beforeIn", $newPage, $newNavbarEl, "current", void 0, options);
      router.pageCallback("afterIn", $newPage, $newNavbarEl, "current", void 0, options);
    }
    var $previousPages = $newPage.prevAll(".page-previous:not(.stacked):not(.page-master)");
    if ($previousPages.length > 0) {
      $previousPages.each(function(pageToRemove) {
        var $pageToRemove2 = dom7_default(pageToRemove);
        var $navbarToRemove2;
        if (dynamicNavbar) {
          $navbarToRemove2 = dom7_default(app.navbar.getElByPage($pageToRemove2));
        }
        if (router.params.stackPages && router.initialPages.indexOf(pageToRemove) >= 0) {
          $pageToRemove2.addClass("stacked");
          $pageToRemove2.trigger("page:stack");
          router.emit("pageStack", $pageToRemove2[0]);
          if (dynamicNavbar) {
            $navbarToRemove2.addClass("stacked");
          }
        } else {
          router.pageCallback("beforeRemove", $pageToRemove2, $navbarToRemove2, "previous", void 0);
          router.removePage($pageToRemove2);
          if (dynamicNavbar && $navbarToRemove2.length) {
            router.removeNavbar($navbarToRemove2);
          }
        }
      });
    }
    router.allowPageChange = true;
    return router;
  }
  if (!(device2.ie || device2.edge || device2.firefox && !device2.ios)) {
    if (router.params.browserHistory && options.browserHistory) {
      if (options.replaceState) {
        var browserHistoryRoot = router.params.browserHistoryRoot || "";
        history_default.replace(view.id, {
          url: options.route.url
        }, browserHistoryRoot + router.params.browserHistorySeparator + options.route.url);
      } else if (backIndex) {
        history_default.go(-backIndex);
      } else {
        history_default.back();
      }
    }
  }
  if (options.replaceState) {
    router.history[router.history.length - 1] = options.route.url;
  } else {
    if (router.history.length === 1) {
      router.history.unshift(router.url);
    }
    router.history.pop();
  }
  router.saveHistory();
  router.currentPageEl = $newPage[0];
  if (dynamicNavbar && $newNavbarEl.length) {
    router.currentNavbarEl = $newNavbarEl[0];
  } else {
    delete router.currentNavbarEl;
  }
  router.currentRoute = options.route;
  if (device2.ie || device2.edge || device2.firefox && !device2.ios) {
    if (router.params.browserHistory && options.browserHistory) {
      if (options.replaceState) {
        var _browserHistoryRoot = router.params.browserHistoryRoot || "";
        history_default.replace(view.id, {
          url: options.route.url
        }, _browserHistoryRoot + router.params.browserHistorySeparator + options.route.url);
      } else if (backIndex) {
        history_default.go(-backIndex);
      } else {
        history_default.back();
      }
    }
  }
  insertPage();
  if (options.route.route.tab) {
    router.tabLoad(options.route.route.tab, extend3({}, options, {
      history: false,
      browserHistory: false
    }));
  }
  if (masterDetailEnabled && (currentIsMaster || masterPageRemoved)) {
    view.checkMasterDetailBreakpoint(false);
  }
  router.pageCallback("init", $newPage, $newNavbarEl, "previous", "current", options, $oldPage);
  router.pageCallback("beforeOut", $oldPage, $oldNavbarEl, "current", "next", options);
  router.pageCallback("beforeIn", $newPage, $newNavbarEl, "previous", "current", options);
  function afterAnimation() {
    router.setPagePosition($newPage, "current", false);
    router.setPagePosition($oldPage, "next", true);
    if (dynamicNavbar) {
      router.setNavbarPosition($newNavbarEl, "current", false);
      router.setNavbarPosition($oldNavbarEl, "next", true);
    }
    router.pageCallback("afterOut", $oldPage, $oldNavbarEl, "current", "next", options);
    router.pageCallback("afterIn", $newPage, $newNavbarEl, "previous", "current", options);
    if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
      $oldPage.addClass("stacked");
      $oldPage.trigger("page:stack");
      router.emit("pageStack", $oldPage[0]);
      if (dynamicNavbar) {
        $oldNavbarEl.addClass("stacked");
      }
    } else {
      router.pageCallback("beforeRemove", $oldPage, $oldNavbarEl, "next", void 0, options);
      router.removePage($oldPage);
      if (dynamicNavbar && $oldNavbarEl.length) {
        router.removeNavbar($oldNavbarEl);
      }
    }
    router.allowPageChange = true;
    router.emit("routeChanged", router.currentRoute, router.previousRoute, router);
    var preloadPreviousPage = router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"];
    if (preloadPreviousPage && router.history[router.history.length - 2] && !isMaster) {
      router.back(router.history[router.history.length - 2], {
        preload: true
      });
    }
    if (router.params.browserHistory) {
      history_default.clearRouterQueue();
    }
  }
  function setPositionClasses() {
    router.setPagePosition($oldPage, "current");
    router.setPagePosition($newPage, "previous", false);
    if (dynamicNavbar) {
      router.setNavbarPosition($oldNavbarEl, "current");
      router.setNavbarPosition($newNavbarEl, "previous", false);
    }
  }
  if (options.animate && !(currentIsMaster && app.width >= router.params.masterDetailBreakpoint)) {
    var transition2 = router.params.transition;
    if ($oldPage[0] && $oldPage[0].f7PageTransition) {
      transition2 = $oldPage[0].f7PageTransition;
      delete $oldPage[0].f7PageTransition;
    }
    if (options.transition)
      transition2 = options.transition;
    if (!transition2 && router.previousRoute && router.previousRoute.route) {
      transition2 = router.previousRoute.route.transition;
    }
    if (!transition2 && router.previousRoute && router.previousRoute.route && router.previousRoute.route.options) {
      transition2 = router.previousRoute.route.options.transition;
    }
    setPositionClasses();
    router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, "backward", transition2, function() {
      afterAnimation();
    });
  } else {
    afterAnimation();
  }
  return router;
}
function loadBack(router, backParams, backOptions, ignorePageChange) {
  if (!router.allowPageChange && !ignorePageChange)
    return router;
  var params = backParams;
  var options = backOptions;
  var url = params.url, content = params.content, el = params.el, pageName = params.pageName, component = params.component, componentUrl = params.componentUrl;
  if (options.route.url && router.url === options.route.url && !(options.reloadCurrent || options.reloadPrevious) && !router.params.allowDuplicateUrls) {
    return false;
  }
  if (!options.route && url) {
    options.route = router.parseRouteUrl(url);
  }
  function resolve(pageEl, newOptions) {
    return backward(router, pageEl, extend3(options, newOptions));
  }
  function reject() {
    router.allowPageChange = true;
    return router;
  }
  if (url || componentUrl || component) {
    router.allowPageChange = false;
  }
  if (content) {
    backward(router, router.getPageEl(content), options);
  } else if (el) {
    backward(router, router.getPageEl(el), options);
  } else if (pageName) {
    backward(router, router.$el.children('.page[data-name="' + pageName + '"]').eq(0), options);
  } else if (component || componentUrl) {
    try {
      router.pageComponentLoader({
        routerEl: router.el,
        component,
        componentUrl,
        options,
        resolve,
        reject
      });
    } catch (err) {
      router.allowPageChange = true;
      throw err;
    }
  } else if (url) {
    if (router.xhrAbortController) {
      router.xhrAbortController.abort();
      router.xhrAbortController = false;
    }
    router.xhrRequest(url, options).then(function(pageContent) {
      backward(router, router.getPageEl(pageContent), options);
    }).catch(function() {
      router.allowPageChange = true;
    });
  }
  return router;
}
function back2() {
  var router = this;
  var device2 = getDevice2();
  if (router.swipeBackActive)
    return router;
  var navigateUrl;
  var navigateOptions;
  var route;
  if (typeof (arguments.length <= 0 ? void 0 : arguments[0]) === "object") {
    navigateOptions = (arguments.length <= 0 ? void 0 : arguments[0]) || {};
  } else {
    navigateUrl = arguments.length <= 0 ? void 0 : arguments[0];
    navigateOptions = (arguments.length <= 1 ? void 0 : arguments[1]) || {};
  }
  var _navigateOptions = navigateOptions, name = _navigateOptions.name, params = _navigateOptions.params, query = _navigateOptions.query;
  if (name) {
    navigateUrl = router.generateUrl({
      name,
      params,
      query
    });
    if (navigateUrl) {
      return router.back(navigateUrl, extend3({}, navigateOptions, {
        name: null,
        params: null,
        query: null
      }));
    }
    return router;
  }
  var app = router.app;
  appRouterCheck(router, "back");
  var currentRouteIsModal = router.currentRoute.modal;
  var modalType;
  if (!currentRouteIsModal) {
    "popup popover sheet loginScreen actions customModal panel".split(" ").forEach(function(modalLoadProp) {
      if (router.currentRoute.route[modalLoadProp]) {
        currentRouteIsModal = true;
        modalType = modalLoadProp;
      }
    });
  }
  if (currentRouteIsModal && !navigateOptions.preload) {
    var modalToClose = router.currentRoute.modal || router.currentRoute.route.modalInstance || app[modalType].get();
    var previousUrl = router.history[router.history.length - 2];
    var previousRoute;
    if (modalToClose && modalToClose.$el) {
      var prevOpenedModals = modalToClose.$el.prevAll(".modal-in");
      if (prevOpenedModals.length && prevOpenedModals[0].f7Modal) {
        var modalEl = prevOpenedModals[0];
        if (!router.$el.parents(modalEl).length) {
          previousRoute = modalEl.f7Modal.route;
        }
      }
    }
    if (!previousRoute) {
      previousRoute = router.findMatchingRoute(previousUrl);
    }
    if (!previousRoute && previousUrl) {
      previousRoute = {
        url: previousUrl,
        path: previousUrl.split("?")[0],
        query: parseUrlQuery(previousUrl),
        route: {
          path: previousUrl.split("?")[0],
          url: previousUrl
        }
      };
    }
    if (!navigateUrl || navigateUrl.replace(/[# ]/g, "").trim().length === 0) {
      if (!previousRoute || !modalToClose) {
        return router;
      }
    }
    var forceOtherUrl = navigateOptions.force && previousRoute && navigateUrl;
    if (previousRoute && modalToClose) {
      var isBrokenBrowserHistory = device2.ie || device2.edge || device2.firefox && !device2.ios;
      var needHistoryBack = router.params.browserHistory && navigateOptions.browserHistory !== false;
      var currentRouteWithoutBrowserHistory = router.currentRoute && router.currentRoute.route && router.currentRoute.route.options && router.currentRoute.route.options.browserHistory === false;
      if (needHistoryBack && !isBrokenBrowserHistory && !currentRouteWithoutBrowserHistory) {
        history_default.back();
      }
      router.currentRoute = previousRoute;
      router.history.pop();
      router.saveHistory();
      if (needHistoryBack && isBrokenBrowserHistory && !currentRouteWithoutBrowserHistory) {
        history_default.back();
      }
      router.modalRemove(modalToClose);
      if (forceOtherUrl) {
        router.navigate(navigateUrl, {
          reloadCurrent: true
        });
      }
    } else if (modalToClose) {
      router.modalRemove(modalToClose);
      if (navigateUrl) {
        router.navigate(navigateUrl, {
          reloadCurrent: true
        });
      }
    }
    return router;
  }
  var $previousPage = router.$el.children(".page-current").prevAll(".page-previous:not(.page-master)").eq(0);
  var skipMaster;
  if (router.params.masterDetailBreakpoint > 0) {
    var classes = [];
    router.$el.children(".page").each(function(pageEl) {
      classes.push(pageEl.className);
    });
    var $previousMaster = router.$el.children(".page-current").prevAll(".page-master").eq(0);
    if ($previousMaster.length) {
      var expectedPreviousPageUrl = router.history[router.history.length - 2];
      var expectedPreviousPageRoute = router.findMatchingRoute(expectedPreviousPageUrl);
      if (expectedPreviousPageRoute && $previousMaster[0].f7Page && expectedPreviousPageRoute.route === $previousMaster[0].f7Page.route.route) {
        $previousPage = $previousMaster;
        if (!navigateOptions.preload) {
          skipMaster = app.width >= router.params.masterDetailBreakpoint;
        }
      }
    }
  }
  if (!navigateOptions.force && $previousPage.length && !skipMaster) {
    if (router.params.browserHistory && $previousPage[0].f7Page && router.history[router.history.length - 2] !== $previousPage[0].f7Page.route.url) {
      router.back(router.history[router.history.length - 2], extend3(navigateOptions, {
        force: true
      }));
      return router;
    }
    var previousPageRoute = $previousPage[0].f7Page.route;
    processRouteQueue.call(router, previousPageRoute, router.currentRoute, function() {
      loadBack(router, {
        el: $previousPage
      }, extend3(navigateOptions, {
        route: previousPageRoute
      }));
    }, function() {
    }, "backward");
    return router;
  }
  if (navigateUrl === "#") {
    navigateUrl = void 0;
  }
  if (navigateUrl && navigateUrl[0] !== "/" && navigateUrl.indexOf("#") !== 0) {
    navigateUrl = ((router.path || "/") + navigateUrl).replace("//", "/");
  }
  if (!navigateUrl && router.history.length > 1) {
    navigateUrl = router.history[router.history.length - 2];
  }
  if (skipMaster && !navigateOptions.force && router.history[router.history.length - 3]) {
    return router.back(router.history[router.history.length - 3], extend3({}, navigateOptions || {}, {
      force: true,
      animate: false
    }));
  }
  if (skipMaster && !navigateOptions.force) {
    return router;
  }
  route = router.findMatchingRoute(navigateUrl);
  if (!route) {
    if (navigateUrl) {
      route = {
        url: navigateUrl,
        path: navigateUrl.split("?")[0],
        query: parseUrlQuery(navigateUrl),
        route: {
          path: navigateUrl.split("?")[0],
          url: navigateUrl
        }
      };
    }
  }
  if (!route) {
    return router;
  }
  if (route.route.redirect) {
    return redirect.call(router, "backward", route, navigateOptions);
  }
  var options = {};
  if (route.route.options) {
    extend3(options, route.route.options, navigateOptions);
  } else {
    extend3(options, navigateOptions);
  }
  options.route = route;
  var backForceLoaded;
  if (options.force && router.params.stackPages) {
    router.$el.children(".page-previous.stacked").each(function(pageEl) {
      if (pageEl.f7Page && pageEl.f7Page.route && pageEl.f7Page.route.url === route.url) {
        backForceLoaded = true;
        loadBack(router, {
          el: pageEl
        }, options);
      }
    });
    if (backForceLoaded) {
      return router;
    }
  }
  function resolve() {
    var routerLoaded = false;
    if (route.route.keepAlive && route.route.keepAliveData) {
      loadBack(router, {
        el: route.route.keepAliveData.pageEl
      }, options);
      routerLoaded = true;
    }
    "url content component pageName el componentUrl".split(" ").forEach(function(pageLoadProp) {
      if (route.route[pageLoadProp] && !routerLoaded) {
        var _loadBack;
        routerLoaded = true;
        loadBack(router, (_loadBack = {}, _loadBack[pageLoadProp] = route.route[pageLoadProp], _loadBack), options);
      }
    });
    if (routerLoaded)
      return;
    function asyncResolve(resolveParams, resolveOptions) {
      router.allowPageChange = false;
      loadBack(router, resolveParams, extend3(options, resolveOptions), true);
    }
    function asyncReject() {
      router.allowPageChange = true;
    }
    if (route.route.async) {
      router.allowPageChange = false;
      route.route.async.call(router, {
        router,
        to: route,
        from: router.currentRoute,
        resolve: asyncResolve,
        reject: asyncReject,
        direction: "backward",
        app
      });
    }
    if (route.route.asyncComponent) {
      asyncComponent(router, route.route.asyncComponent, asyncResolve, asyncReject);
    }
  }
  function reject() {
    router.allowPageChange = true;
  }
  if (options.preload) {
    resolve();
  } else {
    processRouteQueue.call(router, route, router.currentRoute, function() {
      if (route.route.modules) {
        app.loadModules(Array.isArray(route.route.modules) ? route.route.modules : [route.route.modules]).then(function() {
          resolve();
        }).catch(function() {
          reject();
        });
      } else {
        resolve();
      }
    }, function() {
      reject();
    }, "backward");
  }
  return router;
}

// node_modules/framework7/esm/modules/router/clear-previous-history.js
function clearPreviousPages(router) {
  appRouterCheck(router, "clearPreviousPages");
  var app = router.app;
  var dynamicNavbar = router.dynamicNavbar;
  var $pagesToRemove = router.$el.children(".page").filter(function(pageInView) {
    if (router.currentRoute && (router.currentRoute.modal || router.currentRoute.panel))
      return true;
    return pageInView !== router.currentPageEl;
  });
  $pagesToRemove.each(function(pageEl) {
    var $oldPageEl = dom7_default(pageEl);
    var $oldNavbarEl = dom7_default(app.navbar.getElByPage($oldPageEl));
    if (router.params.stackPages && router.initialPages.indexOf($oldPageEl[0]) >= 0) {
      $oldPageEl.addClass("stacked");
      if (dynamicNavbar) {
        $oldNavbarEl.addClass("stacked");
      }
    } else {
      router.pageCallback("beforeRemove", $oldPageEl, $oldNavbarEl, "previous", void 0, {});
      router.removePage($oldPageEl);
      if (dynamicNavbar && $oldNavbarEl.length) {
        router.removeNavbar($oldNavbarEl);
      }
    }
  });
}
function clearPreviousHistory() {
  var router = this;
  appRouterCheck(router, "clearPreviousHistory");
  var url = router.history[router.history.length - 1];
  clearPreviousPages(router);
  router.history = [url];
  router.view.history = [url];
  router.saveHistory();
}

// node_modules/framework7/esm/modules/router/router-class.js
function _assertThisInitialized6(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _inheritsLoose6(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var Router = function(_Framework7Class) {
  _inheritsLoose6(Router2, _Framework7Class);
  function Router2(app, view) {
    var _this;
    _this = _Framework7Class.call(this, {}, [typeof view === "undefined" ? app : view]) || this;
    var router = _assertThisInitialized6(_this);
    router.isAppRouter = typeof view === "undefined";
    if (router.isAppRouter) {
      extend3(false, router, {
        app,
        params: app.params.view,
        routes: app.routes || [],
        cache: app.cache
      });
    } else {
      extend3(false, router, {
        app,
        view,
        viewId: view.id,
        id: view.params.routerId,
        params: view.params,
        routes: view.routes,
        history: view.history,
        scrollHistory: view.scrollHistory,
        cache: app.cache,
        dynamicNavbar: app.theme === "ios" && view.params.iosDynamicNavbar,
        initialPages: [],
        initialNavbars: []
      });
    }
    router.useModules();
    router.allowPageChange = true;
    var currentRoute = {};
    var previousRoute = {};
    Object.defineProperty(router, "currentRoute", {
      enumerable: true,
      configurable: true,
      set: function set(newRoute) {
        if (newRoute === void 0) {
          newRoute = {};
        }
        previousRoute = extend3({}, currentRoute);
        currentRoute = newRoute;
        if (!currentRoute)
          return;
        router.url = currentRoute.url;
        router.emit("routeChange", newRoute, previousRoute, router);
      },
      get: function get2() {
        return currentRoute;
      }
    });
    Object.defineProperty(router, "previousRoute", {
      enumerable: true,
      configurable: true,
      get: function get2() {
        return previousRoute;
      },
      set: function set(newRoute) {
        previousRoute = newRoute;
      }
    });
    return router || _assertThisInitialized6(_this);
  }
  var _proto = Router2.prototype;
  _proto.mount = function mount() {
    var router = this;
    var view = router.view;
    var document2 = getDocument();
    extend3(false, router, {
      tempDom: document2.createElement("div"),
      $el: view.$el,
      el: view.el,
      $navbarsEl: view.$navbarsEl,
      navbarsEl: view.navbarsEl
    });
    router.emit("local::mount routerMount", router);
  };
  _proto.animatableNavElements = function animatableNavElements($newNavbarEl, $oldNavbarEl, toLarge, fromLarge, direction) {
    var router = this;
    var dynamicNavbar = router.dynamicNavbar;
    var animateIcon = router.params.iosAnimateNavbarBackIcon;
    var newNavEls;
    var oldNavEls;
    function animatableNavEl($el, $navbarInner) {
      var isSliding = $el.hasClass("sliding") || $navbarInner.hasClass("sliding");
      var isSubnavbar = $el.hasClass("subnavbar");
      var needsOpacityTransition = isSliding ? !isSubnavbar : true;
      var $iconEl = $el.find(".back .icon");
      var isIconLabel;
      if (isSliding && animateIcon && $el.hasClass("left") && $iconEl.length > 0 && $iconEl.next("span").length) {
        $el = $iconEl.next("span");
        isIconLabel = true;
      }
      return {
        $el,
        isIconLabel,
        leftOffset: $el[0].f7NavbarLeftOffset,
        rightOffset: $el[0].f7NavbarRightOffset,
        isSliding,
        isSubnavbar,
        needsOpacityTransition
      };
    }
    if (dynamicNavbar) {
      newNavEls = [];
      oldNavEls = [];
      $newNavbarEl.children(".navbar-inner").children(".left, .right, .title, .subnavbar").each(function(navEl) {
        var $navEl = dom7_default(navEl);
        if ($navEl.hasClass("left") && fromLarge && direction === "forward")
          return;
        if ($navEl.hasClass("title") && toLarge)
          return;
        newNavEls.push(animatableNavEl($navEl, $newNavbarEl.children(".navbar-inner")));
      });
      if (!($oldNavbarEl.hasClass("navbar-master") && router.params.masterDetailBreakpoint > 0 && router.app.width >= router.params.masterDetailBreakpoint)) {
        $oldNavbarEl.children(".navbar-inner").children(".left, .right, .title, .subnavbar").each(function(navEl) {
          var $navEl = dom7_default(navEl);
          if ($navEl.hasClass("left") && toLarge && !fromLarge && direction === "forward")
            return;
          if ($navEl.hasClass("left") && toLarge && direction === "backward")
            return;
          if ($navEl.hasClass("title") && fromLarge) {
            return;
          }
          oldNavEls.push(animatableNavEl($navEl, $oldNavbarEl.children(".navbar-inner")));
        });
      }
      [oldNavEls, newNavEls].forEach(function(navEls) {
        navEls.forEach(function(navEl) {
          var n = navEl;
          var isSliding = navEl.isSliding, $el = navEl.$el;
          var otherEls = navEls === oldNavEls ? newNavEls : oldNavEls;
          if (!(isSliding && $el.hasClass("title") && otherEls))
            return;
          otherEls.forEach(function(otherNavEl) {
            if (otherNavEl.isIconLabel) {
              var iconTextEl = otherNavEl.$el[0];
              n.leftOffset += iconTextEl ? iconTextEl.offsetLeft || 0 : 0;
            }
          });
        });
      });
    }
    return {
      newNavEls,
      oldNavEls
    };
  };
  _proto.animate = function animate2($oldPageEl, $newPageEl, $oldNavbarEl, $newNavbarEl, direction, transition2, callback) {
    var router = this;
    if (router.params.animateCustom) {
      router.params.animateCustom.apply(router, [$oldPageEl, $newPageEl, $oldNavbarEl, $newNavbarEl, direction, callback]);
      return;
    }
    var dynamicNavbar = router.dynamicNavbar;
    var ios = router.app.theme === "ios";
    if (transition2) {
      var routerCustomTransitionClass = "router-transition-custom router-transition-" + transition2 + "-" + direction;
      var onCustomTransitionDone = function onCustomTransitionDone2() {
        router.$el.removeClass(routerCustomTransitionClass);
        if (dynamicNavbar && router.$navbarsEl.length) {
          if ($newNavbarEl) {
            router.$navbarsEl.prepend($newNavbarEl);
          }
          if ($oldNavbarEl) {
            router.$navbarsEl.prepend($oldNavbarEl);
          }
        }
        if (callback)
          callback();
      };
      (direction === "forward" ? $newPageEl : $oldPageEl).animationEnd(onCustomTransitionDone);
      if (dynamicNavbar) {
        if ($newNavbarEl && $newPageEl) {
          router.setNavbarPosition($newNavbarEl, "");
          $newNavbarEl.removeClass("navbar-next navbar-previous navbar-current");
          $newPageEl.prepend($newNavbarEl);
        }
        if ($oldNavbarEl && $oldPageEl) {
          router.setNavbarPosition($oldNavbarEl, "");
          $oldNavbarEl.removeClass("navbar-next navbar-previous navbar-current");
          $oldPageEl.prepend($oldNavbarEl);
        }
      }
      router.$el.addClass(routerCustomTransitionClass);
      return;
    }
    var routerTransitionClass = "router-transition-" + direction + " router-transition";
    var newNavEls;
    var oldNavEls;
    var fromLarge;
    var toLarge;
    var toDifferent;
    var oldIsLarge;
    var newIsLarge;
    if (ios && dynamicNavbar) {
      var betweenMasterAndDetail = router.params.masterDetailBreakpoint > 0 && router.app.width >= router.params.masterDetailBreakpoint && ($oldNavbarEl.hasClass("navbar-master") && $newNavbarEl.hasClass("navbar-master-detail") || $oldNavbarEl.hasClass("navbar-master-detail") && $newNavbarEl.hasClass("navbar-master"));
      if (!betweenMasterAndDetail) {
        oldIsLarge = $oldNavbarEl && $oldNavbarEl.hasClass("navbar-large");
        newIsLarge = $newNavbarEl && $newNavbarEl.hasClass("navbar-large");
        fromLarge = oldIsLarge && !$oldNavbarEl.hasClass("navbar-large-collapsed");
        toLarge = newIsLarge && !$newNavbarEl.hasClass("navbar-large-collapsed");
        toDifferent = fromLarge && !toLarge || toLarge && !fromLarge;
      }
      var navEls = router.animatableNavElements($newNavbarEl, $oldNavbarEl, toLarge, fromLarge, direction);
      newNavEls = navEls.newNavEls;
      oldNavEls = navEls.oldNavEls;
    }
    function animateNavbars(progress) {
      if (!(ios && dynamicNavbar))
        return;
      if (progress === 1) {
        if (toLarge) {
          $newNavbarEl.addClass("router-navbar-transition-to-large");
          $oldNavbarEl.addClass("router-navbar-transition-to-large");
        }
        if (fromLarge) {
          $newNavbarEl.addClass("router-navbar-transition-from-large");
          $oldNavbarEl.addClass("router-navbar-transition-from-large");
        }
      }
      newNavEls.forEach(function(navEl) {
        var $el = navEl.$el;
        var offset2 = direction === "forward" ? navEl.rightOffset : navEl.leftOffset;
        if (navEl.isSliding) {
          if (navEl.isSubnavbar && newIsLarge) {
            $el[0].style.setProperty("transform", "translate3d(" + offset2 * (1 - progress) + "px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)", "important");
          } else {
            $el.transform("translate3d(" + offset2 * (1 - progress) + "px,0,0)");
          }
        }
      });
      oldNavEls.forEach(function(navEl) {
        var $el = navEl.$el;
        var offset2 = direction === "forward" ? navEl.leftOffset : navEl.rightOffset;
        if (navEl.isSliding) {
          if (navEl.isSubnavbar && oldIsLarge) {
            $el.transform("translate3d(" + offset2 * progress + "px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)");
          } else {
            $el.transform("translate3d(" + offset2 * progress + "px,0,0)");
          }
        }
      });
    }
    function onDone() {
      if (router.dynamicNavbar) {
        if ($newNavbarEl) {
          $newNavbarEl.removeClass("router-navbar-transition-to-large router-navbar-transition-from-large");
          $newNavbarEl.addClass("navbar-no-title-large-transition");
          nextFrame(function() {
            $newNavbarEl.removeClass("navbar-no-title-large-transition");
          });
        }
        if ($oldNavbarEl) {
          $oldNavbarEl.removeClass("router-navbar-transition-to-large router-navbar-transition-from-large");
        }
        if ($newNavbarEl.hasClass("sliding") || $newNavbarEl.children(".navbar-inner.sliding").length) {
          $newNavbarEl.find(".title, .left, .right, .left .icon, .subnavbar").transform("");
        } else {
          $newNavbarEl.find(".sliding").transform("");
        }
        if ($oldNavbarEl.hasClass("sliding") || $oldNavbarEl.children(".navbar-inner.sliding").length) {
          $oldNavbarEl.find(".title, .left, .right, .left .icon, .subnavbar").transform("");
        } else {
          $oldNavbarEl.find(".sliding").transform("");
        }
      }
      router.$el.removeClass(routerTransitionClass);
      if (callback)
        callback();
    }
    (direction === "forward" ? $newPageEl : $oldPageEl).animationEnd(function() {
      onDone();
    });
    if (dynamicNavbar) {
      animateNavbars(0);
      nextFrame(function() {
        router.$el.addClass(routerTransitionClass);
        if (toDifferent) {
          router.el._clientLeft = router.el.clientLeft;
        }
        animateNavbars(1);
      });
    } else {
      router.$el.addClass(routerTransitionClass);
    }
  };
  _proto.removeModal = function removeModal(modalEl) {
    var router = this;
    router.removeEl(modalEl);
  };
  _proto.removeTabContent = function removeTabContent(tabEl) {
    var $tabEl = dom7_default(tabEl);
    $tabEl.html("");
  };
  _proto.removeNavbar = function removeNavbar(el) {
    var router = this;
    router.removeEl(el);
  };
  _proto.removePage = function removePage(el) {
    var $el = dom7_default(el);
    var f7Page = $el && $el[0] && $el[0].f7Page;
    var router = this;
    if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
      $el.remove();
      return;
    }
    router.removeEl(el);
  };
  _proto.removeEl = function removeEl(el) {
    if (!el)
      return;
    var router = this;
    var $el = dom7_default(el);
    if ($el.length === 0)
      return;
    $el.find(".tab").each(function(tabEl) {
      dom7_default(tabEl).children().each(function(tabChild) {
        if (tabChild.f7Component) {
          dom7_default(tabChild).trigger("tab:beforeremove");
          tabChild.f7Component.destroy();
        }
      });
    });
    if ($el[0].f7Component && $el[0].f7Component.destroy) {
      $el[0].f7Component.destroy();
    }
    if (!router.params.removeElements) {
      return;
    }
    if (router.params.removeElementsWithTimeout) {
      setTimeout(function() {
        $el.remove();
      }, router.params.removeElementsTimeout);
    } else {
      $el.remove();
    }
  };
  _proto.getPageEl = function getPageEl(content) {
    var router = this;
    if (typeof content === "string") {
      router.tempDom.innerHTML = content;
    } else {
      if (dom7_default(content).hasClass("page")) {
        return content;
      }
      router.tempDom.innerHTML = "";
      dom7_default(router.tempDom).append(content);
    }
    return router.findElement(".page", router.tempDom);
  };
  _proto.findElement = function findElement(stringSelector, container, notStacked) {
    var router = this;
    var view = router.view;
    var app = router.app;
    var modalsSelector = ".popup, .dialog, .popover, .actions-modal, .sheet-modal, .login-screen, .page";
    var $container = dom7_default(container);
    var selector = stringSelector;
    if (notStacked)
      selector += ":not(.stacked)";
    var found = $container.find(selector).filter(function(el) {
      return dom7_default(el).parents(modalsSelector).length === 0;
    });
    if (found.length > 1) {
      if (typeof view.selector === "string") {
        found = $container.find(view.selector + " " + selector);
      }
      if (found.length > 1) {
        found = $container.find("." + app.params.viewMainClass + " " + selector);
      }
    }
    if (found.length === 1)
      return found;
    if (!notStacked)
      found = router.findElement(selector, $container, true);
    if (found && found.length === 1)
      return found;
    if (found && found.length > 1)
      return dom7_default(found[0]);
    return void 0;
  };
  _proto.flattenRoutes = function flattenRoutes(routes) {
    if (routes === void 0) {
      routes = this.routes;
    }
    var router = this;
    var flattenedRoutes = [];
    routes.forEach(function(route) {
      var hasTabRoutes = false;
      if ("tabs" in route && route.tabs) {
        var mergedPathsRoutes = route.tabs.map(function(tabRoute) {
          var tRoute = extend3({}, route, {
            path: (route.path + "/" + tabRoute.path).replace("///", "/").replace("//", "/"),
            parentPath: route.path,
            tab: tabRoute
          });
          delete tRoute.tabs;
          delete tRoute.routes;
          return tRoute;
        });
        hasTabRoutes = true;
        flattenedRoutes = flattenedRoutes.concat(router.flattenRoutes(mergedPathsRoutes));
      }
      if ("detailRoutes" in route) {
        var _mergedPathsRoutes = route.detailRoutes.map(function(detailRoute) {
          var dRoute = extend3({}, detailRoute);
          dRoute.masterRoute = route;
          dRoute.masterRoutePath = route.path;
          return dRoute;
        });
        flattenedRoutes = flattenedRoutes.concat(route, router.flattenRoutes(_mergedPathsRoutes));
      }
      if ("routes" in route) {
        var _mergedPathsRoutes2 = route.routes.map(function(childRoute) {
          var cRoute = extend3({}, childRoute);
          cRoute.path = (route.path + "/" + cRoute.path).replace("///", "/").replace("//", "/");
          return cRoute;
        });
        if (hasTabRoutes) {
          flattenedRoutes = flattenedRoutes.concat(router.flattenRoutes(_mergedPathsRoutes2));
        } else {
          flattenedRoutes = flattenedRoutes.concat(route, router.flattenRoutes(_mergedPathsRoutes2));
        }
      }
      if (!("routes" in route) && !("tabs" in route && route.tabs) && !("detailRoutes" in route)) {
        flattenedRoutes.push(route);
      }
    });
    return flattenedRoutes;
  };
  _proto.parseRouteUrl = function parseRouteUrl(url) {
    if (!url)
      return {};
    var query = parseUrlQuery(url);
    var hash = url.split("#")[1];
    var params = {};
    var path = url.split("#")[0].split("?")[0];
    return {
      query,
      hash,
      params,
      url,
      path
    };
  };
  _proto.generateUrl = function generateUrl(parameters) {
    if (parameters === void 0) {
      parameters = {};
    }
    if (typeof parameters === "string") {
      return parameters;
    }
    var _parameters = parameters, name = _parameters.name, path = _parameters.path, params = _parameters.params, query = _parameters.query;
    if (!name && !path) {
      throw new Error('Framework7: "name" or "path" parameter is required');
    }
    var router = this;
    var route = name ? router.findRouteByKey("name", name) : router.findRouteByKey("path", path);
    if (!route) {
      if (name) {
        throw new Error('Framework7: route with name "' + name + '" not found');
      } else {
        throw new Error('Framework7: route with path "' + path + '" not found');
      }
    }
    var url = router.constructRouteUrl(route, {
      params,
      query
    });
    if (!url) {
      throw new Error(`Framework7: can't construct URL for route with name "` + name + '"');
    }
    return url;
  };
  _proto.constructRouteUrl = function constructRouteUrl(route, _temp) {
    var _ref = _temp === void 0 ? {} : _temp, params = _ref.params, query = _ref.query;
    var path = route.path;
    var toUrl = compile(path);
    var url;
    try {
      url = toUrl(params || {});
    } catch (error) {
      throw new Error("Framework7: error constructing route URL from passed params:\nRoute: " + path + "\n" + error.toString());
    }
    if (query) {
      if (typeof query === "string")
        url += "?" + query;
      else
        url += "?" + serializeObject(query);
    }
    return url;
  };
  _proto.findTabRoute = function findTabRoute(tabEl) {
    var router = this;
    var $tabEl = dom7_default(tabEl);
    var parentPath = router.currentRoute.route.parentPath;
    var tabId = $tabEl.attr("id");
    var flattenedRoutes = router.flattenRoutes(router.routes);
    var foundTabRoute;
    flattenedRoutes.forEach(function(route) {
      if (route.parentPath === parentPath && route.tab && route.tab.id === tabId) {
        foundTabRoute = route;
      }
    });
    return foundTabRoute;
  };
  _proto.findRouteByKey = function findRouteByKey(key, value2) {
    var router = this;
    var routes = router.routes;
    var flattenedRoutes = router.flattenRoutes(routes);
    var matchingRoute;
    flattenedRoutes.forEach(function(route) {
      if (matchingRoute)
        return;
      if (route[key] === value2) {
        matchingRoute = route;
      }
    });
    return matchingRoute;
  };
  _proto.findMatchingRoute = function findMatchingRoute(url) {
    if (!url)
      return void 0;
    var router = this;
    var routes = router.routes;
    var flattenedRoutes = router.flattenRoutes(routes);
    var _router$parseRouteUrl = router.parseRouteUrl(url), path = _router$parseRouteUrl.path, query = _router$parseRouteUrl.query, hash = _router$parseRouteUrl.hash, params = _router$parseRouteUrl.params;
    var matchingRoute;
    flattenedRoutes.forEach(function(route) {
      if (matchingRoute)
        return;
      var keys = [];
      var pathsToMatch = [route.path];
      if (route.alias) {
        if (typeof route.alias === "string")
          pathsToMatch.push(route.alias);
        else if (Array.isArray(route.alias)) {
          route.alias.forEach(function(aliasPath) {
            pathsToMatch.push(aliasPath);
          });
        }
      }
      var matched;
      pathsToMatch.forEach(function(pathToMatch) {
        if (matched)
          return;
        matched = pathToRegexp(pathToMatch, keys).exec(path);
      });
      if (matched) {
        keys.forEach(function(keyObj, index2) {
          if (typeof keyObj.name === "number")
            return;
          var paramValue = matched[index2 + 1];
          if (typeof paramValue === "undefined" || paramValue === null) {
            params[keyObj.name] = paramValue;
          } else {
            params[keyObj.name] = decodeURIComponent(paramValue);
          }
        });
        var parentPath;
        if (route.parentPath) {
          parentPath = path.split("/").slice(0, route.parentPath.split("/").length - 1).join("/");
        }
        matchingRoute = {
          query,
          hash,
          params,
          url,
          path,
          parentPath,
          route,
          name: route.name
        };
      }
    });
    return matchingRoute;
  };
  _proto.replaceRequestUrlParams = function replaceRequestUrlParams(url, options) {
    if (url === void 0) {
      url = "";
    }
    if (options === void 0) {
      options = {};
    }
    var compiledUrl = url;
    if (typeof compiledUrl === "string" && compiledUrl.indexOf("{{") >= 0 && options && options.route && options.route.params && Object.keys(options.route.params).length) {
      Object.keys(options.route.params).forEach(function(paramName) {
        var regExp = new RegExp("{{" + paramName + "}}", "g");
        compiledUrl = compiledUrl.replace(regExp, options.route.params[paramName] || "");
      });
    }
    return compiledUrl;
  };
  _proto.removeFromXhrCache = function removeFromXhrCache(url) {
    var router = this;
    var xhrCache = router.cache.xhr;
    var index2 = false;
    for (var i = 0; i < xhrCache.length; i += 1) {
      if (xhrCache[i].url === url)
        index2 = i;
    }
    if (index2 !== false)
      xhrCache.splice(index2, 1);
  };
  _proto.xhrRequest = function xhrRequest(requestUrl, options) {
    var router = this;
    var params = router.params;
    var ignoreCache = options.ignoreCache;
    var url = requestUrl;
    var hasQuery = url.indexOf("?") >= 0;
    if (params.passRouteQueryToRequest && options && options.route && options.route.query && Object.keys(options.route.query).length) {
      url += "" + (hasQuery ? "&" : "?") + serializeObject(options.route.query);
      hasQuery = true;
    }
    if (params.passRouteParamsToRequest && options && options.route && options.route.params && Object.keys(options.route.params).length) {
      url += "" + (hasQuery ? "&" : "?") + serializeObject(options.route.params);
      hasQuery = true;
    }
    if (url.indexOf("{{") >= 0) {
      url = router.replaceRequestUrlParams(url, options);
    }
    if (params.xhrCacheIgnoreGetParameters && url.indexOf("?") >= 0) {
      url = url.split("?")[0];
    }
    return new Promise(function(resolve, reject) {
      if (params.xhrCache && !ignoreCache && url.indexOf("nocache") < 0 && params.xhrCacheIgnore.indexOf(url) < 0) {
        for (var i = 0; i < router.cache.xhr.length; i += 1) {
          var cachedUrl = router.cache.xhr[i];
          if (cachedUrl.url === url) {
            if (now2() - cachedUrl.time < params.xhrCacheDuration) {
              resolve(cachedUrl.content);
              return;
            }
          }
        }
      }
      router.xhrAbortController = router.app.request.abortController();
      router.app.request({
        abortController: router.xhrAbortController,
        url,
        method: "GET",
        beforeSend: function beforeSend(xhr) {
          router.emit("routerAjaxStart", xhr, options);
        },
        complete: function complete(xhr, status) {
          router.emit("routerAjaxComplete", xhr);
          if (status !== "error" && status !== "timeout" && xhr.status >= 200 && xhr.status < 300 || xhr.status === 0) {
            if (params.xhrCache && xhr.responseText !== "") {
              router.removeFromXhrCache(url);
              router.cache.xhr.push({
                url,
                time: now2(),
                content: xhr.responseText
              });
            }
            router.emit("routerAjaxSuccess", xhr, options);
            resolve(xhr.responseText);
          } else {
            router.emit("routerAjaxError", xhr, options);
            reject(xhr);
          }
        },
        error: function error(xhr) {
          router.emit("routerAjaxError", xhr, options);
          reject(xhr);
        }
      });
    });
  };
  _proto.setNavbarPosition = function setNavbarPosition($el, position, ariaHidden) {
    var router = this;
    $el.removeClass("navbar-previous navbar-current navbar-next");
    if (position) {
      $el.addClass("navbar-" + position);
    }
    if (ariaHidden === false) {
      $el.removeAttr("aria-hidden");
    } else if (ariaHidden === true) {
      $el.attr("aria-hidden", "true");
    }
    $el.trigger("navbar:position", {
      position
    });
    router.emit("navbarPosition", $el[0], position);
  };
  _proto.setPagePosition = function setPagePosition($el, position, ariaHidden) {
    var router = this;
    $el.removeClass("page-previous page-current page-next");
    $el.addClass("page-" + position);
    if (ariaHidden === false) {
      $el.removeAttr("aria-hidden");
    } else if (ariaHidden === true) {
      $el.attr("aria-hidden", "true");
    }
    $el.trigger("page:position", {
      position
    });
    router.emit("pagePosition", $el[0], position);
  };
  _proto.removeThemeElements = function removeThemeElements(el) {
    var router = this;
    var theme = router.app.theme;
    var toRemove;
    if (theme === "ios") {
      toRemove = ".md-only, .aurora-only, .if-md, .if-aurora, .if-not-ios, .not-ios";
    } else if (theme === "md") {
      toRemove = ".ios-only, .aurora-only, .if-ios, .if-aurora, .if-not-md, .not-md";
    } else if (theme === "aurora") {
      toRemove = ".ios-only, .md-only, .if-ios, .if-md, .if-not-aurora, .not-aurora";
    }
    dom7_default(el).find(toRemove).remove();
  };
  _proto.getPageData = function getPageData(pageEl, navbarEl, from, to, route, pageFromEl) {
    if (route === void 0) {
      route = {};
    }
    var router = this;
    var $pageEl = dom7_default(pageEl).eq(0);
    var $navbarEl = dom7_default(navbarEl).eq(0);
    var currentPage = $pageEl[0].f7Page || {};
    var direction;
    var pageFrom;
    if (from === "next" && to === "current" || from === "current" && to === "previous")
      direction = "forward";
    if (from === "current" && to === "next" || from === "previous" && to === "current")
      direction = "backward";
    if (currentPage && !currentPage.fromPage) {
      var $pageFromEl = dom7_default(pageFromEl);
      if ($pageFromEl.length) {
        pageFrom = $pageFromEl[0].f7Page;
      }
    }
    pageFrom = currentPage.pageFrom || pageFrom;
    if (pageFrom && pageFrom.pageFrom) {
      pageFrom.pageFrom = null;
    }
    var page = {
      app: router.app,
      view: router.view,
      router,
      $el: $pageEl,
      el: $pageEl[0],
      $pageEl,
      pageEl: $pageEl[0],
      $navbarEl,
      navbarEl: $navbarEl[0],
      name: $pageEl.attr("data-name"),
      position: from,
      from,
      to,
      direction,
      route: currentPage.route ? currentPage.route : route,
      pageFrom
    };
    $pageEl[0].f7Page = page;
    return page;
  };
  _proto.pageCallback = function pageCallback(callback, pageEl, navbarEl, from, to, options, pageFromEl) {
    if (options === void 0) {
      options = {};
    }
    if (!pageEl)
      return;
    var router = this;
    var $pageEl = dom7_default(pageEl);
    if (!$pageEl.length)
      return;
    var $navbarEl = dom7_default(navbarEl);
    var _options = options, route = _options.route;
    var restoreScrollTopOnBack = router.params.restoreScrollTopOnBack && !(router.params.masterDetailBreakpoint > 0 && $pageEl.hasClass("page-master") && router.app.width >= router.params.masterDetailBreakpoint);
    var keepAlive = $pageEl[0].f7Page && $pageEl[0].f7Page.route && $pageEl[0].f7Page.route.route && $pageEl[0].f7Page.route.route.keepAlive;
    if (callback === "beforeRemove" && keepAlive) {
      callback = "beforeUnmount";
    }
    var camelName = "page" + (callback[0].toUpperCase() + callback.slice(1, callback.length));
    var colonName = "page:" + callback.toLowerCase();
    var page = {};
    if (callback === "beforeRemove" && $pageEl[0].f7Page) {
      page = extend3($pageEl[0].f7Page, {
        from,
        to,
        position: from
      });
    } else {
      page = router.getPageData($pageEl[0], $navbarEl[0], from, to, route, pageFromEl);
    }
    page.swipeBack = !!options.swipeBack;
    var _ref2 = options.route ? options.route.route : {}, _ref2$on = _ref2.on, on3 = _ref2$on === void 0 ? {} : _ref2$on, _ref2$once = _ref2.once, once3 = _ref2$once === void 0 ? {} : _ref2$once;
    if (options.on) {
      extend3(on3, options.on);
    }
    if (options.once) {
      extend3(once3, options.once);
    }
    function attachEvents2() {
      if ($pageEl[0].f7RouteEventsAttached)
        return;
      $pageEl[0].f7RouteEventsAttached = true;
      if (on3 && Object.keys(on3).length > 0) {
        $pageEl[0].f7RouteEventsOn = on3;
        Object.keys(on3).forEach(function(eventName) {
          on3[eventName] = on3[eventName].bind(router);
          $pageEl.on(eventNameToColonCase(eventName), on3[eventName]);
        });
      }
      if (once3 && Object.keys(once3).length > 0) {
        $pageEl[0].f7RouteEventsOnce = once3;
        Object.keys(once3).forEach(function(eventName) {
          once3[eventName] = once3[eventName].bind(router);
          $pageEl.once(eventNameToColonCase(eventName), once3[eventName]);
        });
      }
    }
    function detachEvents2() {
      if (!$pageEl[0].f7RouteEventsAttached)
        return;
      if ($pageEl[0].f7RouteEventsOn) {
        Object.keys($pageEl[0].f7RouteEventsOn).forEach(function(eventName) {
          $pageEl.off(eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOn[eventName]);
        });
      }
      if ($pageEl[0].f7RouteEventsOnce) {
        Object.keys($pageEl[0].f7RouteEventsOnce).forEach(function(eventName) {
          $pageEl.off(eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOnce[eventName]);
        });
      }
      $pageEl[0].f7RouteEventsAttached = null;
      $pageEl[0].f7RouteEventsOn = null;
      $pageEl[0].f7RouteEventsOnce = null;
      delete $pageEl[0].f7RouteEventsAttached;
      delete $pageEl[0].f7RouteEventsOn;
      delete $pageEl[0].f7RouteEventsOnce;
    }
    if (callback === "mounted") {
      attachEvents2();
    }
    if (callback === "init") {
      if (restoreScrollTopOnBack && (from === "previous" || !from) && to === "current" && router.scrollHistory[page.route.url] && !$pageEl.hasClass("no-restore-scroll")) {
        var $pageContent = $pageEl.find(".page-content");
        if ($pageContent.length > 0) {
          $pageContent = $pageContent.filter(function(pageContentEl) {
            return dom7_default(pageContentEl).parents(".tab:not(.tab-active)").length === 0 && !dom7_default(pageContentEl).is(".tab:not(.tab-active)");
          });
        }
        $pageContent.scrollTop(router.scrollHistory[page.route.url]);
      }
      attachEvents2();
      if ($pageEl[0].f7PageInitialized) {
        $pageEl.trigger("page:reinit", page);
        router.emit("pageReinit", page);
        return;
      }
      $pageEl[0].f7PageInitialized = true;
    }
    if (restoreScrollTopOnBack && callback === "beforeOut" && from === "current" && to === "previous") {
      var _$pageContent = $pageEl.find(".page-content");
      if (_$pageContent.length > 0) {
        _$pageContent = _$pageContent.filter(function(pageContentEl) {
          return dom7_default(pageContentEl).parents(".tab:not(.tab-active)").length === 0 && !dom7_default(pageContentEl).is(".tab:not(.tab-active)");
        });
      }
      router.scrollHistory[page.route.url] = _$pageContent.scrollTop();
    }
    if (restoreScrollTopOnBack && callback === "beforeOut" && from === "current" && to === "next") {
      delete router.scrollHistory[page.route.url];
    }
    $pageEl.trigger(colonName, page);
    router.emit(camelName, page);
    if (callback === "beforeRemove" || callback === "beforeUnmount") {
      detachEvents2();
      if (!keepAlive) {
        if ($pageEl[0].f7Page && $pageEl[0].f7Page.navbarEl) {
          delete $pageEl[0].f7Page.navbarEl.f7Page;
        }
        $pageEl[0].f7Page = null;
      }
    }
  };
  _proto.saveHistory = function saveHistory() {
    var router = this;
    var window2 = getWindow();
    router.view.history = router.history;
    if (router.params.browserHistory && router.params.browserHistoryStoreHistory && window2.localStorage) {
      window2.localStorage["f7router-" + router.view.id + "-history"] = JSON.stringify(router.history);
    }
  };
  _proto.restoreHistory = function restoreHistory() {
    var router = this;
    var window2 = getWindow();
    if (router.params.browserHistory && router.params.browserHistoryStoreHistory && window2.localStorage && window2.localStorage["f7router-" + router.view.id + "-history"]) {
      router.history = JSON.parse(window2.localStorage["f7router-" + router.view.id + "-history"]);
      router.view.history = router.history;
    }
  };
  _proto.clearHistory = function clearHistory() {
    var router = this;
    router.history = [];
    if (router.view)
      router.view.history = [];
    router.saveHistory();
  };
  _proto.updateCurrentUrl = function updateCurrentUrl(newUrl) {
    var router = this;
    appRouterCheck(router, "updateCurrentUrl");
    if (router.history.length) {
      router.history[router.history.length - 1] = newUrl;
    } else {
      router.history.push(newUrl);
    }
    var _router$parseRouteUrl2 = router.parseRouteUrl(newUrl), query = _router$parseRouteUrl2.query, hash = _router$parseRouteUrl2.hash, params = _router$parseRouteUrl2.params, url = _router$parseRouteUrl2.url, path = _router$parseRouteUrl2.path;
    if (router.currentRoute) {
      extend3(router.currentRoute, {
        query,
        hash,
        params,
        url,
        path
      });
    }
    if (router.params.browserHistory) {
      var browserHistoryRoot = router.params.browserHistoryRoot || "";
      history_default.replace(router.view.id, {
        url: newUrl
      }, browserHistoryRoot + router.params.browserHistorySeparator + newUrl);
    }
    router.saveHistory();
    router.emit("routeUrlUpdate", router.currentRoute, router);
  };
  _proto.getInitialUrl = function getInitialUrl() {
    var router = this;
    if (router.initialUrl) {
      return {
        initialUrl: router.initialUrl,
        historyRestored: router.historyRestored
      };
    }
    var app = router.app, view = router.view;
    var document2 = getDocument();
    var window2 = getWindow();
    var location = app.params.url && typeof app.params.url === "string" && typeof URL !== "undefined" ? new URL(app.params.url) : document2.location;
    var initialUrl = router.params.url;
    var documentUrl = location.href.split(location.origin)[1];
    var historyRestored;
    var _router$params = router.params, browserHistory = _router$params.browserHistory, browserHistoryOnLoad = _router$params.browserHistoryOnLoad, browserHistorySeparator = _router$params.browserHistorySeparator;
    var browserHistoryRoot = router.params.browserHistoryRoot;
    if ((window2.cordova || window2.Capacitor && window2.Capacitor.isNative) && browserHistory && !browserHistorySeparator && !browserHistoryRoot && location.pathname.indexOf("index.html")) {
      console.warn("Framework7: wrong or not complete browserHistory configuration, trying to guess browserHistoryRoot");
      browserHistoryRoot = location.pathname.split("index.html")[0];
    }
    if (!browserHistory || !browserHistoryOnLoad) {
      if (!initialUrl) {
        initialUrl = documentUrl;
      }
      if (location.search && initialUrl.indexOf("?") < 0) {
        initialUrl += location.search;
      }
      if (location.hash && initialUrl.indexOf("#") < 0) {
        initialUrl += location.hash;
      }
    } else {
      if (browserHistoryRoot && documentUrl.indexOf(browserHistoryRoot) >= 0) {
        documentUrl = documentUrl.split(browserHistoryRoot)[1];
        if (documentUrl === "")
          documentUrl = "/";
      }
      if (browserHistorySeparator.length > 0 && documentUrl.indexOf(browserHistorySeparator) >= 0) {
        initialUrl = documentUrl.split(browserHistorySeparator)[1];
      } else {
        initialUrl = documentUrl;
      }
      router.restoreHistory();
      if (router.history.indexOf(initialUrl) >= 0) {
        router.history = router.history.slice(0, router.history.indexOf(initialUrl) + 1);
      } else if (router.params.url === initialUrl) {
        router.history = [initialUrl];
      } else if (history_default.state && history_default.state[view.id] && history_default.state[view.id].url === router.history[router.history.length - 1]) {
        initialUrl = router.history[router.history.length - 1];
      } else {
        router.history = [documentUrl.split(browserHistorySeparator)[0] || "/", initialUrl];
      }
      if (router.history.length > 1) {
        historyRestored = true;
      } else {
        router.history = [];
      }
      router.saveHistory();
    }
    router.initialUrl = initialUrl;
    router.historyRestored = historyRestored;
    return {
      initialUrl,
      historyRestored
    };
  };
  _proto.init = function init15() {
    var router = this;
    var app = router.app, view = router.view;
    var document2 = getDocument();
    router.mount();
    var _router$getInitialUrl = router.getInitialUrl(), initialUrl = _router$getInitialUrl.initialUrl, historyRestored = _router$getInitialUrl.historyRestored;
    if (view && router.params.iosSwipeBack && app.theme === "ios" || view && router.params.mdSwipeBack && app.theme === "md" || view && router.params.auroraSwipeBack && app.theme === "aurora") {
      swipe_back_default(router);
    }
    var _router$params2 = router.params, browserHistory = _router$params2.browserHistory, browserHistoryOnLoad = _router$params2.browserHistoryOnLoad, browserHistoryAnimateOnLoad = _router$params2.browserHistoryAnimateOnLoad, browserHistoryInitialMatch = _router$params2.browserHistoryInitialMatch;
    var currentRoute;
    if (router.history.length > 1) {
      var initUrl = browserHistoryInitialMatch ? initialUrl : router.history[0];
      currentRoute = router.findMatchingRoute(initUrl);
      if (!currentRoute) {
        currentRoute = extend3(router.parseRouteUrl(initUrl), {
          route: {
            url: initUrl,
            path: initUrl.split("?")[0]
          }
        });
      }
    } else {
      currentRoute = router.findMatchingRoute(initialUrl);
      if (!currentRoute) {
        currentRoute = extend3(router.parseRouteUrl(initialUrl), {
          route: {
            url: initialUrl,
            path: initialUrl.split("?")[0]
          }
        });
      }
    }
    if (router.params.stackPages) {
      router.$el.children(".page").each(function(pageEl) {
        var $pageEl = dom7_default(pageEl);
        router.initialPages.push($pageEl[0]);
        if (router.dynamicNavbar && $pageEl.children(".navbar").length > 0) {
          router.initialNavbars.push($pageEl.children(".navbar")[0]);
        }
      });
    }
    if (router.$el.children(".page:not(.stacked)").length === 0 && initialUrl && router.params.loadInitialPage) {
      router.navigate(initialUrl, {
        initial: true,
        reloadCurrent: true,
        browserHistory: false,
        animate: false,
        once: {
          modalOpen: function modalOpen() {
            if (!historyRestored)
              return;
            var preloadPreviousPage2 = router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"];
            if (preloadPreviousPage2 && router.history.length > 1) {
              router.back({
                preload: true
              });
            }
          },
          pageAfterIn: function pageAfterIn() {
            if (!historyRestored)
              return;
            var preloadPreviousPage2 = router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"];
            if (preloadPreviousPage2 && router.history.length > 1) {
              router.back({
                preload: true
              });
            }
          }
        }
      });
    } else if (router.$el.children(".page:not(.stacked)").length) {
      var hasTabRoute;
      router.currentRoute = currentRoute;
      router.$el.children(".page:not(.stacked)").each(function(pageEl) {
        var $pageEl = dom7_default(pageEl);
        var $navbarEl;
        router.setPagePosition($pageEl, "current");
        if (router.dynamicNavbar) {
          $navbarEl = $pageEl.children(".navbar");
          if ($navbarEl.length > 0) {
            if (!router.$navbarsEl.parents(document2).length) {
              router.$el.prepend(router.$navbarsEl);
            }
            router.setNavbarPosition($navbarEl, "current");
            router.$navbarsEl.append($navbarEl);
            if ($navbarEl.children(".title-large").length) {
              $navbarEl.addClass("navbar-large");
            }
            $pageEl.children(".navbar").remove();
          } else {
            router.$navbarsEl.addClass("navbar-hidden");
            if ($navbarEl.children(".title-large").length) {
              router.$navbarsEl.addClass("navbar-hidden navbar-large-hidden");
            }
          }
        }
        if (router.currentRoute && router.currentRoute.route && (router.currentRoute.route.master === true || typeof router.currentRoute.route.master === "function" && router.currentRoute.route.master(app, router)) && router.params.masterDetailBreakpoint > 0) {
          $pageEl.addClass("page-master");
          $pageEl.trigger("page:role", {
            role: "master"
          });
          if ($navbarEl && $navbarEl.length) {
            $navbarEl.addClass("navbar-master");
          }
          view.checkMasterDetailBreakpoint();
        }
        var initOptions = {
          route: router.currentRoute
        };
        if (router.currentRoute && router.currentRoute.route && router.currentRoute.route.options) {
          extend3(initOptions, router.currentRoute.route.options);
        }
        router.currentPageEl = $pageEl[0];
        if (router.dynamicNavbar && $navbarEl.length) {
          router.currentNavbarEl = $navbarEl[0];
        }
        router.removeThemeElements($pageEl);
        if (router.dynamicNavbar && $navbarEl.length) {
          router.removeThemeElements($navbarEl);
        }
        if (initOptions.route.route.tab) {
          hasTabRoute = true;
          router.tabLoad(initOptions.route.route.tab, extend3({}, initOptions));
        }
        router.pageCallback("init", $pageEl, $navbarEl, "current", void 0, initOptions);
        router.pageCallback("beforeIn", $pageEl, $navbarEl, "current", void 0, initOptions);
        router.pageCallback("afterIn", $pageEl, $navbarEl, "current", void 0, initOptions);
      });
      if (historyRestored) {
        if (browserHistoryInitialMatch) {
          var preloadPreviousPage = router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"];
          if (preloadPreviousPage && router.history.length > 1) {
            router.back({
              preload: true
            });
          }
        } else {
          router.navigate(initialUrl, {
            initial: true,
            browserHistory: false,
            history: false,
            animate: browserHistoryAnimateOnLoad,
            once: {
              pageAfterIn: function pageAfterIn() {
                var preloadPreviousPage2 = router.params.preloadPreviousPage || router.params[app.theme + "SwipeBack"];
                if (preloadPreviousPage2 && router.history.length > 2) {
                  router.back({
                    preload: true
                  });
                }
              }
            }
          });
        }
      }
      if (!historyRestored && !hasTabRoute) {
        router.history.push(initialUrl);
        router.saveHistory();
      }
    }
    if (initialUrl && browserHistory && browserHistoryOnLoad && (!history_default.state || !history_default.state[view.id])) {
      history_default.initViewState(view.id, {
        url: initialUrl
      });
    }
    router.emit("local::init routerInit", router);
  };
  _proto.destroy = function destroy5() {
    var router = this;
    router.emit("local::destroy routerDestroy", router);
    Object.keys(router).forEach(function(routerProp) {
      router[routerProp] = null;
      delete router[routerProp];
    });
    router = null;
  };
  return Router2;
}(class_default);
Router.prototype.navigate = navigate;
Router.prototype.refreshPage = refreshPage;
Router.prototype.tabLoad = tabLoad;
Router.prototype.tabRemove = tabRemove;
Router.prototype.modalLoad = modalLoad;
Router.prototype.modalRemove = modalRemove;
Router.prototype.back = back2;
Router.prototype.clearPreviousHistory = clearPreviousHistory;
var router_class_default = Router;

// node_modules/framework7/esm/modules/router/router.js
var router_default = {
  name: "router",
  static: {
    Router: router_class_default
  },
  instance: {
    cache: {
      xhr: [],
      templates: [],
      components: []
    }
  },
  create: function create8() {
    var instance = this;
    if (instance.app) {
      if (instance.params.router) {
        instance.router = new router_class_default(instance.app, instance);
      }
    } else {
      instance.router = new router_class_default(instance);
    }
  }
};

// node_modules/framework7/esm/components/view/resizable-view.js
function resizableView(view) {
  var app = view.app;
  var support3 = getSupport2();
  if (view.resizableInitialized)
    return;
  extend3(view, {
    resizable: true,
    resizableWidth: null,
    resizableInitialized: true
  });
  var $htmlEl = dom7_default("html");
  var $el = view.$el;
  if (!$el)
    return;
  var $resizeHandlerEl;
  var isTouched;
  var isMoved;
  var touchesStart = {};
  var touchesDiff;
  var width2;
  var minWidth;
  var maxWidth;
  function transformCSSWidth(v) {
    if (!v)
      return null;
    if (v.indexOf("%") >= 0 || v.indexOf("vw") >= 0) {
      return parseInt(v, 10) / 100 * app.width;
    }
    var newV = parseInt(v, 10);
    if (Number.isNaN(newV))
      return null;
    return newV;
  }
  function isResizable() {
    return view.resizable && $el.hasClass("view-resizable") && $el.hasClass("view-master-detail");
  }
  function handleTouchStart(e) {
    if (!isResizable())
      return;
    touchesStart.x = e.type === "touchstart" ? e.targetTouches[0].pageX : e.pageX;
    touchesStart.y = e.type === "touchstart" ? e.targetTouches[0].pageY : e.pageY;
    isMoved = false;
    isTouched = true;
    var $pageMasterEl = $el.children(".page-master");
    minWidth = transformCSSWidth($pageMasterEl.css("min-width"));
    maxWidth = transformCSSWidth($pageMasterEl.css("max-width"));
  }
  function handleTouchMove(e) {
    if (!isTouched)
      return;
    e.f7PreventSwipePanel = true;
    var pageX = e.type === "touchmove" ? e.targetTouches[0].pageX : e.pageX;
    if (!isMoved) {
      width2 = $resizeHandlerEl[0].offsetLeft + $resizeHandlerEl[0].offsetWidth;
      $el.addClass("view-resizing");
      $htmlEl.css("cursor", "col-resize");
    }
    isMoved = true;
    e.preventDefault();
    touchesDiff = pageX - touchesStart.x;
    var newWidth = width2 + touchesDiff;
    if (minWidth && !Number.isNaN(minWidth)) {
      newWidth = Math.max(newWidth, minWidth);
    }
    if (maxWidth && !Number.isNaN(maxWidth)) {
      newWidth = Math.min(newWidth, maxWidth);
    }
    newWidth = Math.min(Math.max(newWidth, 0), app.width);
    view.resizableWidth = newWidth;
    $htmlEl[0].style.setProperty("--f7-page-master-width", newWidth + "px");
    $el.trigger("view:resize", newWidth);
    view.emit("local::resize viewResize", view, newWidth);
  }
  function handleTouchEnd() {
    dom7_default("html").css("cursor", "");
    if (!isTouched || !isMoved) {
      isTouched = false;
      isMoved = false;
      return;
    }
    isTouched = false;
    isMoved = false;
    $htmlEl[0].style.setProperty("--f7-page-master-width", view.resizableWidth + "px");
    $el.removeClass("view-resizing");
  }
  function handleResize() {
    if (!view.resizableWidth)
      return;
    minWidth = transformCSSWidth($resizeHandlerEl.css("min-width"));
    maxWidth = transformCSSWidth($resizeHandlerEl.css("max-width"));
    if (minWidth && !Number.isNaN(minWidth) && view.resizableWidth < minWidth) {
      view.resizableWidth = Math.max(view.resizableWidth, minWidth);
    }
    if (maxWidth && !Number.isNaN(maxWidth) && view.resizableWidth > maxWidth) {
      view.resizableWidth = Math.min(view.resizableWidth, maxWidth);
    }
    view.resizableWidth = Math.min(Math.max(view.resizableWidth, 0), app.width);
    $htmlEl[0].style.setProperty("--f7-page-master-width", view.resizableWidth + "px");
  }
  $resizeHandlerEl = view.$el.children(".view-resize-handler");
  if (!$resizeHandlerEl.length) {
    view.$el.append('<div class="view-resize-handler"></div>');
    $resizeHandlerEl = view.$el.children(".view-resize-handler");
  }
  view.$resizeHandlerEl = $resizeHandlerEl;
  $el.addClass("view-resizable");
  var passive = support3.passiveListener ? {
    passive: true
  } : false;
  view.$el.on(app.touchEvents.start, ".view-resize-handler", handleTouchStart, passive);
  app.on("touchmove:active", handleTouchMove);
  app.on("touchend:passive", handleTouchEnd);
  app.on("resize", handleResize);
  view.on("beforeOpen", handleResize);
  view.once("viewDestroy", function() {
    $el.removeClass("view-resizable");
    view.$resizeHandlerEl.remove();
    view.$el.off(app.touchEvents.start, ".view-resize-handler", handleTouchStart, passive);
    app.off("touchmove:active", handleTouchMove);
    app.off("touchend:passive", handleTouchEnd);
    app.off("resize", handleResize);
    view.off("beforeOpen", handleResize);
  });
}
var resizable_view_default = resizableView;

// node_modules/framework7/esm/components/view/view-class.js
function _assertThisInitialized7(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _inheritsLoose7(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var View = function(_Framework7Class) {
  _inheritsLoose7(View2, _Framework7Class);
  function View2(app, el, viewParams) {
    var _this;
    if (viewParams === void 0) {
      viewParams = {};
    }
    _this = _Framework7Class.call(this, viewParams, [app]) || this;
    var view = _assertThisInitialized7(_this);
    var ssr = view.params.routerId;
    var defaults = {
      routes: [],
      routesAdd: []
    };
    if (!ssr) {
      var $el = dom7_default(el);
      if (!$el.length) {
        var message = "Framework7: can't create a View instance because ";
        message += typeof el === "string" ? 'the selector "' + el + `" didn't match any element` : "el must be an HTMLElement or Dom7 object";
        throw new Error(message);
      }
    }
    view.params = extend3({
      el
    }, defaults, app.params.view, viewParams);
    if (view.params.routes.length > 0) {
      view.routes = view.params.routes;
    } else {
      view.routes = [].concat(app.routes, view.params.routesAdd);
    }
    extend3(false, view, {
      app,
      name: view.params.name,
      main: view.params.main,
      history: [],
      scrollHistory: {}
    });
    view.useModules();
    app.views.push(view);
    if (view.main) {
      app.views.main = view;
    }
    if (view.name) {
      app.views[view.name] = view;
    }
    view.index = app.views.indexOf(view);
    var viewId;
    if (view.name) {
      viewId = "view_" + view.name;
    } else if (view.main) {
      viewId = "view_main";
    } else {
      viewId = "view_" + view.index;
    }
    view.id = viewId;
    if (!view.params.init) {
      return view || _assertThisInitialized7(_this);
    }
    if (app.initialized) {
      view.init();
    } else {
      app.on("init", function() {
        view.init();
      });
    }
    return view || _assertThisInitialized7(_this);
  }
  var _proto = View2.prototype;
  _proto.destroy = function destroy5() {
    var view = this;
    var app = view.app;
    view.$el.trigger("view:beforedestroy");
    view.emit("local::beforeDestroy viewBeforeDestroy", view);
    app.off("resize", view.checkMasterDetailBreakpoint);
    if (view.main) {
      app.views.main = null;
      delete app.views.main;
    } else if (view.name) {
      app.views[view.name] = null;
      delete app.views[view.name];
    }
    view.$el[0].f7View = null;
    delete view.$el[0].f7View;
    app.views.splice(app.views.indexOf(view), 1);
    if (view.params.router && view.router) {
      view.router.destroy();
    }
    view.emit("local::destroy viewDestroy", view);
    Object.keys(view).forEach(function(viewProp) {
      view[viewProp] = null;
      delete view[viewProp];
    });
    view = null;
  };
  _proto.checkMasterDetailBreakpoint = function checkMasterDetailBreakpoint(force) {
    var view = this;
    var app = view.app;
    var wasMasterDetail = view.$el.hasClass("view-master-detail");
    var isMasterDetail = app.width >= view.params.masterDetailBreakpoint && view.$el.children(".page-master").length;
    if (typeof force === "undefined" && isMasterDetail || force === true) {
      view.$el.addClass("view-master-detail");
      if (!wasMasterDetail) {
        view.emit("local::masterDetailBreakpoint viewMasterDetailBreakpoint", view);
        view.$el.trigger("view:masterDetailBreakpoint");
      }
    } else {
      view.$el.removeClass("view-master-detail");
      if (wasMasterDetail) {
        view.emit("local::masterDetailBreakpoint viewMasterDetailBreakpoint", view);
        view.$el.trigger("view:masterDetailBreakpoint");
      }
    }
  };
  _proto.initMasterDetail = function initMasterDetail() {
    var view = this;
    var app = view.app;
    view.checkMasterDetailBreakpoint = view.checkMasterDetailBreakpoint.bind(view);
    view.checkMasterDetailBreakpoint();
    if (view.params.masterDetailResizable) {
      resizable_view_default(view);
    }
    app.on("resize", view.checkMasterDetailBreakpoint);
  };
  _proto.mount = function mount(viewEl) {
    var view = this;
    var app = view.app;
    var el = view.params.el || viewEl;
    var $el = dom7_default(el);
    var selector;
    if (typeof el === "string")
      selector = el;
    else {
      selector = ($el.attr("id") ? "#" + $el.attr("id") : "") + ($el.attr("class") ? "." + $el.attr("class").replace(/ /g, ".").replace(".active", "") : "");
    }
    var $navbarsEl;
    if (app.theme === "ios" && view.params.iosDynamicNavbar) {
      $navbarsEl = $el.children(".navbars").eq(0);
      if ($navbarsEl.length === 0) {
        $navbarsEl = dom7_default('<div class="navbars"></div>');
      }
    }
    extend3(view, {
      $el,
      el: $el[0],
      main: view.main || $el.hasClass("view-main"),
      $navbarsEl,
      navbarsEl: $navbarsEl ? $navbarsEl[0] : void 0,
      selector
    });
    if (view.main) {
      app.views.main = view;
    }
    if ($el && $el[0]) {
      $el[0].f7View = view;
    }
    view.emit("local::mount viewMount", view);
  };
  _proto.init = function init15(viewEl) {
    var view = this;
    view.mount(viewEl);
    if (view.params.router) {
      if (view.params.masterDetailBreakpoint > 0) {
        view.initMasterDetail();
      }
      view.router.init();
      view.$el.trigger("view:init");
      view.emit("local::init viewInit", view);
    }
  };
  return View2;
}(class_default);
View.use(router_default);
var view_class_default = View;

// node_modules/framework7/esm/components/view/view.js
function getCurrentView(app) {
  var $popoverView = dom7_default(".popover.modal-in .view");
  var $popupView = dom7_default(".popup.modal-in .view");
  var $panelView = dom7_default(".panel.panel-in .view");
  var $viewsEl = dom7_default(".views");
  if ($viewsEl.length === 0)
    $viewsEl = app.$el;
  var $viewEl = $viewsEl.children(".view");
  if ($viewEl.length === 0) {
    $viewEl = $viewsEl.children(".tabs").children(".view");
  }
  if ($viewEl.length > 1) {
    if ($viewEl.hasClass("tab")) {
      $viewEl = $viewsEl.children(".view.tab-active");
      if ($viewEl.length === 0) {
        $viewEl = $viewsEl.children(".tabs").children(".view.tab-active");
      }
    } else {
    }
  }
  if ($popoverView.length > 0 && $popoverView[0].f7View)
    return $popoverView[0].f7View;
  if ($popupView.length > 0 && $popupView[0].f7View)
    return $popupView[0].f7View;
  if ($panelView.length > 0 && $panelView[0].f7View)
    return $panelView[0].f7View;
  if ($viewEl.length > 0) {
    if ($viewEl.length === 1 && $viewEl[0].f7View)
      return $viewEl[0].f7View;
    if ($viewEl.length > 1) {
      return app.views.main;
    }
  }
  return void 0;
}
var view_default = {
  name: "view",
  params: {
    view: {
      init: true,
      name: void 0,
      main: false,
      router: true,
      linksView: null,
      stackPages: false,
      xhrCache: true,
      xhrCacheIgnore: [],
      xhrCacheIgnoreGetParameters: false,
      xhrCacheDuration: 1e3 * 60 * 10,
      componentCache: true,
      preloadPreviousPage: true,
      allowDuplicateUrls: false,
      reloadPages: false,
      reloadDetail: false,
      masterDetailBreakpoint: 0,
      masterDetailResizable: false,
      removeElements: true,
      removeElementsWithTimeout: false,
      removeElementsTimeout: 0,
      restoreScrollTopOnBack: true,
      unloadTabContent: true,
      passRouteQueryToRequest: true,
      passRouteParamsToRequest: false,
      loadInitialPage: true,
      iosSwipeBack: true,
      iosSwipeBackAnimateShadow: true,
      iosSwipeBackAnimateOpacity: true,
      iosSwipeBackActiveArea: 30,
      iosSwipeBackThreshold: 0,
      mdSwipeBack: false,
      mdSwipeBackAnimateShadow: true,
      mdSwipeBackAnimateOpacity: false,
      mdSwipeBackActiveArea: 30,
      mdSwipeBackThreshold: 0,
      auroraSwipeBack: false,
      auroraSwipeBackAnimateShadow: false,
      auroraSwipeBackAnimateOpacity: true,
      auroraSwipeBackActiveArea: 30,
      auroraSwipeBackThreshold: 0,
      browserHistory: false,
      browserHistoryRoot: void 0,
      browserHistoryAnimate: true,
      browserHistoryAnimateOnLoad: false,
      browserHistorySeparator: "#!",
      browserHistoryOnLoad: true,
      browserHistoryInitialMatch: false,
      browserHistoryStoreHistory: true,
      animate: true,
      iosDynamicNavbar: true,
      iosAnimateNavbarBackIcon: true,
      iosPageLoadDelay: 0,
      mdPageLoadDelay: 0,
      auroraPageLoadDelay: 0,
      routesBeforeEnter: null,
      routesBeforeLeave: null
    }
  },
  static: {
    View: view_class_default
  },
  create: function create9() {
    var app = this;
    extend3(app, {
      views: extend3([], {
        create: function create13(el, params) {
          return new view_class_default(app, el, params);
        },
        get: function get2(viewEl) {
          var $viewEl = dom7_default(viewEl);
          if ($viewEl.length && $viewEl[0].f7View)
            return $viewEl[0].f7View;
          return void 0;
        }
      })
    });
    Object.defineProperty(app.views, "current", {
      enumerable: true,
      configurable: true,
      get: function get2() {
        return getCurrentView(app);
      }
    });
    app.view = app.views;
  },
  on: {
    init: function init9() {
      var app = this;
      dom7_default(".view-init").each(function(viewEl) {
        if (viewEl.f7View)
          return;
        var viewParams = dom7_default(viewEl).dataset();
        app.views.create(viewEl, viewParams);
      });
    },
    "modalOpen panelOpen": function onOpen(instance) {
      var app = this;
      instance.$el.find(".view-init").each(function(viewEl) {
        if (viewEl.f7View)
          return;
        var viewParams = dom7_default(viewEl).dataset();
        app.views.create(viewEl, viewParams);
      });
    },
    "modalBeforeDestroy panelBeforeDestroy": function onClose(instance) {
      if (!instance || !instance.$el)
        return;
      instance.$el.find(".view-init").each(function(viewEl) {
        var view = viewEl.f7View;
        if (!view)
          return;
        view.destroy();
      });
    }
  },
  vnode: {
    "view-init": {
      insert: function insert2(vnode) {
        var app = this;
        var viewEl = vnode.elm;
        if (viewEl.f7View)
          return;
        var viewParams = dom7_default(viewEl).dataset();
        app.views.create(viewEl, viewParams);
      },
      destroy: function destroy4(vnode) {
        var viewEl = vnode.elm;
        var view = viewEl.f7View;
        if (!view)
          return;
        view.destroy();
      }
    }
  }
};

// node_modules/framework7/esm/modules/clicks/clicks.js
function initClicks(app) {
  function handleClicks(e) {
    var window2 = getWindow();
    var $clickedEl = dom7_default(e.target);
    var $clickedLinkEl = $clickedEl.closest("a");
    var isLink = $clickedLinkEl.length > 0;
    var url = isLink && $clickedLinkEl.attr("href");
    if (isLink) {
      if ($clickedLinkEl.is(app.params.clicks.externalLinks) || url && url.indexOf("javascript:") >= 0) {
        var target = $clickedLinkEl.attr("target");
        if (url && window2.cordova && window2.cordova.InAppBrowser && (target === "_system" || target === "_blank")) {
          e.preventDefault();
          window2.cordova.InAppBrowser.open(url, target);
        } else if (url && window2.Capacitor && window2.Capacitor.Plugins && window2.Capacitor.Plugins.Browser && (target === "_system" || target === "_blank")) {
          e.preventDefault();
          window2.Capacitor.Plugins.Browser.open({
            url
          });
        }
        return;
      }
    }
    Object.keys(app.modules).forEach(function(moduleName) {
      var moduleClicks = app.modules[moduleName].clicks;
      if (!moduleClicks)
        return;
      if (e.preventF7Router)
        return;
      Object.keys(moduleClicks).forEach(function(clickSelector) {
        var matchingClickedElement = $clickedEl.closest(clickSelector).eq(0);
        if (matchingClickedElement.length > 0) {
          moduleClicks[clickSelector].call(app, matchingClickedElement, matchingClickedElement.dataset(), e);
        }
      });
    });
    var clickedLinkData = {};
    if (isLink) {
      e.preventDefault();
      clickedLinkData = $clickedLinkEl.dataset();
    }
    clickedLinkData.clickedEl = $clickedLinkEl[0];
    if (e.preventF7Router)
      return;
    if ($clickedLinkEl.hasClass("prevent-router") || $clickedLinkEl.hasClass("router-prevent"))
      return;
    var validUrl = url && url.length > 0 && url[0] !== "#";
    if (validUrl || $clickedLinkEl.hasClass("back")) {
      var view;
      if (clickedLinkData.view && clickedLinkData.view === "current") {
        view = app.views.current;
      } else if (clickedLinkData.view) {
        view = dom7_default(clickedLinkData.view)[0].f7View;
      } else {
        view = $clickedEl.parents(".view")[0] && $clickedEl.parents(".view")[0].f7View;
        if (!$clickedLinkEl.hasClass("back") && view && view.params.linksView) {
          if (typeof view.params.linksView === "string")
            view = dom7_default(view.params.linksView)[0].f7View;
          else if (view.params.linksView instanceof view_class_default)
            view = view.params.linksView;
        }
      }
      if (!view) {
        if (app.views.main)
          view = app.views.main;
      }
      if (!view || !view.router)
        return;
      if ($clickedLinkEl[0].f7RouteProps) {
        clickedLinkData.props = $clickedLinkEl[0].f7RouteProps;
      }
      if ($clickedLinkEl.hasClass("back"))
        view.router.back(url, clickedLinkData);
      else
        view.router.navigate(url, clickedLinkData);
    }
  }
  app.on("click", handleClicks);
}
var clicks_default = {
  name: "clicks",
  params: {
    clicks: {
      externalLinks: ".external"
    }
  },
  on: {
    init: function init10() {
      var app = this;
      initClicks(app);
    }
  }
};

// node_modules/framework7/esm/modules/device/device.js
var device_default = {
  name: "device",
  static: {
    getDevice: getDevice2
  },
  on: {
    init: function init11() {
      var document2 = getDocument();
      var device2 = getDevice2();
      var classNames = [];
      var html2 = document2.querySelector("html");
      var metaStatusbar = document2.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
      if (!html2)
        return;
      if (device2.standalone && device2.ios && metaStatusbar && metaStatusbar.content === "black-translucent") {
        classNames.push("device-full-viewport");
      }
      classNames.push("device-pixel-ratio-" + Math.floor(device2.pixelRatio));
      if (device2.os && !device2.desktop) {
        classNames.push("device-" + device2.os);
      } else if (device2.desktop) {
        classNames.push("device-desktop");
        if (device2.os) {
          classNames.push("device-" + device2.os);
        }
      }
      if (device2.cordova || device2.phonegap) {
        classNames.push("device-cordova");
      }
      if (device2.capacitor) {
        classNames.push("device-capacitor");
      }
      classNames.forEach(function(className) {
        html2.classList.add(className);
      });
    }
  }
};

// node_modules/framework7/esm/modules/history/history.js
var history_default2 = {
  name: "history",
  static: {
    history: history_default
  },
  on: {
    init: function init12() {
      history_default.init(this);
    }
  }
};

// node_modules/framework7/esm/shared/request.js
function _assertThisInitialized8(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _inheritsLoose8(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _wrapNativeSuper2(Class) {
  var _cache = typeof Map === "function" ? new Map() : void 0;
  _wrapNativeSuper2 = function _wrapNativeSuper3(Class2) {
    if (Class2 === null || !_isNativeFunction2(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct4(Class2, arguments, _getPrototypeOf2(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {constructor: {value: Wrapper, enumerable: false, writable: true, configurable: true}});
    return _setPrototypeOf4(Wrapper, Class2);
  };
  return _wrapNativeSuper2(Class);
}
function _construct4(Parent, args, Class) {
  if (_isNativeReflectConstruct4()) {
    _construct4 = Reflect.construct;
  } else {
    _construct4 = function _construct5(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf4(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct4.apply(null, arguments);
}
function _isNativeReflectConstruct4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _isNativeFunction2(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _setPrototypeOf4(o, p) {
  _setPrototypeOf4 = Object.setPrototypeOf || function _setPrototypeOf5(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf4(o, p);
}
function _getPrototypeOf2(o) {
  _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf2(o);
}
var globals = {};
var jsonpRequests = 0;
var RequestResponse = function RequestResponse2(obj) {
  Object.assign(this, obj);
};
var RequestError = function(_Error) {
  _inheritsLoose8(RequestError2, _Error);
  function RequestError2(obj) {
    var _this;
    _this = _Error.call(this) || this;
    Object.assign(_assertThisInitialized8(_this), obj);
    return _this;
  }
  return RequestError2;
}(_wrapNativeSuper2(Error));
var request = function request2(requestOptions) {
  return new Promise(function(resolve, reject) {
    var window2 = getWindow();
    var document2 = getDocument();
    var globalsNoCallbacks = extend3({}, globals);
    "beforeCreate beforeOpen beforeSend error complete success statusCode".split(" ").forEach(function(callbackName2) {
      delete globalsNoCallbacks[callbackName2];
    });
    var defaults = extend3({
      url: window2.location.toString(),
      method: "GET",
      data: false,
      async: true,
      cache: true,
      user: "",
      password: "",
      headers: {},
      xhrFields: {},
      statusCode: {},
      processData: true,
      dataType: "text",
      contentType: "application/x-www-form-urlencoded",
      timeout: 0
    }, globalsNoCallbacks);
    var proceedRequest;
    var options = extend3({}, defaults, requestOptions);
    if (requestOptions.abortController) {
      options.abortController = requestOptions.abortController;
    }
    if (options.abortController && options.abortController.canceled) {
      reject(new RequestError({
        options,
        status: "canceled",
        message: "canceled"
      }));
      return;
    }
    function fireCallback(callbackName2) {
      var globalCallbackValue;
      var optionCallbackValue;
      for (var _len = arguments.length, data3 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        data3[_key - 1] = arguments[_key];
      }
      if (globals[callbackName2]) {
        globalCallbackValue = globals[callbackName2].apply(globals, data3);
      }
      if (options[callbackName2]) {
        optionCallbackValue = options[callbackName2].apply(options, data3);
      }
      if (typeof globalCallbackValue !== "boolean")
        globalCallbackValue = true;
      if (typeof optionCallbackValue !== "boolean")
        optionCallbackValue = true;
      if (options.abortController && options.abortController.canceled && (callbackName2 === "beforeCreate" || callbackName2 === "beforeOpen" || callbackName2 === "beforeSend")) {
        return false;
      }
      return globalCallbackValue && optionCallbackValue;
    }
    proceedRequest = fireCallback("beforeCreate", options);
    if (proceedRequest === false) {
      reject(new RequestError({
        options,
        status: "canceled",
        message: "canceled"
      }));
      return;
    }
    if (options.type)
      options.method = options.type;
    var paramsPrefix = options.url.indexOf("?") >= 0 ? "&" : "?";
    var method = options.method.toUpperCase();
    if ((method === "GET" || method === "HEAD" || method === "OPTIONS" || method === "DELETE") && options.data) {
      var stringData;
      if (typeof options.data === "string") {
        if (options.data.indexOf("?") >= 0)
          stringData = options.data.split("?")[1];
        else
          stringData = options.data;
      } else {
        stringData = serializeObject(options.data);
      }
      if (stringData.length) {
        options.url += paramsPrefix + stringData;
        if (paramsPrefix === "?")
          paramsPrefix = "&";
      }
    }
    if (options.dataType === "json" && options.url.indexOf("callback=") >= 0) {
      var callbackName = "f7jsonp_" + (Date.now() + (jsonpRequests += 1));
      var abortTimeout;
      var callbackSplit = options.url.split("callback=");
      var requestUrl = callbackSplit[0] + "callback=" + callbackName;
      if (callbackSplit[1].indexOf("&") >= 0) {
        var addVars = callbackSplit[1].split("&").filter(function(el) {
          return el.indexOf("=") > 0;
        }).join("&");
        if (addVars.length > 0)
          requestUrl += "&" + addVars;
      }
      var script = document2.createElement("script");
      script.type = "text/javascript";
      script.onerror = function onerror() {
        clearTimeout(abortTimeout);
        fireCallback("error", null, "scripterror", "scripterror");
        reject(new RequestError({
          options,
          status: "scripterror",
          message: "scripterror"
        }));
        fireCallback("complete", null, "scripterror");
      };
      script.src = requestUrl;
      window2[callbackName] = function jsonpCallback(data3) {
        clearTimeout(abortTimeout);
        fireCallback("success", data3);
        script.parentNode.removeChild(script);
        script = null;
        delete window2[callbackName];
        resolve(new RequestResponse({
          options,
          data: data3
        }));
      };
      document2.querySelector("head").appendChild(script);
      if (options.timeout > 0) {
        abortTimeout = setTimeout(function() {
          script.parentNode.removeChild(script);
          script = null;
          fireCallback("error", null, "timeout", "timeout");
          reject(new RequestError({
            options,
            status: "timeout",
            message: "timeout"
          }));
        }, options.timeout);
      }
      return;
    }
    if (method === "GET" || method === "HEAD" || method === "OPTIONS" || method === "DELETE") {
      if (options.cache === false) {
        options.url += paramsPrefix + "_nocache" + Date.now();
      }
    }
    var xhr = new XMLHttpRequest();
    if (options.abortController) {
      var aborted = false;
      options.abortController.onAbort = function() {
        if (aborted)
          return;
        aborted = true;
        xhr.abort();
        reject(new RequestError({
          options,
          xhr,
          status: "canceled",
          message: "canceled"
        }));
      };
    }
    xhr.requestUrl = options.url;
    xhr.requestParameters = options;
    proceedRequest = fireCallback("beforeOpen", xhr, options);
    if (proceedRequest === false) {
      reject(new RequestError({
        options,
        xhr,
        status: "canceled",
        message: "canceled"
      }));
      return;
    }
    xhr.open(method, options.url, options.async, options.user, options.password);
    var postData = null;
    if ((method === "POST" || method === "PUT" || method === "PATCH") && options.data) {
      if (options.processData) {
        var postDataInstances = [ArrayBuffer, Blob, Document, FormData];
        if (postDataInstances.indexOf(options.data.constructor) >= 0) {
          postData = options.data;
        } else {
          var boundary = "---------------------------" + Date.now().toString(16);
          if (options.contentType === "multipart/form-data") {
            xhr.setRequestHeader("Content-Type", "multipart/form-data; boundary=" + boundary);
          } else {
            xhr.setRequestHeader("Content-Type", options.contentType);
          }
          postData = "";
          var data2 = serializeObject(options.data);
          if (options.contentType === "multipart/form-data") {
            data2 = data2.split("&");
            var newData = [];
            for (var i = 0; i < data2.length; i += 1) {
              newData.push('Content-Disposition: form-data; name="' + data2[i].split("=")[0] + '"\r\n\r\n' + data2[i].split("=")[1] + "\r\n");
            }
            postData = "--" + boundary + "\r\n" + newData.join("--" + boundary + "\r\n") + "--" + boundary + "--\r\n";
          } else if (options.contentType === "application/json") {
            postData = JSON.stringify(options.data);
          } else {
            postData = data2;
          }
        }
      } else {
        postData = options.data;
        xhr.setRequestHeader("Content-Type", options.contentType);
      }
    }
    if (options.dataType === "json" && (!options.headers || !options.headers.Accept)) {
      xhr.setRequestHeader("Accept", "application/json");
    }
    if (options.headers) {
      Object.keys(options.headers).forEach(function(headerName) {
        if (typeof options.headers[headerName] === "undefined")
          return;
        xhr.setRequestHeader(headerName, options.headers[headerName]);
      });
    }
    if (typeof options.crossDomain === "undefined") {
      options.crossDomain = /^([\w-]+:)?\/\/([^\/]+)/.test(options.url) && RegExp.$2 !== window2.location.host;
    }
    if (!options.crossDomain) {
      xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
    }
    if (options.xhrFields) {
      extend3(xhr, options.xhrFields);
    }
    xhr.onload = function onload() {
      if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 0) {
        var responseData;
        if (options.dataType === "json") {
          var parseError;
          try {
            responseData = JSON.parse(xhr.responseText);
          } catch (err) {
            parseError = true;
          }
          if (!parseError) {
            fireCallback("success", responseData, xhr.status, xhr);
            resolve(new RequestResponse({
              options,
              data: responseData,
              status: xhr.status,
              xhr
            }));
          } else {
            fireCallback("error", xhr, "parseerror", "parseerror");
            reject(new RequestError({
              options,
              xhr,
              status: "parseerror",
              message: "parseerror"
            }));
          }
        } else {
          responseData = xhr.responseType === "text" || xhr.responseType === "" ? xhr.responseText : xhr.response;
          fireCallback("success", responseData, xhr.status, xhr);
          resolve(new RequestResponse({
            options,
            data: responseData,
            status: xhr.status,
            xhr
          }));
        }
      } else {
        fireCallback("error", xhr, xhr.status, xhr.statusText);
        reject(new RequestError({
          options,
          xhr,
          status: xhr.status,
          message: xhr.statusText
        }));
      }
      if (options.statusCode) {
        if (globals.statusCode && globals.statusCode[xhr.status])
          globals.statusCode[xhr.status](xhr);
        if (options.statusCode[xhr.status])
          options.statusCode[xhr.status](xhr);
      }
      fireCallback("complete", xhr, xhr.status);
    };
    xhr.onerror = function onerror() {
      fireCallback("error", xhr, xhr.status, xhr.status);
      reject(new RequestError({
        options,
        xhr,
        status: xhr.status,
        message: xhr.statusText
      }));
      fireCallback("complete", xhr, "error");
    };
    if (options.timeout > 0) {
      xhr.timeout = options.timeout;
      xhr.ontimeout = function() {
        fireCallback("error", xhr, "timeout", "timeout");
        reject(new RequestError({
          options,
          xhr,
          status: "timeout",
          message: "timeout"
        }));
        fireCallback("complete", xhr, "timeout");
      };
    }
    proceedRequest = fireCallback("beforeSend", xhr, options);
    if (proceedRequest === false) {
      reject(new RequestError({
        options,
        xhr,
        status: "canceled",
        message: "canceled"
      }));
      return;
    }
    xhr.send(postData);
  });
};
function requestShortcut(method) {
  var _ref = [], url = _ref[0], data2 = _ref[1], success = _ref[2], error = _ref[3], dataType = _ref[4];
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  if (typeof args[1] === "function") {
    url = args[0];
    success = args[1];
    error = args[2];
    dataType = args[3];
  } else {
    url = args[0];
    data2 = args[1];
    success = args[2];
    error = args[3];
    dataType = args[4];
  }
  [success, error].forEach(function(callback) {
    if (typeof callback === "string") {
      dataType = callback;
      if (callback === success)
        success = void 0;
      else
        error = void 0;
    }
  });
  dataType = dataType || (method === "json" || method === "postJSON" ? "json" : void 0);
  var requestOptions = {
    url,
    method: method === "post" || method === "postJSON" ? "POST" : "GET",
    data: data2,
    success,
    error,
    dataType
  };
  if (method === "postJSON") {
    extend3(requestOptions, {
      contentType: "application/json",
      processData: false,
      crossDomain: true,
      data: typeof data2 === "string" ? data2 : JSON.stringify(data2)
    });
  }
  return request(requestOptions);
}
Object.assign(request, {
  get: function get() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return requestShortcut.apply(void 0, ["get"].concat(args));
  },
  post: function post() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return requestShortcut.apply(void 0, ["post"].concat(args));
  },
  json: function json() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return requestShortcut.apply(void 0, ["json"].concat(args));
  },
  getJSON: function getJSON() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    return requestShortcut.apply(void 0, ["json"].concat(args));
  },
  postJSON: function postJSON() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    return requestShortcut.apply(void 0, ["postJSON"].concat(args));
  }
});
request.abortController = function() {
  var contoller = {
    canceled: false,
    onAbort: null,
    abort: function abort() {
      contoller.canceled = true;
      if (contoller.onAbort)
        contoller.onAbort();
    }
  };
  return contoller;
};
request.setup = function setup(options) {
  if (options.type && !options.method) {
    extend3(options, {
      method: options.type
    });
  }
  extend3(globals, options);
};
var request_default = request;

// node_modules/framework7/esm/modules/request/request.js
var request_default2 = {
  name: "request",
  proto: {
    request: request_default
  },
  static: {
    request: request_default
  }
};

// node_modules/framework7/esm/modules/resize/resize.js
var resize_default2 = {
  name: "resize",
  create: function create10() {
    var app = this;
    app.getSize = function() {
      if (!app.el)
        return {
          width: 0,
          height: 0,
          left: 0,
          top: 0
        };
      var offset2 = app.$el.offset();
      var _ref = [app.el.offsetWidth, app.el.offsetHeight, offset2.left, offset2.top], width2 = _ref[0], height2 = _ref[1], left = _ref[2], top = _ref[3];
      app.width = width2;
      app.height = height2;
      app.left = left;
      app.top = top;
      return {
        width: width2,
        height: height2,
        left,
        top
      };
    };
  },
  on: {
    init: function init13() {
      var app = this;
      var window2 = getWindow();
      app.getSize();
      window2.addEventListener("resize", function() {
        app.emit("resize");
      }, false);
      window2.addEventListener("orientationchange", function() {
        app.emit("orientationchange");
      });
    },
    orientationchange: function orientationchange() {
      var document2 = getDocument();
      var device2 = getDevice2();
      if (device2.ipad) {
        document2.body.scrollLeft = 0;
        setTimeout(function() {
          document2.body.scrollLeft = 0;
        }, 0);
      }
    },
    resize: function resize2() {
      var app = this;
      app.getSize();
    }
  }
};

// node_modules/framework7/esm/modules/service-worker/service-worker.js
var SW = {
  registrations: [],
  register: function register(path, scope) {
    var app = this;
    var window2 = getWindow();
    if (!("serviceWorker" in window2.navigator) || !app.serviceWorker.container) {
      return new Promise(function(resolve, reject) {
        reject(new Error("Service worker is not supported"));
      });
    }
    return new Promise(function(resolve, reject) {
      app.serviceWorker.container.register(path, scope ? {
        scope
      } : {}).then(function(reg) {
        SW.registrations.push(reg);
        app.emit("serviceWorkerRegisterSuccess", reg);
        resolve(reg);
      }).catch(function(error) {
        app.emit("serviceWorkerRegisterError", error);
        reject(error);
      });
    });
  },
  unregister: function unregister(registration) {
    var app = this;
    var window2 = getWindow();
    if (!("serviceWorker" in window2.navigator) || !app.serviceWorker.container) {
      return new Promise(function(resolve, reject) {
        reject(new Error("Service worker is not supported"));
      });
    }
    var registrations;
    if (!registration)
      registrations = SW.registrations;
    else if (Array.isArray(registration))
      registrations = registration;
    else
      registrations = [registration];
    return Promise.all(registrations.map(function(reg) {
      return new Promise(function(resolve, reject) {
        reg.unregister().then(function() {
          if (SW.registrations.indexOf(reg) >= 0) {
            SW.registrations.splice(SW.registrations.indexOf(reg), 1);
          }
          app.emit("serviceWorkerUnregisterSuccess", reg);
          resolve();
        }).catch(function(error) {
          app.emit("serviceWorkerUnregisterError", reg, error);
          reject(error);
        });
      });
    }));
  }
};
var service_worker_default = {
  name: "sw",
  params: {
    serviceWorker: {
      path: void 0,
      scope: void 0
    }
  },
  create: function create11() {
    var app = this;
    var window2 = getWindow();
    extend3(app, {
      serviceWorker: {
        container: "serviceWorker" in window2.navigator ? window2.navigator.serviceWorker : void 0,
        registrations: SW.registrations,
        register: SW.register.bind(app),
        unregister: SW.unregister.bind(app)
      }
    });
  },
  on: {
    init: function init14() {
      var window2 = getWindow();
      if (!("serviceWorker" in window2.navigator))
        return;
      var app = this;
      if (app.device.cordova || window2.Capacitor && window2.Capacitor.isNative)
        return;
      if (!app.serviceWorker.container)
        return;
      var paths = app.params.serviceWorker.path;
      var scope = app.params.serviceWorker.scope;
      if (!paths || Array.isArray(paths) && !paths.length)
        return;
      var toRegister = Array.isArray(paths) ? paths : [paths];
      toRegister.forEach(function(path) {
        app.serviceWorker.register(path, scope);
      });
    }
  }
};

// node_modules/framework7/esm/modules/store/create-store.js
function _extends4() {
  _extends4 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends4.apply(this, arguments);
}
function createStore(storeParams) {
  if (storeParams === void 0) {
    storeParams = {};
  }
  var store = {
    __store: true
  };
  var originalState = _extends4({}, storeParams.state || {});
  var actions = _extends4({}, storeParams.actions || {});
  var getters = _extends4({}, storeParams.getters || {});
  var state = extend3({}, originalState);
  var propsQueue = [];
  var gettersDependencies = {};
  var gettersCallbacks = {};
  Object.keys(getters).forEach(function(getterKey) {
    gettersDependencies[getterKey] = [];
    gettersCallbacks[getterKey] = [];
  });
  var getGetterValue = function getGetterValue2(getterKey) {
    return getters[getterKey]({
      state: store.state
    });
  };
  var addGetterDependencies = function addGetterDependencies2(getterKey, deps) {
    if (!gettersDependencies[getterKey])
      gettersDependencies[getterKey] = [];
    deps.forEach(function(dep) {
      if (gettersDependencies[getterKey].indexOf(dep) < 0) {
        gettersDependencies[getterKey].push(dep);
      }
    });
  };
  var addGetterCallback = function addGetterCallback2(getterKey, callback) {
    if (!gettersCallbacks[getterKey])
      gettersCallbacks[getterKey] = [];
    gettersCallbacks[getterKey].push(callback);
  };
  var runGetterCallbacks = function runGetterCallbacks2(stateKey) {
    var keys = Object.keys(gettersDependencies).filter(function(getterKey) {
      return gettersDependencies[getterKey].indexOf(stateKey) >= 0;
    });
    keys.forEach(function(getterKey) {
      if (!gettersCallbacks[getterKey] || !gettersCallbacks[getterKey].length)
        return;
      gettersCallbacks[getterKey].forEach(function(callback) {
        callback(getGetterValue(getterKey));
      });
    });
  };
  var removeGetterCallback = function removeGetterCallback2(callback) {
    Object.keys(gettersCallbacks).forEach(function(stateKey) {
      var callbacks = gettersCallbacks[stateKey];
      if (callbacks.indexOf(callback) >= 0) {
        callbacks.splice(callbacks.indexOf(callback), 1);
      }
    });
  };
  store.__removeCallback = function(callback) {
    removeGetterCallback(callback);
  };
  var getterValue = function getterValue2(getterKey) {
    if (getterKey === "constructor")
      return;
    propsQueue = [];
    var value2 = getGetterValue(getterKey);
    addGetterDependencies(getterKey, propsQueue);
    var onUpdated = function onUpdated2(callback2) {
      addGetterCallback(getterKey, callback2);
    };
    var obj = {
      value: value2,
      onUpdated
    };
    var callback = function callback2(v) {
      obj.value = v;
    };
    obj.__callback = callback;
    addGetterCallback(getterKey, callback);
    return obj;
  };
  store.state = new Proxy(state, {
    set: function set(target, prop2, value2) {
      target[prop2] = value2;
      runGetterCallbacks(prop2);
      return true;
    },
    get: function get2(target, prop2) {
      propsQueue.push(prop2);
      return target[prop2];
    }
  });
  store.getters = new Proxy(getters, {
    set: function set() {
      return false;
    },
    get: function get2(target, prop2) {
      if (!target[prop2]) {
        return void 0;
      }
      return getterValue(prop2);
    }
  });
  store.dispatch = function(actionName, data2) {
    return new Promise(function(resolve, reject) {
      if (!actions[actionName]) {
        reject();
        throw new Error('Framework7: Store action "' + actionName + '" is not found');
      }
      var result = actions[actionName]({
        state: store.state,
        dispatch: store.dispatch
      }, data2);
      resolve(result);
    });
  };
  return store;
}
var create_store_default = createStore;

// node_modules/framework7/esm/modules/store/store.js
var store_default = {
  name: "store",
  static: {
    createStore: create_store_default
  },
  proto: {
    createStore: create_store_default
  }
};

// node_modules/framework7/esm/modules/support/support.js
var support_default = {
  name: "support",
  static: {
    getSupport: getSupport2
  }
};

// node_modules/framework7/esm/modules/touch/touch.js
function initTouch() {
  var app = this;
  var device2 = getDevice2();
  var support3 = getSupport2();
  var window2 = getWindow();
  var document2 = getDocument();
  var params = app.params.touch;
  var useRipple = params[app.theme + "TouchRipple"];
  if (device2.ios && device2.webView) {
    window2.addEventListener("touchstart", function() {
    });
  }
  var touchStartX;
  var touchStartY;
  var targetElement;
  var isMoved;
  var tapHoldFired;
  var tapHoldTimeout;
  var preventClick;
  var activableElement;
  var activeTimeout;
  var rippleWave;
  var rippleTarget;
  var rippleTimeout;
  function findActivableElement(el) {
    var target = dom7_default(el);
    var parents2 = target.parents(params.activeStateElements);
    if (target.closest(".no-active-state").length) {
      return null;
    }
    var activable;
    if (target.is(params.activeStateElements)) {
      activable = target;
    }
    if (parents2.length > 0) {
      activable = activable ? activable.add(parents2) : parents2;
    }
    if (activable && activable.length > 1) {
      var newActivable = [];
      var preventPropagation;
      for (var i = 0; i < activable.length; i += 1) {
        if (!preventPropagation) {
          newActivable.push(activable[i]);
          if (activable.eq(i).hasClass("prevent-active-state-propagation") || activable.eq(i).hasClass("no-active-state-propagation")) {
            preventPropagation = true;
          }
        }
      }
      activable = dom7_default(newActivable);
    }
    return activable || target;
  }
  function isInsideScrollableView(el) {
    var pageContent = el.parents(".page-content");
    return pageContent.length > 0;
  }
  function addActive() {
    if (!activableElement)
      return;
    activableElement.addClass("active-state");
  }
  function removeActive() {
    if (!activableElement)
      return;
    activableElement.removeClass("active-state");
    activableElement = null;
  }
  function findRippleElement(el) {
    var rippleElements = params.touchRippleElements;
    var $el = dom7_default(el);
    if ($el.is(rippleElements)) {
      if ($el.hasClass("no-ripple")) {
        return false;
      }
      return $el;
    }
    if ($el.parents(rippleElements).length > 0) {
      var rippleParent = $el.parents(rippleElements).eq(0);
      if (rippleParent.hasClass("no-ripple")) {
        return false;
      }
      return rippleParent;
    }
    return false;
  }
  function createRipple($el, x, y) {
    if (!$el)
      return;
    rippleWave = app.touchRipple.create(app, $el, x, y);
  }
  function removeRipple() {
    if (!rippleWave)
      return;
    rippleWave.remove();
    rippleWave = void 0;
    rippleTarget = void 0;
  }
  function rippleTouchStart(el) {
    rippleTarget = findRippleElement(el);
    if (!rippleTarget || rippleTarget.length === 0) {
      rippleTarget = void 0;
      return;
    }
    var inScrollable = isInsideScrollableView(rippleTarget);
    if (!inScrollable) {
      removeRipple();
      createRipple(rippleTarget, touchStartX, touchStartY);
    } else {
      clearTimeout(rippleTimeout);
      rippleTimeout = setTimeout(function() {
        removeRipple();
        createRipple(rippleTarget, touchStartX, touchStartY);
      }, 80);
    }
  }
  function rippleTouchMove() {
    clearTimeout(rippleTimeout);
    removeRipple();
  }
  function rippleTouchEnd() {
    if (!rippleWave && rippleTarget && !isMoved) {
      clearTimeout(rippleTimeout);
      createRipple(rippleTarget, touchStartX, touchStartY);
      setTimeout(removeRipple, 0);
    } else {
      removeRipple();
    }
  }
  function handleMouseDown(e) {
    var $activableEl = findActivableElement(e.target);
    if ($activableEl) {
      $activableEl.addClass("active-state");
      if ("which" in e && e.which === 3) {
        setTimeout(function() {
          dom7_default(".active-state").removeClass("active-state");
        }, 0);
      }
    }
    if (useRipple) {
      touchStartX = e.pageX;
      touchStartY = e.pageY;
      rippleTouchStart(e.target, e.pageX, e.pageY);
    }
  }
  function handleMouseMove() {
    if (!params.activeStateOnMouseMove) {
      dom7_default(".active-state").removeClass("active-state");
    }
    if (useRipple) {
      rippleTouchMove();
    }
  }
  function handleMouseUp() {
    dom7_default(".active-state").removeClass("active-state");
    if (useRipple) {
      rippleTouchEnd();
    }
  }
  function handleTouchCancel() {
    targetElement = null;
    clearTimeout(activeTimeout);
    clearTimeout(tapHoldTimeout);
    if (params.activeState) {
      removeActive();
    }
    if (useRipple) {
      rippleTouchEnd();
    }
  }
  function handleTouchStart(e) {
    isMoved = false;
    tapHoldFired = false;
    preventClick = false;
    if (e.targetTouches.length > 1) {
      if (activableElement)
        removeActive();
      return true;
    }
    if (e.touches.length > 1 && activableElement) {
      removeActive();
    }
    if (params.tapHold) {
      if (tapHoldTimeout)
        clearTimeout(tapHoldTimeout);
      tapHoldTimeout = setTimeout(function() {
        if (e && e.touches && e.touches.length > 1)
          return;
        tapHoldFired = true;
        e.preventDefault();
        preventClick = true;
        dom7_default(e.target).trigger("taphold", e);
        app.emit("taphold", e);
      }, params.tapHoldDelay);
    }
    targetElement = e.target;
    touchStartX = e.targetTouches[0].pageX;
    touchStartY = e.targetTouches[0].pageY;
    if (params.activeState) {
      activableElement = findActivableElement(targetElement);
      if (activableElement && !isInsideScrollableView(activableElement)) {
        addActive();
      } else if (activableElement) {
        activeTimeout = setTimeout(addActive, 80);
      }
    }
    if (useRipple) {
      rippleTouchStart(targetElement, touchStartX, touchStartY);
    }
    return true;
  }
  function handleTouchMove(e) {
    var touch;
    var distance;
    if (e.type === "touchmove") {
      touch = e.targetTouches[0];
      distance = params.touchClicksDistanceThreshold;
    }
    if (distance && touch) {
      var pageX = touch.pageX;
      var pageY = touch.pageY;
      if (Math.abs(pageX - touchStartX) > distance || Math.abs(pageY - touchStartY) > distance) {
        isMoved = true;
      }
    } else {
      isMoved = true;
    }
    if (isMoved) {
      preventClick = true;
      if (params.tapHold) {
        clearTimeout(tapHoldTimeout);
      }
      if (params.activeState) {
        clearTimeout(activeTimeout);
        removeActive();
      }
      if (useRipple) {
        rippleTouchMove();
      }
    }
  }
  function handleTouchEnd(e) {
    clearTimeout(activeTimeout);
    clearTimeout(tapHoldTimeout);
    if (document2.activeElement === e.target) {
      if (params.activeState)
        removeActive();
      if (useRipple) {
        rippleTouchEnd();
      }
      return true;
    }
    if (params.activeState) {
      addActive();
      setTimeout(removeActive, 0);
    }
    if (useRipple) {
      rippleTouchEnd();
    }
    if (params.tapHoldPreventClicks && tapHoldFired || preventClick) {
      if (e.cancelable)
        e.preventDefault();
      preventClick = true;
      return false;
    }
    return true;
  }
  function handleClick(e) {
    var isOverswipe = e && e.detail && e.detail === "f7Overswipe";
    var localPreventClick = preventClick;
    if (targetElement && e.target !== targetElement) {
      if (isOverswipe) {
        localPreventClick = false;
      } else {
        localPreventClick = true;
      }
    }
    if (params.tapHold && params.tapHoldPreventClicks && tapHoldFired) {
      localPreventClick = true;
    }
    if (localPreventClick) {
      e.stopImmediatePropagation();
      e.stopPropagation();
      e.preventDefault();
    }
    if (params.tapHold) {
      tapHoldTimeout = setTimeout(function() {
        tapHoldFired = false;
      }, device2.ios || device2.androidChrome ? 100 : 400);
    }
    preventClick = false;
    targetElement = null;
    return !localPreventClick;
  }
  function emitAppTouchEvent(name, e) {
    app.emit({
      events: name,
      data: [e]
    });
  }
  function appClick(e) {
    emitAppTouchEvent("click", e);
  }
  function appTouchStartActive(e) {
    emitAppTouchEvent("touchstart touchstart:active", e);
  }
  function appTouchMoveActive(e) {
    emitAppTouchEvent("touchmove touchmove:active", e);
  }
  function appTouchEndActive(e) {
    emitAppTouchEvent("touchend touchend:active", e);
  }
  function appTouchStartPassive(e) {
    emitAppTouchEvent("touchstart:passive", e);
  }
  function appTouchMovePassive(e) {
    emitAppTouchEvent("touchmove:passive", e);
  }
  function appTouchEndPassive(e) {
    emitAppTouchEvent("touchend:passive", e);
  }
  var passiveListener = support3.passiveListener ? {
    passive: true
  } : false;
  var passiveListenerCapture = support3.passiveListener ? {
    passive: true,
    capture: true
  } : true;
  var activeListener = support3.passiveListener ? {
    passive: false
  } : false;
  var activeListenerCapture = support3.passiveListener ? {
    passive: false,
    capture: true
  } : true;
  document2.addEventListener("click", appClick, true);
  if (support3.passiveListener) {
    document2.addEventListener(app.touchEvents.start, appTouchStartActive, activeListenerCapture);
    document2.addEventListener(app.touchEvents.move, appTouchMoveActive, activeListener);
    document2.addEventListener(app.touchEvents.end, appTouchEndActive, activeListener);
    document2.addEventListener(app.touchEvents.start, appTouchStartPassive, passiveListenerCapture);
    document2.addEventListener(app.touchEvents.move, appTouchMovePassive, passiveListener);
    document2.addEventListener(app.touchEvents.end, appTouchEndPassive, passiveListener);
  } else {
    document2.addEventListener(app.touchEvents.start, function(e) {
      appTouchStartActive(e);
      appTouchStartPassive(e);
    }, true);
    document2.addEventListener(app.touchEvents.move, function(e) {
      appTouchMoveActive(e);
      appTouchMovePassive(e);
    }, false);
    document2.addEventListener(app.touchEvents.end, function(e) {
      appTouchEndActive(e);
      appTouchEndPassive(e);
    }, false);
  }
  if (support3.touch) {
    app.on("click", handleClick);
    app.on("touchstart", handleTouchStart);
    app.on("touchmove", handleTouchMove);
    app.on("touchend", handleTouchEnd);
    document2.addEventListener("touchcancel", handleTouchCancel, {
      passive: true
    });
  } else if (params.activeState) {
    app.on("touchstart", handleMouseDown);
    app.on("touchmove", handleMouseMove);
    app.on("touchend", handleMouseUp);
    document2.addEventListener("pointercancel", handleMouseUp, {
      passive: true
    });
  }
  document2.addEventListener("contextmenu", function(e) {
    if (params.disableContextMenu && (device2.ios || device2.android || device2.cordova || window2.Capacitor && window2.Capacitor.isNative)) {
      e.preventDefault();
    }
    if (useRipple) {
      if (activableElement)
        removeActive();
      rippleTouchEnd();
    }
  });
}
var touch_default = {
  name: "touch",
  params: {
    touch: {
      touchClicksDistanceThreshold: 5,
      disableContextMenu: false,
      tapHold: false,
      tapHoldDelay: 750,
      tapHoldPreventClicks: true,
      activeState: true,
      activeStateElements: "a, button, label, span, .actions-button, .stepper-button, .stepper-button-plus, .stepper-button-minus, .card-expandable, .menu-item, .link, .item-link, .accordion-item-toggle",
      activeStateOnMouseMove: false,
      mdTouchRipple: true,
      iosTouchRipple: false,
      auroraTouchRipple: false,
      touchRippleElements: ".ripple, .link, .item-link, .list-button, .links-list a, .button, button, .input-clear-button, .dialog-button, .tab-link, .item-radio, .item-checkbox, .actions-button, .searchbar-disable-button, .fab a, .checkbox, .radio, .data-table .sortable-cell:not(.input-cell), .notification-close-button, .stepper-button, .stepper-button-minus, .stepper-button-plus, .menu-item-content, .list.accordion-list .accordion-item-toggle",
      touchRippleInsetElements: ".ripple-inset, .icon-only, .searchbar-disable-button, .input-clear-button, .notification-close-button, .md .navbar .link.back"
    }
  },
  create: function create12() {
    var app = this;
    var support3 = getSupport2();
    extend3(app, {
      touchEvents: {
        start: support3.touch ? "touchstart" : support3.pointerEvents ? "pointerdown" : "mousedown",
        move: support3.touch ? "touchmove" : support3.pointerEvents ? "pointermove" : "mousemove",
        end: support3.touch ? "touchend" : support3.pointerEvents ? "pointerup" : "mouseup"
      }
    });
  },
  on: {
    init: initTouch
  }
};

// node_modules/framework7/esm/modules/utils/utils.js
var utils_default = {
  name: "utils",
  proto: {
    utils: utils_exports
  },
  static: {
    utils: utils_exports
  }
};

// node_modules/swiper/esm/components/mousewheel/mousewheel.js
function isEventSupported() {
  var document2 = getDocument();
  var eventName = "onwheel";
  var isSupported = eventName in document2;
  if (!isSupported) {
    var element = document2.createElement("div");
    element.setAttribute(eventName, "return;");
    isSupported = typeof element[eventName] === "function";
  }
  if (!isSupported && document2.implementation && document2.implementation.hasFeature && document2.implementation.hasFeature("", "") !== true) {
    isSupported = document2.implementation.hasFeature("Events.wheel", "3.0");
  }
  return isSupported;
}
var Mousewheel = {
  lastScrollTime: now(),
  lastEventBeforeSnap: void 0,
  recentWheelEvents: [],
  event: function event() {
    var window2 = getWindow();
    if (window2.navigator.userAgent.indexOf("firefox") > -1)
      return "DOMMouseScroll";
    return isEventSupported() ? "wheel" : "mousewheel";
  },
  normalize: function normalize(e) {
    var PIXEL_STEP = 10;
    var LINE_HEIGHT = 40;
    var PAGE_HEIGHT = 800;
    var sX = 0;
    var sY = 0;
    var pX = 0;
    var pY = 0;
    if ("detail" in e) {
      sY = e.detail;
    }
    if ("wheelDelta" in e) {
      sY = -e.wheelDelta / 120;
    }
    if ("wheelDeltaY" in e) {
      sY = -e.wheelDeltaY / 120;
    }
    if ("wheelDeltaX" in e) {
      sX = -e.wheelDeltaX / 120;
    }
    if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
      sX = sY;
      sY = 0;
    }
    pX = sX * PIXEL_STEP;
    pY = sY * PIXEL_STEP;
    if ("deltaY" in e) {
      pY = e.deltaY;
    }
    if ("deltaX" in e) {
      pX = e.deltaX;
    }
    if (e.shiftKey && !pX) {
      pX = pY;
      pY = 0;
    }
    if ((pX || pY) && e.deltaMode) {
      if (e.deltaMode === 1) {
        pX *= LINE_HEIGHT;
        pY *= LINE_HEIGHT;
      } else {
        pX *= PAGE_HEIGHT;
        pY *= PAGE_HEIGHT;
      }
    }
    if (pX && !sX) {
      sX = pX < 1 ? -1 : 1;
    }
    if (pY && !sY) {
      sY = pY < 1 ? -1 : 1;
    }
    return {
      spinX: sX,
      spinY: sY,
      pixelX: pX,
      pixelY: pY
    };
  },
  handleMouseEnter: function handleMouseEnter() {
    var swiper = this;
    swiper.mouseEntered = true;
  },
  handleMouseLeave: function handleMouseLeave() {
    var swiper = this;
    swiper.mouseEntered = false;
  },
  handle: function handle2(event2) {
    var e = event2;
    var disableParentSwiper = true;
    var swiper = this;
    var params = swiper.params.mousewheel;
    if (swiper.params.cssMode) {
      e.preventDefault();
    }
    var target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarget !== "container") {
      target = dom_default(swiper.params.mousewheel.eventsTarget);
    }
    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges)
      return true;
    if (e.originalEvent)
      e = e.originalEvent;
    var delta = 0;
    var rtlFactor = swiper.rtlTranslate ? -1 : 1;
    var data2 = Mousewheel.normalize(e);
    if (params.forceToAxis) {
      if (swiper.isHorizontal()) {
        if (Math.abs(data2.pixelX) > Math.abs(data2.pixelY))
          delta = -data2.pixelX * rtlFactor;
        else
          return true;
      } else if (Math.abs(data2.pixelY) > Math.abs(data2.pixelX))
        delta = -data2.pixelY;
      else
        return true;
    } else {
      delta = Math.abs(data2.pixelX) > Math.abs(data2.pixelY) ? -data2.pixelX * rtlFactor : -data2.pixelY;
    }
    if (delta === 0)
      return true;
    if (params.invert)
      delta = -delta;
    var positions = swiper.getTranslate() + delta * params.sensitivity;
    if (positions >= swiper.minTranslate())
      positions = swiper.minTranslate();
    if (positions <= swiper.maxTranslate())
      positions = swiper.maxTranslate();
    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
    if (disableParentSwiper && swiper.params.nested)
      e.stopPropagation();
    if (!swiper.params.freeMode) {
      var newEvent = {
        time: now(),
        delta: Math.abs(delta),
        direction: Math.sign(delta),
        raw: event2
      };
      var recentWheelEvents = swiper.mousewheel.recentWheelEvents;
      if (recentWheelEvents.length >= 2) {
        recentWheelEvents.shift();
      }
      var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
      recentWheelEvents.push(newEvent);
      if (prevEvent) {
        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
          swiper.mousewheel.animateSlider(newEvent);
        }
      } else {
        swiper.mousewheel.animateSlider(newEvent);
      }
      if (swiper.mousewheel.releaseScroll(newEvent)) {
        return true;
      }
    } else {
      var _newEvent = {
        time: now(),
        delta: Math.abs(delta),
        direction: Math.sign(delta)
      };
      var lastEventBeforeSnap = swiper.mousewheel.lastEventBeforeSnap;
      var ignoreWheelEvents = lastEventBeforeSnap && _newEvent.time < lastEventBeforeSnap.time + 500 && _newEvent.delta <= lastEventBeforeSnap.delta && _newEvent.direction === lastEventBeforeSnap.direction;
      if (!ignoreWheelEvents) {
        swiper.mousewheel.lastEventBeforeSnap = void 0;
        if (swiper.params.loop) {
          swiper.loopFix();
        }
        var position = swiper.getTranslate() + delta * params.sensitivity;
        var wasBeginning = swiper.isBeginning;
        var wasEnd = swiper.isEnd;
        if (position >= swiper.minTranslate())
          position = swiper.minTranslate();
        if (position <= swiper.maxTranslate())
          position = swiper.maxTranslate();
        swiper.setTransition(0);
        swiper.setTranslate(position);
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
          swiper.updateSlidesClasses();
        }
        if (swiper.params.freeModeSticky) {
          clearTimeout(swiper.mousewheel.timeout);
          swiper.mousewheel.timeout = void 0;
          var _recentWheelEvents = swiper.mousewheel.recentWheelEvents;
          if (_recentWheelEvents.length >= 15) {
            _recentWheelEvents.shift();
          }
          var _prevEvent = _recentWheelEvents.length ? _recentWheelEvents[_recentWheelEvents.length - 1] : void 0;
          var firstEvent = _recentWheelEvents[0];
          _recentWheelEvents.push(_newEvent);
          if (_prevEvent && (_newEvent.delta > _prevEvent.delta || _newEvent.direction !== _prevEvent.direction)) {
            _recentWheelEvents.splice(0);
          } else if (_recentWheelEvents.length >= 15 && _newEvent.time - firstEvent.time < 500 && firstEvent.delta - _newEvent.delta >= 1 && _newEvent.delta <= 6) {
            var snapToThreshold = delta > 0 ? 0.8 : 0.2;
            swiper.mousewheel.lastEventBeforeSnap = _newEvent;
            _recentWheelEvents.splice(0);
            swiper.mousewheel.timeout = nextTick(function() {
              swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
            }, 0);
          }
          if (!swiper.mousewheel.timeout) {
            swiper.mousewheel.timeout = nextTick(function() {
              var snapToThreshold2 = 0.5;
              swiper.mousewheel.lastEventBeforeSnap = _newEvent;
              _recentWheelEvents.splice(0);
              swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold2);
            }, 500);
          }
        }
        if (!ignoreWheelEvents)
          swiper.emit("scroll", e);
        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction)
          swiper.autoplay.stop();
        if (position === swiper.minTranslate() || position === swiper.maxTranslate())
          return true;
      }
    }
    if (e.preventDefault)
      e.preventDefault();
    else
      e.returnValue = false;
    return false;
  },
  animateSlider: function animateSlider(newEvent) {
    var swiper = this;
    var window2 = getWindow();
    if (this.params.mousewheel.thresholdDelta && newEvent.delta < this.params.mousewheel.thresholdDelta) {
      return false;
    }
    if (this.params.mousewheel.thresholdTime && now() - swiper.mousewheel.lastScrollTime < this.params.mousewheel.thresholdTime) {
      return false;
    }
    if (newEvent.delta >= 6 && now() - swiper.mousewheel.lastScrollTime < 60) {
      return true;
    }
    if (newEvent.direction < 0) {
      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
        swiper.slideNext();
        swiper.emit("scroll", newEvent.raw);
      }
    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
      swiper.slidePrev();
      swiper.emit("scroll", newEvent.raw);
    }
    swiper.mousewheel.lastScrollTime = new window2.Date().getTime();
    return false;
  },
  releaseScroll: function releaseScroll(newEvent) {
    var swiper = this;
    var params = swiper.params.mousewheel;
    if (newEvent.direction < 0) {
      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
        return true;
      }
    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
      return true;
    }
    return false;
  },
  enable: function enable() {
    var swiper = this;
    var event2 = Mousewheel.event();
    if (swiper.params.cssMode) {
      swiper.wrapperEl.removeEventListener(event2, swiper.mousewheel.handle);
      return true;
    }
    if (!event2)
      return false;
    if (swiper.mousewheel.enabled)
      return false;
    var target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarget !== "container") {
      target = dom_default(swiper.params.mousewheel.eventsTarget);
    }
    target.on("mouseenter", swiper.mousewheel.handleMouseEnter);
    target.on("mouseleave", swiper.mousewheel.handleMouseLeave);
    target.on(event2, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = true;
    return true;
  },
  disable: function disable() {
    var swiper = this;
    var event2 = Mousewheel.event();
    if (swiper.params.cssMode) {
      swiper.wrapperEl.addEventListener(event2, swiper.mousewheel.handle);
      return true;
    }
    if (!event2)
      return false;
    if (!swiper.mousewheel.enabled)
      return false;
    var target = swiper.$el;
    if (swiper.params.mousewheel.eventsTarget !== "container") {
      target = dom_default(swiper.params.mousewheel.eventsTarget);
    }
    target.off(event2, swiper.mousewheel.handle);
    swiper.mousewheel.enabled = false;
    return true;
  }
};

export {
  utils_default,
  request_default2 as request_default,
  store_default,
  support_default,
  dom7_default,
  history_default2 as history_default,
  router_default,
  subnavbar_default,
  modal_default,
  id,
  mdPreloaderContent,
  iosPreloaderContent,
  device_default,
  nextTick,
  auroraPreloaderContent,
  Mousewheel,
  now,
  getSupport2 as getSupport,
  getDocument,
  resize_default2 as resize_default,
  deleteProps2 as deleteProps,
  clicks_default,
  getTranslate,
  requestAnimationFrame,
  isObject2 as isObject,
  touch_ripple_default,
  getDevice2 as getDevice,
  nextTick2,
  dom_default,
  ModalMethods,
  nextFrame,
  now2,
  extend2 as extend,
  getWindow,
  service_worker_default,
  bindModuleMethods,
  view_default,
  ConstructorMethods,
  statusbar_default,
  getTranslate2,
  toolbar_default,
  modal_class_default,
  serializeObject,
  create_store_default,
  class_default,
  extend3 as extend2,
  colorHexToRgb,
  app_class_default,
  colorRgbToHex,
  touch_default,
  colorRgbToHsl,
  colorHslToRgb,
  colorHsbToHsl,
  request_default as request_default2,
  colorHslToHsb,
  core_class_default,
  bindMethods,
  utils_exports,
  navbar_default
};
//# sourceMappingURL=chunk-Q7SKJDY4.js.map
